{"project": "Chart", "bug_id": "1", "eval": "PASS", "patch": "        if (dataset == null) {", "rollout": 1}
{"project": "Chart", "bug_id": "3", "eval": "PASS", "patch": "        copy.minY = Double.NaN; // Initialize minY to NaN explicitly\n        copy.maxY = Double.NaN; // Initialize maxY to NaN explicitly", "rollout": 1}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "patch": "public Range getDataRange(ValueAxis axis) {\n\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (r != null) {\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n            else {\n                // Handle null renderer\n                if (isDomainAxis) {\n                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\n                }\n                else {\n                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\n                }\n            }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            }\n            else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n\n}", "rollout": 1}
{"project": "Chart", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "patch": "    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        double middle = start + ((end - start) / 2.0);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            double minMiddle = s + (e - s) / 2.0;\n            if (middle < minMiddle || middle == minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            double maxMiddle = s + (e - s) / 2.0;\n            if (middle > maxMiddle || middle == maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }", "rollout": 5}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "patch": "        this(time, zone, Locale.getDefault());", "rollout": 8}
{"project": "Chart", "bug_id": "9", "eval": "PASS", "patch": "        if (endIndex < 0 || endIndex < startIndex) {", "rollout": 1}
{"project": "Chart", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "patch": "        PathIterator iterator2 = p2.getPathIterator(null);", "rollout": 1}
{"project": "Chart", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "patch": "new Range(0.0, Math.max(0.0, constraint.getWidth() - h[2] - w[4])),", "rollout": 9}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "rollout": 1}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "26", "eval": "PASS", "patch": "    protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // It is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n            if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n            }\n        }\n        return state;\n\n    }", "rollout": 2}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "3", "eval": "PASS", "patch": "\n            return Double.valueOf(str);\n", "rollout": 1}
{"project": "Cli", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "patch": "        if (str == null) return null;", "rollout": 6}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "patch": "            pos = findWrapPos(text, width, 0);", "rollout": 4}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "patch": "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been processed\n        if (getRequiredOptions().size() > 0)\n        {\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n            // loop through the required options\n            for (int i = 0; i < getRequiredOptions().size(); i++)\n            {\n                buff.append(getRequiredOptions().get(i));\n                if (i < getRequiredOptions().size() - 1)\n                {\n                    buff.append(\", \");\n                }\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }", "rollout": 1}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "patch": "if (option.hasArg() && (option.getArgName() == null || option.getOpt().equals(\"h\")) && !required)", "rollout": 5}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "19", "eval": "PASS", "patch": "    private void processOptionToken(String token, boolean stopAtNonOption)\n    {\n        if (options.hasOption(token))\n        {\n            currentOption = options.getOption(token);\n        }\n        else if (stopAtNonOption)\n        {\n            eatTheRest = true;\n        }\n\n        // Add the token to the tokens list\n        tokens.add(token);\n    }", "rollout": 1}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "patch": "                    continue;", "rollout": 1}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "35", "eval": "PASS", "patch": "        if (longOpts.containsKey(opt)) {\n            matchingOpts.add(opt);\n            return matchingOpts;\n        }", "rollout": 3}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "patch": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1));\n    }", "rollout": 2}
{"project": "Cli", "bug_id": "38", "eval": "PASS", "patch": "private boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!token.startsWith(\"-\") || token.length() == 1)\n    {\n        return false;\n    }\n\n    // concatenate and split the token into individual characters\n    String[] optsToCheck = token.substring(1).split(\"\");\n    \n    for (String opt : optsToCheck)\n    {\n        if (options.hasShortOption(opt))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}", "rollout": 2}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "patch": "            throw new ParseException(\"Unknown class type: \" + clazz.getSimpleName());", "rollout": 1}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "patch": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n    String functionName, HashMap<String, ObjectType> properties,\n    HashMap<String, ObjectType> currentProperties,\n    ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames = null;\n\n  // Check if implicitProto is not null before calling getOwnPropertyNames\n  if (implicitProto != null) {\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n  }\n\n  if (currentPropertyNames != null) {\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n              oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n              functionName, name, oType.toString(),\n              interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n  }\n\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(t, n, functionName, properties,\n      currentProperties, iType);\n  }\n}", "rollout": 1}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "7", "eval": "PASS", "patch": "    public JSType caseObjectType(ObjectType type) {\n      if (value != null && value.equals(\"function\")) {\n        JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n        return resultEqualsValue ? ctorType : type;\n      }\n      return matchesExpectation(\"object\") ? type : null;\n    }", "rollout": 8}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "patch": "    return (Boolean) mayBeStringHelper(n);", "rollout": 4}
{"project": "Closure", "bug_id": "11", "eval": "PASS", "patch": "", "rollout": 7}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n    default:\n      // Skip non-NAME and non-GETPROP nodes\n      break;\n  }\n}", "rollout": 3}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "patch": "          !options.skipAllPasses ||", "rollout": 3}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "patch": "    return len > 0 && s.charAt(0) != '0';", "rollout": 2}
{"project": "Closure", "bug_id": "53", "eval": "PASS", "patch": "private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n    // Compute all of the assignments necessary\n    List<Node> nodes = Lists.newArrayList();\n    Node val = ref.getAssignedValue();\n    blacklistVarReferencesInTree(val, v.scope);\n    Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n    Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n    for (Node key = val.getFirstChild(); key != null;\n         key = key.getNext()) {\n        String var = key.getString();\n        Node value = key.removeFirstChild();\n        // TODO(user): Copy type information.\n        nodes.add(\n            new Node(Token.ASSIGN,\n                     Node.newString(Token.NAME, varmap.get(var)), value));\n        all.remove(var);\n    }\n\n    // TODO(user): Better source information.\n    for (String var : all) {\n        nodes.add(\n            new Node(Token.ASSIGN,\n                     Node.newString(Token.NAME, varmap.get(var)),\n                     NodeUtil.newUndefinedNode(null)));\n    }\n\n    Node replacement;\n\n    // All assignments evaluate to true, so make sure that the\n    // expr statement evaluates to true in case it matters.\n    nodes.add(new Node(Token.TRUE));\n\n    // Join these using COMMA.  A COMMA node must have 2 children, so we\n    // create a tree. In the tree the first child be the COMMA to match\n    // the parser, otherwise tree equality tests fail.\n    if (nodes.size() > 1) {\n        nodes = Lists.reverse(nodes);\n        replacement = new Node(Token.COMMA);\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n            cur.addChildToFront(nodes.get(i));\n            Node t = new Node(Token.COMMA);\n            cur.addChildToFront(t);\n            cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n    } else {\n        // If there's only one node, just use it as the replacement.\n        replacement = nodes.get(0);\n    }\n\n    Node replace = ref.getParent();\n    replacement.copyInformationFromForTree(replace);\n\n    if (replace.getType() == Token.VAR) {\n        replace.getParent().replaceChild(\n            replace, NodeUtil.newExpr(replacement));\n    } else {\n        replace.getParent().replaceChild(replace, replacement);\n    }\n}", "rollout": 2}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "patch": "          if (target != null && target.getType() == Token.STRING) {", "rollout": 3}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "62", "eval": "PASS", "patch": "&& charno >= 0) {", "rollout": 1}
{"project": "Closure", "bug_id": "65", "eval": "PASS", "patch": "        case '\\0': sb.append(\"\\\\000\"); break;", "rollout": 1}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "70", "eval": "PASS", "patch": "                  jsDocParameter != null ? jsDocParameter.getJSType() : null, false);", "rollout": 5}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "patch": "            if (c > 0x1f && c < 0x7f) {", "rollout": 4}
{"project": "Closure", "bug_id": "77", "eval": "PASS", "patch": "        case '\\0': sb.append(\"\\\\0\"); break;", "rollout": 1}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "patch": "return locals.apply(value);", "rollout": 5}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "patch": "int indexOfDot = -1;", "rollout": 12}
{"project": "Closure", "bug_id": "94", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "101", "eval": "PASS", "patch": "protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n        level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n        formattingOption.applyToOptions(options);\n    }\n\n    // Check if process_closure_primitives is set to false\n    if (!flags.process_closure_primitives) {\n        options.closurePass = false;\n    } else {\n        options.closurePass = true;\n    }\n\n    initOptionsFromFlags(options);\n    return options;\n}", "rollout": 8}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "107", "eval": "PASS", "patch": "options.messageBundle = null;", "rollout": 7}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "117", "eval": "PASS", "patch": "  String getReadableJSTypeName(Node n, boolean dereference) {\n\n    // The best type name is the actual type name.\n\n    // If we're analyzing a GETPROP, the property may be inherited by the\n    // prototype chain. So climb the prototype chain and find out where\n    // the property was originally defined.\n    if (n.isGetProp()) {\n      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n      if (objectType != null) {\n        String propName = n.getLastChild().getString();\n        \n        // Ensure the property name is properly escaped\n        propName = propName.replace(\"_\", \"\\\\_\");\n        \n        if (objectType.getConstructor() != null &&\n            objectType.getConstructor().isInterface()) {\n          objectType = FunctionType.getTopDefiningInterface(\n              objectType, propName);\n        } else {\n          // classes\n          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      return \"function\";\n    } else {\n      return type.toString();\n    }\n  }", "rollout": 1}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "119", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "122", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "patch": "  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    Node prevNode = node;\n    while (node.isGetProp()) {\n      prevNode = node;\n      node = node.getFirstChild();\n    }\n\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }", "rollout": 2}
{"project": "Closure", "bug_id": "125", "eval": "PASS", "patch": "      if (fnType != null && fnType.isConstructor()) {", "rollout": 3}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "patch": "      // if (NodeUtil.hasFinally(n)) {\n      //   Node finallyBlock = n.getLastChild();\n      //   if (NodeUtil.hasBreak(finallyBlock)) {\n      //     // Remove the break statement before the return in the try block\n      //     NodeUtil.removeChild(finallyBlock, NodeUtil.getLastChild(finallyBlock));\n      //   }\n      //   tryMinimizeExits(finallyBlock, exitType, labelName);\n      // }", "rollout": 4}
{"project": "Closure", "bug_id": "128", "eval": "PASS", "patch": "static boolean isSimpleNumber(String s) {\n    int len = s.length();\n    if (len == 0) {\n        return false;\n    }\n    for (int index = 0; index < len; index++) {\n        char c = s.charAt(index);\n        if (c < '0' || c > '9') {\n            return false;\n        }\n    }\n    // Ensure the string does not start with '0' if it contains digits\n    if (len > 1 && s.charAt(0) == '0') {\n        return false;\n    }\n    return true;\n}", "rollout": 10}
{"project": "Closure", "bug_id": "129", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "patch": "public static boolean isJSIdentifier(String s) {\n    int length = s.length();\n\n    if (length == 0 ||\n        !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n\n    for (int i = 1; i < length; i++) {\n        char c = s.charAt(i);\n        if (c < 0x0020 || c > 0x10FFFF || !Character.isJavaIdentifierPart(c)) {\n            return false;\n        }\n    }\n\n    return true;\n}", "rollout": 6}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "145", "eval": "PASS", "patch": "private boolean isOneExactlyFunctionOrDo(Node n) {\n    // Check if the node is a FUNCTION or a DO statement\n    if (n.getType() == Token.FUNCTION || n.getType() == Token.DO) {\n        return true;\n    }\n    \n    // If the node is not a FUNCTION or a DO statement, check its children\n    Node child = n.getFirstChild();\n    while (child != null) {\n        if (isOneExactlyFunctionOrDo(child)) {\n            return true;\n        }\n        child = child.getNext();\n    }\n    \n    // If no FUNCTION or DO statements are found in the children, return false\n    return false;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "152", "eval": "PASS", "patch": "    call = (ArrowType) safeResolve(call, t, scope);", "rollout": 1}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "patch": "      if (t.inGlobalScope()) {", "rollout": 7}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "patch": "        long len = binaryData.length * 4 / 3 + (binaryData.length % 3 == 0 ? 0 : 1);", "rollout": 3}
{"project": "Codec", "bug_id": "10", "eval": "PASS", "patch": "txt = txt.replaceAll(\"mb$\", \"m2\");", "rollout": 2}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "patch": "        return bytes == null ? null : new String(bytes);", "rollout": 13}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "patch": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());", "rollout": 8}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "patch": "        if (rawCentralDirectoryData.length < expectedLength || rawCentralDirectoryData.length > DWORD * (DWORD + DWORD + DWORD + WORD)) {", "rollout": 8}
{"project": "Compress", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "patch": "                dictSize += (coder.properties[i] << (8 * i));", "rollout": 11}
{"project": "Compress", "bug_id": "24", "eval": "PASS", "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\n                \"Length \" + length + \" must be at least 2 for octal parsing\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end && buffer[start] == ' ') {\n        start++;\n    }\n\n    // Trim all trailing NULs and spaces.\n    // The ustar and POSIX tar specs require a trailing NUL or\n    // space but some implementations use the extra digit for big\n    // sizes/uids/gids ...\n    while (end > start && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {\n        end--;\n    }\n\n    if (end == start) {\n        throw new IllegalArgumentException(\n                \"No octal digits found in the input\");\n    }\n\n    // Start parsing from the first non-space byte\n    while (start < end) {\n        final byte currentByte = buffer[start];\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    \"Invalid byte \" + currentByte + \" at offset \" + start + \" in '\" +\n                    new String(buffer, offset, length) + \"' len=\" + length);\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        start++;\n    }\n\n    return result;\n}", "rollout": 8}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "patch": "        if (start == end - 1 && buffer[end - 1] == 0) {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }", "rollout": 5}
{"project": "Compress", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "30", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "patch": "if (start == offset && currentByte == '0') {\n    // Skip leading '0's, but only if it's the first character\n    continue;\n}", "rollout": 4}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "patch": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    for (Entry<String, String> ent : headers.entrySet()){\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)){\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)){\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)){\n            currEntry.setGroupId(Long.parseLong(val));\n        } else if (\"gname\".equals(key)){\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)){\n            currEntry.setUserId(Long.parseLong(val));\n        } else if (\"uname\".equals(key)){\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)){\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)){\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)){\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)){\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "rollout": 1}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "38", "eval": "PASS", "patch": "        if (linkFlag == LF_DIR) {", "rollout": 1}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "patch": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if (checksum == null) {\n            throw new NullPointerException(\"Checksum\");\n        }\n        if (in == null) {\n            throw new NullPointerException(\"InputStream\");\n        }\n        this.checksum = checksum;\n        this.in = in;\n    }", "rollout": 1}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "patch": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        // Check if the binary representation will exceed the specified length\n        if (length < 9 && value < 0) {\n            formatLongBinary(value, buf, offset, length, negative);\n            return offset + length;\n        }\n\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }", "rollout": 2}
{"project": "Compress", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "patch": "public String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    \n    Integer index = mapping.get(name);\n    \n    if (index == null || index < 0 || index >= values.length) {\n        throw new IllegalArgumentException(\n                \"The record value for name '\" + name + \"' is not found in the mapping or the index is out of bounds\");\n    }\n    \n    return values[index];\n}", "rollout": 7}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "patch": "        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);", "rollout": 1}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "patch": "    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }", "rollout": 2}
{"project": "Csv", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "9", "eval": "PASS", "patch": "        if (values == null) {\n            return map; // Return the map as is if values is null\n        }\n\n        if (mapping == null || mapping.isEmpty()) {\n            return map; // Return the map as is if mapping is null or empty\n        }", "rollout": 15}
{"project": "Csv", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "patch": "                    final boolean emptyHeader = header == null || header.trim().isEmpty();", "rollout": 12}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "patch": "                if (c == COMMENT || c == ' ' || c == '\\t') {", "rollout": 16}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "patch": "                if (newRecord && (c < 0x20 || (c >= COMMENT && c <= COMMENT))) {\n                    quote = true;\n                } else if (c <= COMMENT) {", "rollout": 5}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "patch": "public char[] expandCurrentSegment()\n{\n    final char[] curr = _currentSegment;\n    final int len = curr.length;\n\n    // Set the new length to the minimum of the maximum allowed length\n    // and the current length plus one.\n    int newLen = Math.min(MAX_SEGMENT_LEN, len + 1);\n\n    // Ensure the new length is at least one more than the current length\n    // if it is not already at the maximum allowed length.\n    if (newLen <= len) {\n        newLen = len + 1;\n    }\n\n    return (_currentSegment = Arrays.copyOf(curr, newLen));\n}", "rollout": 2}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "patch": "            char c = str.charAt(i);", "rollout": 2}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "patch": "if (_inputBuffer == null) return contentsAsArray();", "rollout": 9}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "patch": "            if (i < maxCode) {", "rollout": 1}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "PASS", "patch": "return;", "rollout": 15}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "PASS", "patch": "        return (_valueTypeDeserializer != null)", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "patch": "        return _annotations.put(ann.annotationType(), ann) != null;", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "patch": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "rollout": 4}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "patch": "                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "PASS", "patch": "            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }", "rollout": 10}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "PASS", "patch": "    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n        if (id != null) {\n            return id;\n        }\n        id = generator.generateId(forPojo);\n        return id;\n    }", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "PASS", "patch": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType;\n    try {\n        serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n    } catch (JsonMappingException e) {\n        return prov.reportBadPropertyDefinition(_beanDesc, propDef, e.getMessage());\n    }\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            prov.reportBadPropertyDefinition(_beanDesc, propDef,\n                    \"serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n\n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    // 17-Aug-2016, tatu: Default inclusion covers global default (for all types), as well\n    //   as type-default for enclosing POJO. What we need, then, is per-type default (if any)\n    //   for declared property type... and finally property annotation overrides\n    JsonInclude.Value inclV = _config.getDefaultPropertyInclusion(actualType.getRawClass(),\n            _defaultInclusion);\n\n    // property annotation override\n\n    inclV = inclV.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to access values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class/type specifying it; try to find POJO property defaults\n\n        // 16-Oct-2016, tatu: Note: if we can not for some reason create \"default instance\",\n        //    revert logic to the case of general/per-property handling, so both\n        //    type-default AND null are to be excluded.\n        //    (as per [databind#1417]\n        if (_useRealPropertyDefaults) {\n            // 07-Sep-2016, tatu: may also need to front-load access forcing now\n            if (prov.isEnabled(MapperFeature.CAN_OVERRIDE_ACCESS_MODIFIERS)) {\n                am.fixAccess(_config.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n            suppressNulls = true;\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        // Check if a default value was explicitly provided\n        if (valueToSuppress != null) {\n            suppressNulls = true;\n        }\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (actualType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (actualType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}", "rollout": 13}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "patch": "                found = key.equalsIgnoreCase(prop.getName());", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "patch": "            paramName = candidate.paramName(0);", "rollout": 12}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "PASS", "patch": "        sb.append('>');", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "PASS", "patch": "        if (property == null && handledType().equals(Date.class)) {\n            return this;\n        }", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "PASS", "patch": "                        return ctxt.findContextualValueDeserializer(_baseType, _property);", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "3", "eval": "PASS", "patch": "public String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText(); // Extract the text content of the attribute\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText(); // Extract the text content of the attribute\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText; // Return the attribute value\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText(); // Extract the text content of the attribute\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n    }\n    return null;\n}", "rollout": 5}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "patch": "if (docData.startsWith(\"\\uFEFF\")) {\n    docData = docData.substring(1);\n}", "rollout": 10}
{"project": "Jsoup", "bug_id": "24", "eval": "PASS", "patch": "                // Check if the character is a single quote and skip it", "rollout": 5}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};", "rollout": 5}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "patch": "            if (offset >= 0 && offset + seq.length() <= length) {", "rollout": 1}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "patch": "doc = null;", "rollout": 1}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "patch": "attr(\"name\", name);", "rollout": 15}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "patch": "        return element.equals(o);", "rollout": 2}
{"project": "Jsoup", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "43", "eval": "PASS", "patch": "            if (element != search) continue;", "rollout": 11}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "patch": "            } else if (pos == stack.size() - 1 && !last) {", "rollout": 3}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "patch": "                            accum.append(\"&nbsp;\");", "rollout": 1}
{"project": "Jsoup", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "54", "eval": "PASS", "patch": "                if (key.length() == 0) continue;", "rollout": 1}
{"project": "Jsoup", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "patch": "                it.remove();", "rollout": 3}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "patch": "final void newAttribute() {\n    if (attributes == null)\n        attributes = new Attributes();\n\n    if (pendingAttributeName != null) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n        // Check if the trimmed pendingAttributeName is empty\n        if (pendingAttributeName.isEmpty()) {\n            // Handle empty trimmed attribute name, e.g., ignore or log\n            return;\n        }\n\n        Attribute attribute;\n        if (hasPendingAttributeValue) {\n            attribute = new Attribute(pendingAttributeName,\n                pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n        } else if (hasEmptyAttributeValue) {\n            attribute = new Attribute(pendingAttributeName, \"\");\n        } else {\n            attribute = new BooleanAttribute(pendingAttributeName);\n        }\n        attributes.put(attribute);\n    }\n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}", "rollout": 2}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "68", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "patch": "    static boolean preserveWhitespace(Node node) {\n        // check the current element\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n            if (el.tag.preserveWhitespace())\n                return true;\n        }\n        \n        // check the ancestors of the current element\n        Node parent = node.parent();\n        while (parent != null && parent instanceof Element) {\n            Element ancestor = (Element) parent;\n            if (ancestor.tag.preserveWhitespace())\n                return true;\n            parent = parent.parent();\n        }\n        \n        return false;\n    }", "rollout": 1}
{"project": "Jsoup", "bug_id": "72", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "77", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "patch": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    key = key.trim();\n    if (key.isEmpty()) {\n        throw new IllegalArgumentException(\"Key cannot be an empty string after trimming\");\n    }\n    this.key = key;\n    this.val = val;\n    this.parent = parent;\n}", "rollout": 2}
{"project": "Jsoup", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "88", "eval": "PASS", "patch": "        return val != null ? val : \"\";", "rollout": 1}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "patch": "    public String setValue(String val) {\n        // Initialize oldVal to the current value of this.val\n        String oldVal = this.val;\n        \n        // Check if the attribute has a parent\n        if (parent != null) {\n            // Get the current value from the parent\n            oldVal = parent.get(this.key);\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                // Set the value only if the parent attribute exists\n                parent.vals[i] = val;\n        }\n        \n        // Set the new value for this attribute\n        this.val = val;\n        \n        // Return the old value\n        return Attributes.checkNotNull(oldVal);\n    }", "rollout": 6}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "patch": "                i += (end - i);", "rollout": 2}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "5", "eval": "PASS", "patch": "        int index1 = p1.getIndex();\n        int index2 = p2.getIndex();\n        return index1 - index2;", "rollout": 4}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "patch": "public static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    Element element = (Element) node;\n\n    String uri = element.getNamespaceURI();\n    if (uri == null) {\n        String prefix = getPrefix(node);\n        if (prefix == null) {\n            prefix = \"xmlns\"; // Default prefix if prefix is not found\n        }\n\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = node;\n        while (aNode != null) {\n            if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode.getParentNode();\n        }\n        return null;\n    }\n    return uri;\n}", "rollout": 2}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "patch": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    // Cast both CharSequence objects to String and compare their contents\n    return String.valueOf(cs1).equals(String.valueOf(cs2));\n}", "rollout": 11}
{"project": "Lang", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "rollout": 1}
{"project": "Lang", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "24", "eval": "PASS", "patch": "return foundDigit && !hasExp && !hasDecPoint;", "rollout": 10}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "patch": "            classes[i] = array[i] == null ? null : array[i].getClass();", "rollout": 3}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "patch": "    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null && array2 == null) {\n            return null; // or throw an IllegalArgumentException as needed\n        } else if (array1 == null) {\n            return array2.clone();\n        } else if (array2 == null) {\n            return array1.clone();\n        }\n\n        final Class<?> type1 = array1.getClass().getComponentType();\n        T[] joinedArray;\n        Class<?> type2 = array2.getClass().getComponentType();\n        if (type1.equals(type2)) {\n            joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        } else if (type1.isAssignableFrom(type2)) {\n            joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        } else if (type2.isAssignableFrom(type1)) {\n            joinedArray = (T[]) Array.newInstance(type2, array1.length + array2.length);\n        } else {\n            throw new IllegalArgumentException(\"Arrays must be of the same or compatible type to be added\");\n        }\n\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n\n        return joinedArray;\n    }", "rollout": 15}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "39", "eval": "PASS", "patch": "if (replacementList[i] == null || replacementList[i].length() == 0) {\n  continue;\n}", "rollout": 5}
{"project": "Lang", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "patch": "        if (lower > str.length()) {\n            lower = str.length();\n        }", "rollout": 6}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "patch": "        return false;", "rollout": 5}
{"project": "Lang", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "53", "eval": "PASS", "patch": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n\n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n    }\n    if (field == Calendar.SECOND) {\n        done = true;\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done && (!round || seconds < 30)) {\n        time = time - (seconds * 1000L);\n    }\n    if (field == Calendar.MINUTE) {\n        done = true;\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && (!round || minutes < 30)) {\n        time = time - (minutes * 60000L);\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}", "rollout": 1}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "patch": "public void stop() {\n    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running. \");\n    }\n    if (this.runningState == STATE_RUNNING) {\n        stopTime = System.currentTimeMillis();\n    }\n    this.runningState = STATE_STOPPED;\n}", "rollout": 5}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "patch": "        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);", "rollout": 4}
{"project": "Lang", "bug_id": "58", "eval": "PASS", "patch": "&& numeric.substring(1).indexOf(0) != 0\n&& (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {", "rollout": 8}
{"project": "Lang", "bug_id": "59", "eval": "PASS", "patch": "                str.getChars(0, Math.min(strLen, width), buffer, size);", "rollout": 1}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "2", "eval": "PASS", "patch": "        return Math.max((double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(), 0);", "rollout": 1}
{"project": "Math", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "5", "eval": "PASS", "patch": "return Complex.INF;", "rollout": 1}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "11", "eval": "PASS", "patch": "return FastMath.pow(2 * FastMath.PI, -dim / 2.0) *", "rollout": 7}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "27", "eval": "PASS", "patch": "        return ((double) numerator) / denominator * 100;", "rollout": 1}
{"project": "Math", "bug_id": "28", "eval": "PASS", "patch": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            final double ratio = rhs / entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n        // 1. check if there's an artificial variable that can be forced out of the basis\n        // This check is not necessary as it was incorrect in the original code\n        // We can remove this part to simplify the logic\n\n        // 2. apply Bland's rule to prevent cycling:\n        //    take the row for which the corresponding basic variable has the smallest index\n        //\n        // see http://www.stanford.edu/class/msande310/blandrule.pdf\n        // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n        //\n        // Additional heuristic: if we did not get a solution after half of maxIterations\n        //                       revert to the simple case of just returning the top-most row\n        // This heuristic is based on empirical data gathered while investigating MATH-828.\n        int minIndex = Integer.MAX_VALUE;\n        Integer minRow = null;\n        for (Integer row : minRatioPositions) {\n            for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n                if (row == tableau.getBasicRow(i)) {\n                    int thisIndex = i;\n                    if (thisIndex < minIndex) {\n                        minIndex = thisIndex;\n                        minRow = row;\n                    }\n                }\n            }\n        }\n        return minRow;\n    }\n    return minRatioPositions.get(0);\n}", "rollout": 6}
{"project": "Math", "bug_id": "30", "eval": "PASS", "patch": "        final long n1n2prod = Math.multiplyExact(n1, n2);", "rollout": 1}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "32", "eval": "PASS", "patch": "            if (Boolean.TRUE.equals(tree.getAttribute())) {", "rollout": 5}
{"project": "Math", "bug_id": "33", "eval": "PASS", "patch": "            if (Precision.compareTo(entry, 0d, 1e-10) > 0) {", "rollout": 1}
{"project": "Math", "bug_id": "34", "eval": "PASS", "patch": "        return Collections.unmodifiableList(chromosomes).iterator();", "rollout": 9}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "41", "eval": "PASS", "patch": "                for (int i = begin; i < begin + length; i++) {", "rollout": 3}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "50", "eval": "PASS", "patch": "                    if (x == x1) {\n                        // If the new approximation is exactly the same as x1,\n                        // choose a new x0 by moving the midpoint slightly\n                        // within the interval to avoid numerical instability.\n                        double newX0 = (x0 + x1) / 2.0 + FastMath.signum(x1 - x0) * 1e-14;\n                        x0 = newX0;\n                        f0 = computeObjectiveValue(x0);\n                    }", "rollout": 2}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "57", "eval": "PASS", "patch": "            double sum = 0;", "rollout": 1}
{"project": "Math", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "59", "eval": "PASS", "patch": "        return a > b ? a : Math.max(a, b);", "rollout": 14}
{"project": "Math", "bug_id": "60", "eval": "PASS", "patch": "public double cumulativeProbability(double x) throws MathException {\n    final double dev = x - mean;\n    if (standardDeviation == 0.0) {\n        throw new IllegalArgumentException(\"Standard deviation cannot be zero.\");\n    }\n    \n    // Handle very large or very small values\n    if (dev > 30 * standardDeviation) {\n        return 1.0;\n    } else if (dev < -30 * standardDeviation) {\n        return 0.0;\n    }\n    \n    try {\n        double z = dev / (standardDeviation * FastMath.sqrt(2.0));\n        return 0.5 * (1.0 + Erf.erf(z));\n    } catch (MaxIterationsExceededException ex) {\n        // Handle the case where the erf calculation fails\n        if (x > Double.MAX_VALUE / (2 * standardDeviation * FastMath.sqrt(2))) {\n            return 1.0;\n        } else if (x < -Double.MAX_VALUE / (2 * standardDeviation * FastMath.sqrt(2))) {\n            return 0.0;\n        } else {\n            throw new MathException(\"Continued fraction diverged to NaN for value \u221e\", ex);\n        }\n    }\n}", "rollout": 8}
{"project": "Math", "bug_id": "63", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "70", "eval": "PASS", "patch": "        return solve(f, min, max);", "rollout": 4}
{"project": "Math", "bug_id": "72", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "73", "eval": "PASS", "patch": "        // Verify if the initial guess forms a bracket with min and max\n        if (yInitial * yMin >= 0 || yInitial * yMax >= 0) {\n            throw new IllegalArgumentException(\"Initial guess does not form a bracket with min and max\");\n        }", "rollout": 4}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "79", "eval": "PASS", "patch": "public static double distance(int[] p1, int[] p2) {\n    if (p1.length != p2.length) {\n        throw new IllegalArgumentException(\"Both arrays must have the same length.\");\n    }\n\n    double sum = 0.0;\n    for (int i = 0; i < p1.length; i++) {\n        double dp = p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return Math.sqrt(sum);\n}", "rollout": 13}
{"project": "Math", "bug_id": "80", "eval": "PASS", "patch": "        int j = 4 * n - 1 - 3 * (step - 1);", "rollout": 4}
{"project": "Math", "bug_id": "82", "eval": "PASS", "patch": "            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {", "rollout": 3}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "85", "eval": "PASS", "patch": "        if (function == null) {", "rollout": 13}
{"project": "Math", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "89", "eval": "PASS", "patch": "    public void addValue(Object v) {\n        if (v instanceof Comparable<?>) {\n            addValue((Comparable<?>) v);\n        } else {\n            throw new IllegalArgumentException(\"Parameter must be Comparable\");\n        }\n    }", "rollout": 1}
{"project": "Math", "bug_id": "91", "eval": "PASS", "patch": "        int nOd = numerator * object.denominator;\n        int dOn = denominator * object.numerator;", "rollout": 3}
{"project": "Math", "bug_id": "94", "eval": "PASS", "patch": "        if (u == 0 || v == 0) {", "rollout": 2}
{"project": "Math", "bug_id": "95", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "96", "eval": "PASS", "patch": "                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());", "rollout": 2}
{"project": "Math", "bug_id": "97", "eval": "PASS", "patch": "    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Define a tolerance level\n        final double TOLERANCE = 1e-9;\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            // Check if either value is close to a zero\n            if (Math.abs(yMin) < TOLERANCE) {\n                ret = min;\n            } else if (Math.abs(yMax) < TOLERANCE) {\n                ret = max;\n            } else {\n                // Neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }", "rollout": 2}
{"project": "Math", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "103", "eval": "PASS", "patch": "    public double cumulativeProbability(double x) throws MathException {\n        if (x == Double.MAX_VALUE) {\n            return Double.MAX_VALUE;\n        } else if (x == -Double.MAX_VALUE) {\n            return 0.0;\n        }\n        double scaledX = (x - mean) / (standardDeviation * Math.sqrt(2.0));\n        if (scaledX > 20.032) {\n            return 1.0;\n        } else if (scaledX < -20.032) {\n            return 0.0;\n        }\n        double erfValue = Erf.erf(scaledX);\n        return 0.5 * (1.0 + erfValue);\n    }", "rollout": 12}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "1", "eval": "PASS", "patch": "            int argsLength = invocation.getRawArguments().length - 1;", "rollout": 5}
{"project": "Mockito", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "patch": "        primitiveValues.put(double.class, (double) 0.0);", "rollout": 3}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "patch": "            if (k < i.getArguments().length && m instanceof CapturesArguments) {", "rollout": 3}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "patch": "        return (m != null && arg != null) && StringDescription.toString(m).equals(arg.toString());", "rollout": 1}
{"project": "Time", "bug_id": "4", "eval": "PASS", "patch": "    Partial newPartial = new Partial(newTypes, newValues);", "rollout": 4}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "19", "eval": "PASS", "patch": "        } else if (offsetLocal == offsetAdjusted) {", "rollout": 1}
{"project": "Time", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "23", "eval": "PASS", "patch": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }", "rollout": 1}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "11", "eval": "PASS", "patch": "      case STRING:", "rollout": 16}
{"project": "Gson", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
