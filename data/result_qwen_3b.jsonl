{"project": "Chart", "bug_id": "1", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        if (dataset == null) {", "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..ffa187c 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+        if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();"}
{"project": "Chart", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n", "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..2b4db44 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4422,101 +4422,94 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n      *\n      * @return The range.\n      */\n-    public Range getDataRange(ValueAxis axis) {\n-\n-        Range result = null;\n-        List mappedDatasets = new ArrayList();\n-        List includedAnnotations = new ArrayList();\n-        boolean isDomainAxis = true;\n-\n-        // is it a domain axis?\n-        int domainIndex = getDomainAxisIndex(axis);\n-        if (domainIndex >= 0) {\n-            isDomainAxis = true;\n-            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n-                    new Integer(domainIndex)));\n-            if (domainIndex == 0) {\n-                // grab the plot's annotations\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // or is it a range axis?\n-        int rangeIndex = getRangeAxisIndex(axis);\n-        if (rangeIndex >= 0) {\n-            isDomainAxis = false;\n-            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n-                    new Integer(rangeIndex)));\n-            if (rangeIndex == 0) {\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // iterate through the datasets that map to the axis and get the union\n-        // of the ranges.\n-        Iterator iterator = mappedDatasets.iterator();\n-        while (iterator.hasNext()) {\n-            XYDataset d = (XYDataset) iterator.next();\n-            if (d != null) {\n-                XYItemRenderer r = getRendererForDataset(d);\n-                if (isDomainAxis) {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findDomainBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findDomainBounds(d));\n-                    }\n-                }\n-                else {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findRangeBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findRangeBounds(d));\n-                    }\n-                }\n-                \n-                    Collection c = r.getAnnotations();\n-                    Iterator i = c.iterator();\n-                    while (i.hasNext()) {\n-                        XYAnnotation a = (XYAnnotation) i.next();\n-                        if (a instanceof XYAnnotationBoundsInfo) {\n-                            includedAnnotations.add(a);\n-                        }\n-                    }\n-            }\n-        }\n-\n-        Iterator it = includedAnnotations.iterator();\n-        while (it.hasNext()) {\n-            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n-            if (xyabi.getIncludeInDataBounds()) {\n-                if (isDomainAxis) {\n-                    result = Range.combine(result, xyabi.getXRange());\n-                }\n-                else {\n-                    result = Range.combine(result, xyabi.getYRange());\n-                }\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n+\n+    public Range getDataRange(ValueAxis axis) {\n+\n+        Range result = null;\n+        List mappedDatasets = new ArrayList();\n+        List includedAnnotations = new ArrayList();\n+        boolean isDomainAxis = true;\n+\n+        // is it a domain axis?\n+        int domainIndex = getDomainAxisIndex(axis);\n+        if (domainIndex >= 0) {\n+            isDomainAxis = true;\n+            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n+                    new Integer(domainIndex)));\n+            if (domainIndex == 0) {\n+                // grab the plot's annotations\n+                Iterator iterator = this.annotations.iterator();\n+                while (iterator.hasNext()) {\n+                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                    if (annotation instanceof XYAnnotationBoundsInfo) {\n+                        includedAnnotations.add(annotation);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // or is it a range axis?\n+        int rangeIndex = getRangeAxisIndex(axis);\n+        if (rangeIndex >= 0) {\n+            isDomainAxis = false;\n+            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n+                    new Integer(rangeIndex)));\n+            if (rangeIndex == 0) {\n+                Iterator iterator = this.annotations.iterator();\n+                while (iterator.hasNext()) {\n+                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                    if (annotation instanceof XYAnnotationBoundsInfo) {\n+                        includedAnnotations.add(annotation);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // iterate through the datasets that map to the axis and get the union\n+        // of the ranges.\n+        Iterator iterator = mappedDatasets.iterator();\n+        while (iterator.hasNext()) {\n+            XYDataset d = (XYDataset) iterator.next();\n+            if (d != null) {\n+                XYItemRenderer r = getRendererForDataset(d);\n+                if (isDomainAxis) {\n+                    if (r != null) {\n+                        result = Range.combine(result, r.findDomainBounds(d));\n+                    }\n+                    else {\n+                        result = Range.combine(result,\n+                                DatasetUtilities.findDomainBounds(d));\n+                    }\n+                }\n+                else {\n+                    if (r != null) {\n+                        result = Range.combine(result, r.findRangeBounds(d));\n+                    }\n+                    else {\n+                        result = Range.combine(result,\n+                                DatasetUtilities.findRangeBounds(d));\n+                    }\n+                }\n+            }\n+        }\n+\n+        Iterator it = includedAnnotations.iterator();\n+        while (it.hasNext()) {\n+            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n+            if (xyabi.getIncludeInDataBounds()) {\n+                if (isDomainAxis) {\n+                    result = Range.combine(result, xyabi.getXRange());\n+                }\n+                else {\n+                    result = Range.combine(result, xyabi.getYRange());\n+                }\n+            }\n+        }\n+\n+        return result;\n+\n+    }\n+\n \n     /**\n      * Receives notification of a change to the plot's dataset."}
{"project": "Chart", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "attempt": 7, "mode": "SF", "patch": "\n    private void updateBounds(TimePeriod period, int index) {\n\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            TimePeriod minStartPeriod = getDataItem(this.minStartIndex).getPeriod();\n            long minStart = minStartPeriod.getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;\n            }\n        } else {\n            this.minStartIndex = index;\n        }\n\n        if (this.maxStartIndex >= 0) {\n            TimePeriod maxStartPeriod = getDataItem(this.maxStartIndex).getPeriod();\n            long maxStart = maxStartPeriod.getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;\n            }\n        } else {\n            this.maxStartIndex = index;\n        }\n\n        if (this.minMiddleIndex >= 0) {\n            TimePeriod minMiddlePeriod = getDataItem(this.minMiddleIndex).getPeriod();\n            long s = minMiddlePeriod.getStart().getTime();\n            long e = minMiddlePeriod.getEnd().getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;\n            }\n        } else {\n            this.minMiddleIndex = index;\n        }\n\n        if (this.maxMiddleIndex >= 0) {\n            TimePeriod maxMiddlePeriod = getDataItem(this.maxMiddleIndex).getPeriod();\n            long s = maxMiddlePeriod.getStart().getTime();\n            long e = maxMiddlePeriod.getEnd().getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;\n            }\n        } else {\n            this.maxMiddleIndex = index;\n        }\n\n        if (this.minEndIndex >= 0) {\n            TimePeriod minEndPeriod = getDataItem(this.minEndIndex).getPeriod();\n            long minEnd = minEndPeriod.getEnd().getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;\n            }\n        } else {\n            this.minEndIndex = index;\n        }\n\n        if (this.maxEndIndex >= 0) {\n            TimePeriod maxEndPeriod = getDataItem(this.maxEndIndex).getPeriod();\n            long maxEnd = maxEndPeriod.getEnd().getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;\n            }\n        } else {\n            this.maxEndIndex = index;\n        }\n    }\n", "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..6fc1026 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -254,85 +254,78 @@ public class TimePeriodValues extends Series implements Serializable {\n      * @param period  the time period.\n      * @param index  the index of the time period.\n      */\n-    private void updateBounds(TimePeriod period, int index) {\n-        \n-        long start = period.getStart().getTime();\n-        long end = period.getEnd().getTime();\n-        long middle = start + ((end - start) / 2);\n-\n-        if (this.minStartIndex >= 0) {\n-            long minStart = getDataItem(this.minStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start < minStart) {\n-                this.minStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minStartIndex = index;\n-        }\n-        \n-        if (this.maxStartIndex >= 0) {\n-            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start > maxStart) {\n-                this.maxStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxStartIndex = index;\n-        }\n-        \n-        if (this.minMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long minMiddle = s + (e - s) / 2;\n-            if (middle < minMiddle) {\n-                this.minMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minMiddleIndex = index;\n-        }\n-        \n-        if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long maxMiddle = s + (e - s) / 2;\n-            if (middle > maxMiddle) {\n-                this.maxMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxMiddleIndex = index;\n-        }\n-        \n-        if (this.minEndIndex >= 0) {\n-            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end < minEnd) {\n-                this.minEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minEndIndex = index;\n-        }\n-       \n-        if (this.maxEndIndex >= 0) {\n-            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end > maxEnd) {\n-                this.maxEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxEndIndex = index;\n-        }\n-        \n-    }\n+\n+    private void updateBounds(TimePeriod period, int index) {\n+\n+        long start = period.getStart().getTime();\n+        long end = period.getEnd().getTime();\n+        long middle = start + ((end - start) / 2);\n+\n+        if (this.minStartIndex >= 0) {\n+            TimePeriod minStartPeriod = getDataItem(this.minStartIndex).getPeriod();\n+            long minStart = minStartPeriod.getStart().getTime();\n+            if (start < minStart) {\n+                this.minStartIndex = index;\n+            }\n+        } else {\n+            this.minStartIndex = index;\n+        }\n+\n+        if (this.maxStartIndex >= 0) {\n+            TimePeriod maxStartPeriod = getDataItem(this.maxStartIndex).getPeriod();\n+            long maxStart = maxStartPeriod.getStart().getTime();\n+            if (start > maxStart) {\n+                this.maxStartIndex = index;\n+            }\n+        } else {\n+            this.maxStartIndex = index;\n+        }\n+\n+        if (this.minMiddleIndex >= 0) {\n+            TimePeriod minMiddlePeriod = getDataItem(this.minMiddleIndex).getPeriod();\n+            long s = minMiddlePeriod.getStart().getTime();\n+            long e = minMiddlePeriod.getEnd().getTime();\n+            long minMiddle = s + (e - s) / 2;\n+            if (middle < minMiddle) {\n+                this.minMiddleIndex = index;\n+            }\n+        } else {\n+            this.minMiddleIndex = index;\n+        }\n+\n+        if (this.maxMiddleIndex >= 0) {\n+            TimePeriod maxMiddlePeriod = getDataItem(this.maxMiddleIndex).getPeriod();\n+            long s = maxMiddlePeriod.getStart().getTime();\n+            long e = maxMiddlePeriod.getEnd().getTime();\n+            long maxMiddle = s + (e - s) / 2;\n+            if (middle > maxMiddle) {\n+                this.maxMiddleIndex = index;\n+            }\n+        } else {\n+            this.maxMiddleIndex = index;\n+        }\n+\n+        if (this.minEndIndex >= 0) {\n+            TimePeriod minEndPeriod = getDataItem(this.minEndIndex).getPeriod();\n+            long minEnd = minEndPeriod.getEnd().getTime();\n+            if (end < minEnd) {\n+                this.minEndIndex = index;\n+            }\n+        } else {\n+            this.minEndIndex = index;\n+        }\n+\n+        if (this.maxEndIndex >= 0) {\n+            TimePeriod maxEndPeriod = getDataItem(this.maxEndIndex).getPeriod();\n+            long maxEnd = maxEndPeriod.getEnd().getTime();\n+            if (end > maxEnd) {\n+                this.maxEndIndex = index;\n+            }\n+        } else {\n+            this.maxEndIndex = index;\n+        }\n+    }\n+\n     \n     /**\n      * Recalculates the bounds for the collection of items."}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        this(time, zone, Locale.getDefault());", "diff": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 3cc4138..183bac2 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+        this(time, zone, Locale.getDefault());\n     }\n \n     /**"}
{"project": "Chart", "bug_id": "9", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        if (endIndex < startIndex) {", "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 4067e3e..fe45ba9 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (endIndex < startIndex) {\n             emptyRange = true;\n         }\n         if (emptyRange) {"}
{"project": "Chart", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        PathIterator iterator2 = p2.getPathIterator(null);", "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();"}
{"project": "Chart", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "attempt": 11, "mode": "SL", "patch": "                    new Range(0.0, constraint.getWidth() - w[4]),", "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..15e9ace 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, constraint.getWidth() - w[4]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);"}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "attempt": 13, "mode": "SL", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..83af579 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     "}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "3", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n            return Double.valueOf(str);\n", "diff": "diff --git a/src/java/org/apache/commons/cli/TypeHandler.java b/src/java/org/apache/commons/cli/TypeHandler.java\nindex addf90b..3526267 100644\n--- a/src/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/java/org/apache/commons/cli/TypeHandler.java\n@@ -158,7 +158,9 @@ public class TypeHandler {\n     {\n         try\n         {\n-            return org.apache.commons.lang.math.NumberUtils.createNumber(str);\n+\n+            return Double.valueOf(str);\n+\n         }\n         catch (NumberFormatException nfe)\n         {"}
{"project": "Cli", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        if (str == null)\n        {\n            return str;\n        }\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex 2d88c30..c3864ff 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -33,6 +33,12 @@ class Util {\n      */\n     static String stripLeadingHyphens(String str)\n     {\n+\n+        if (str == null)\n+        {\n+            return str;\n+        }\n+\n         if (str.startsWith(\"--\"))\n         {\n             return str.substring(2, str.length());\n@@ -64,4 +70,4 @@ class Util {\n         }\n         return str;\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "attempt": 18, "mode": "SL", "patch": "            pos = findWrapPos(text, width, 0);", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 639b9d5..40873f5 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -809,7 +809,7 @@ public class HelpFormatter {\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+            pos = findWrapPos(text, width, 0);\n \n             if (pos == -1)\n             {"}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next()).append(\", \");\n            }\n\n            // remove the trailing \", \"\n            if (buff.length() > 12) {\n                buff.setLength(buff.length() - 2);\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex dbace06..c6d7ec1 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -300,11 +300,12 @@ public abstract class Parser implements CommandLineParser {\n      * @throws MissingOptionException if any of the required Options\n      * are not present.\n      */\n+\n     protected void checkRequiredOptions()\n         throws MissingOptionException\n     {\n         // if there are required options that have not been\n-        // processsed\n+        // processed\n         if (getRequiredOptions().size() > 0)\n         {\n             Iterator iter = getRequiredOptions().iterator();\n@@ -312,17 +313,22 @@ public abstract class Parser implements CommandLineParser {\n             buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n             buff.append(\": \");\n \n-\n             // loop through the required options\n             while (iter.hasNext())\n             {\n-                buff.append(iter.next());\n+                buff.append(iter.next()).append(\", \");\n+            }\n+\n+            // remove the trailing \", \"\n+            if (buff.length() > 12) {\n+                buff.setLength(buff.length() - 2);\n             }\n \n             throw new MissingOptionException(buff.toString());\n         }\n     }\n \n+\n     /**\n      * <p>Process the argument values for the specified Option\n      * <code>opt</code> using the values retrieved from the "}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "        if (option.hasArg() && (!\"\".equals(option.getArgName())))", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 183cae3..b6457b1 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -629,7 +629,7 @@ public class HelpFormatter {\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+        if (option.hasArg() && (!\"\".equals(option.getArgName())))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }"}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "17", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "            break;", "diff": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex cafcede..7215048 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -300,6 +300,7 @@ public class PosixParser extends Parser {\n             else if (stopAtNonOption)\n             {\n                 process(token.substring(i));\n+            break;\n             }\n             else\n             {"}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                continue;", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex 6b39536..4f38961 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -287,7 +287,7 @@ public abstract class Parser implements CommandLineParser\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+                continue;\n                 }\n \n                 cmd.addOption(opt);"}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\n    private boolean isShortOption(String token) {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        return token.startsWith(\"-\") && token.length() > 1 && options.hasShortOption(token.substring(1));\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 6aeaebe..3481139 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -296,14 +296,13 @@ public class DefaultParser implements CommandLineParser\n      * \n      * @param token\n      */\n-    private boolean isShortOption(String token)\n-    {\n-        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n-        // remove leading \"-\" and \"=value\"\n+    private boolean isShortOption(String token) {\n+        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n+        return token.startsWith(\"-\") && token.length() > 1 && options.hasShortOption(token.substring(1));\n     }\n \n+\n     /**\n      * Tells if the token looks like a long option.\n      *"}
{"project": "Cli", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            throw new ParseException(\"Unsupported class type: \" + clazz.getName());", "diff": "diff --git a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex 6bd84b0..f099a6a 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -100,7 +100,7 @@ public class TypeHandler\n         }\n         else\n         {\n-            return null;\n+            throw new ParseException(\"Unsupported class type: \" + clazz.getName());\n         }\n     }\n "}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprivate void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n    String functionName, HashMap<String, ObjectType> properties,\n    HashMap<String, ObjectType> currentProperties,\n    ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  // This can be the case if interfaceType is proxy to a non-existent\n  // object (which is a bad type annotation, but shouldn't crash).\n  if (implicitProto == null) {\n    return;\n  }\n  Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();\n  for (String name : currentPropertyNames) {\n    ObjectType oType = properties.get(name);\n    if (oType != null) {\n      if (!interfaceType.getPropertyType(name).isEquivalentTo(\n          oType.getPropertyType(name))) {\n        compiler.report(\n            t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                functionName, name, oType.toString(),\n                interfaceType.toString()));\n      }\n    }\n    currentProperties.put(name, interfaceType);\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(t, n, functionName, properties,\n        currentProperties, iType);\n  }\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db9..15679f73 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1563,33 +1563,37 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * that have been visited\n    * @param interfaceType The super interface that is being visited\n    */\n-  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n-      String functionName, HashMap<String, ObjectType> properties,\n-      HashMap<String, ObjectType> currentProperties,\n-      ObjectType interfaceType) {\n-    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n-    Set<String> currentPropertyNames;\n-      // This can be the case if interfaceType is proxy to a non-existent\n-      // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n-    for (String name : currentPropertyNames) {\n-      ObjectType oType = properties.get(name);\n-      if (oType != null) {\n-        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n-            oType.getPropertyType(name))) {\n-          compiler.report(\n-              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n-                  functionName, name, oType.toString(),\n-                  interfaceType.toString()));\n-        }\n+\n+private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n+    String functionName, HashMap<String, ObjectType> properties,\n+    HashMap<String, ObjectType> currentProperties,\n+    ObjectType interfaceType) {\n+  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n+  // This can be the case if interfaceType is proxy to a non-existent\n+  // object (which is a bad type annotation, but shouldn't crash).\n+  if (implicitProto == null) {\n+    return;\n+  }\n+  Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();\n+  for (String name : currentPropertyNames) {\n+    ObjectType oType = properties.get(name);\n+    if (oType != null) {\n+      if (!interfaceType.getPropertyType(name).isEquivalentTo(\n+          oType.getPropertyType(name))) {\n+        compiler.report(\n+            t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n+                functionName, name, oType.toString(),\n+                interfaceType.toString()));\n       }\n-      currentProperties.put(name, interfaceType);\n-    }\n-    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n-      checkInterfaceConflictProperties(t, n, functionName, properties,\n-          currentProperties, iType);\n     }\n+    currentProperties.put(name, interfaceType);\n+  }\n+  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n+    checkInterfaceConflictProperties(t, n, functionName, properties,\n+        currentProperties, iType);\n   }\n+}\n+\n \n   /**\n    * Visits a {@link Token#FUNCTION} node."}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      return mayBeStringHelper(n);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef27927..fb514773 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return mayBeStringHelper(n);\n     } else {\n       return mayBeStringHelper(n);\n     }"}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      if (options.dependencyOptions.needsManagement()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77f..3756b998 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process."}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "attempt": 18, "mode": "SF", "patch": "\n  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        // \"this\" references aren't currently modeled in the CFG.\n        return;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..214f9d28 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,6 +154,7 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n+\n   protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n@@ -169,7 +170,9 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n+      case Token.THIS:\n         // \"this\" references aren't currently modeled in the CFG.\n+        return;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n@@ -177,6 +180,7 @@ public abstract class ChainableReverseAbstractInterpreter\n     }\n   }\n \n+\n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)\n    */"}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "22", "eval": "PASS", "attempt": 11, "mode": "SF", "patch": "\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      // VOID nodes appear when there are extra semicolons at the BLOCK level.\n      // I've been unable to think of any cases where this indicates a bug,\n      // and apparently some people like keeping these semicolons around,\n      // so we'll allow it.\n      if (n.isEmpty() ||\n          n.isComma()) {\n        return;\n      }\n\n      if (parent == null) {\n        return;\n      }\n\n      // Do not try to remove a block or an expr result. We already handle\n      // these cases when we visit the child, and the peephole passes will\n      // fix up the tree in more clever ways when these are removed.\n      if (parent.getType() == Token.COMMA) {\n        Node gramps = parent.getParent();\n        if (gramps.isCall() && parent == gramps.getFirstChild()) {\n          if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n            return;\n          }\n        }\n      } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n             n == parent.getFirstChild().getNext().getNext())) {\n        } else {\n          return;\n        }\n      }\n\n      boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n      boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n      if (!isResultUsed &&\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n          return;\n        } else if (n.isExprResult()) {\n          return;\n        }\n        String msg = \"This code lacks side-effects. Is there a bug?\";\n        if (n.isString()) {\n          msg = \"Is there a missing '+' on the previous line?\";\n        } else if (isSimpleOp) {\n          msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n        }\n\n        t.getCompiler().report(\n            t.makeError(n, level, USELESS_CODE_ERROR, msg));\n        // TODO(johnlenz): determine if it is necessary to\n        // try to protect side-effect free statements as well.\n        if (!NodeUtil.isStatement(n)) {\n          problemNodes.add(n);\n        }\n      }\n    }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex b9aa412c..689e70de 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -81,78 +81,66 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n   }\n \n   @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n-    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n-    // I've been unable to think of any cases where this indicates a bug,\n-    // and apparently some people like keeping these semicolons around,\n-    // so we'll allow it.\n-    if (n.isEmpty() ||\n-        n.isComma()) {\n-      return;\n-    }\n \n-    if (parent == null) {\n-      return;\n-    }\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      // VOID nodes appear when there are extra semicolons at the BLOCK level.\n+      // I've been unable to think of any cases where this indicates a bug,\n+      // and apparently some people like keeping these semicolons around,\n+      // so we'll allow it.\n+      if (n.isEmpty() ||\n+          n.isComma()) {\n+        return;\n+      }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n-    if (parent.getType() == Token.COMMA) {\n-      Node gramps = parent.getParent();\n-      if (gramps.isCall() && parent == gramps.getFirstChild()) {\n-        if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n-      return;\n-        }\n-    }\n+      if (parent == null) {\n+        return;\n+      }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA)\n-            continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK)\n+      // Do not try to remove a block or an expr result. We already handle\n+      // these cases when we visit the child, and the peephole passes will\n+      // fix up the tree in more clever ways when these are removed.\n+      if (parent.getType() == Token.COMMA) {\n+        Node gramps = parent.getParent();\n+        if (gramps.isCall() && parent == gramps.getFirstChild()) {\n+          if (n == parent.getFirstChild() && parent.getChildCount() == 2 && n.getNext().isName() && \"eval\".equals(n.getNext().getString())) {\n             return;\n-          else\n-            break;\n+          }\n+        }\n+      } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n+        if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n+             n == parent.getFirstChild().getNext().getNext())) {\n+        } else {\n+          return;\n         }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() ||\n-           n == parent.getFirstChild().getNext().getNext())) {\n-      } else {\n-      return;\n-      }\n-    }\n \n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (!isResultUsed &&\n+      boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n+      boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n+      if (!isResultUsed &&\n         (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-        return;\n-      } else if (n.isExprResult()) {\n-        return;\n-      }\n-      String msg = \"This code lacks side-effects. Is there a bug?\";\n-      if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n-      } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n+        if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n+          return;\n+        } else if (n.isExprResult()) {\n+          return;\n+        }\n+        String msg = \"This code lacks side-effects. Is there a bug?\";\n+        if (n.isString()) {\n+          msg = \"Is there a missing '+' on the previous line?\";\n+        } else if (isSimpleOp) {\n+          msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n             \"' operator is not being used.\";\n-      }\n+        }\n \n-      t.getCompiler().report(\n-          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n-      // TODO(johnlenz): determine if it is necessary to\n-      // try to protect side-effect free statements as well.\n-      if (!NodeUtil.isStatement(n)) {\n-        problemNodes.add(n);\n+        t.getCompiler().report(\n+            t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+        // TODO(johnlenz): determine if it is necessary to\n+        // try to protect side-effect free statements as well.\n+        if (!NodeUtil.isStatement(n)) {\n+          problemNodes.add(n);\n+        }\n       }\n     }\n-  }\n+\n \n   /**\n    * Protect side-effect free nodes by making them parameters"}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "    return len > 0 && s.charAt(0) != '0';", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex ac6299d1..535148cd 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {"}
{"project": "Closure", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "56", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "          if (target != null && target.getType() == Token.STRING) {", "diff": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex c507c924..b5a3c1b2 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,7 +194,7 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }"}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "62", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "          && 0 <= charno && charno <= sourceExcerpt.length()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..420dbc07 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {"}
{"project": "Closure", "bug_id": "65", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "70", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                  jsDocParameter.getJSType(), false);", "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 210bb66e..aa7e2458 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);"}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "attempt": 13, "mode": "SL", "patch": "            if (0x20 <= c && c <= 0x7e) {", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..b45814c0 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (0x20 <= c && c <= 0x7e) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,"}
{"project": "Closure", "bug_id": "77", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        case '\\u0000': sb.append(\"\\\\0\"); break; // Handle null character", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 8cd3ab9d..acebc741 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -963,6 +963,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n+        case '\\u0000': sb.append(\"\\\\0\"); break; // Handle null character\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;"}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "return locals.apply(value);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dd78f900..a2825fa1 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,7 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return locals.apply(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:"}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "          int indexOfDot = namespace.lastIndexOf('.');", "diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..1d738b52 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)"}
{"project": "Closure", "bug_id": "94", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "97", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "104", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "109", "eval": "PASS", "attempt": 16, "mode": "SH", "patch": "\n          return parseTypeExpression(token);\n", "diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c3509..722cf173 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,9 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+\n+          return parseTypeExpression(token);\n+\n   }\n \n   /**"}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "119", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "122", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "attempt": 20, "mode": "SF", "patch": "\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    // Check if the node is a property access\n    while (node.isGetProp()) {\n      node = node.getFirstChild();\n      if (node.isName()) {\n        // If it's a name node, check if it's assigned to the replacement\n        String name = node.getString();\n        if (isNameAssignedTo(name, replacement)) {\n          return false;\n        }\n      }\n    }\n\n    // If the node is not a property access, return true\n    return true;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/ExploitAssigns.java b/src/com/google/javascript/jscomp/ExploitAssigns.java\nindex 0f03e355..d4235c07 100644\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n@@ -203,6 +203,7 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n    * changed.\n    * @return Whether the replacement can be made.\n    */\n+\n   private boolean isSafeReplacement(Node node, Node replacement) {\n     // No checks are needed for simple names.\n     if (node.isName()) {\n@@ -210,15 +211,23 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n+    // Check if the node is a property access\n+    while (node.isGetProp()) {\n       node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n+      if (node.isName()) {\n+        // If it's a name node, check if it's assigned to the replacement\n+        String name = node.getString();\n+        if (isNameAssignedTo(name, replacement)) {\n+          return false;\n+        }\n+      }\n     }\n \n+    // If the node is not a property access, return true\n     return true;\n   }\n \n+\n   /**\n    * @return Whether name is assigned in the expression rooted at node.\n    */\n@@ -241,4 +250,4 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n \n     return false;\n   }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Closure", "bug_id": "125", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      if (fnType != null && fnType.isConstructor()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 4e053258..bfed9662 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+      if (fnType != null && fnType.isConstructor()) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {"}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        // Don't process the finally block when trying to minimize exits.\n      }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..c2c36676 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,12 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n+\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        // Don't process the finally block when trying to minimize exits.\n       }\n+\n     }\n \n     // Just a 'label'."}
{"project": "Closure", "bug_id": "128", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n  static boolean isSimpleNumber(String s) {\n    if (s == null || s.length() == 0) {\n      return false;\n    }\n    if (s.charAt(0) == '0') {\n      return s.length() == 1; // Only '0' is considered a simple number\n    }\n    for (char c : s.toCharArray()) {\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return true;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 2270c172..4f3665ad 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -780,17 +780,23 @@ class CodeGenerator {\n     } while (current != n);\n   }\n \n+\n   static boolean isSimpleNumber(String s) {\n-    int len = s.length();\n-    for (int index = 0; index < len; index++) {\n-      char c = s.charAt(index);\n+    if (s == null || s.length() == 0) {\n+      return false;\n+    }\n+    if (s.charAt(0) == '0') {\n+      return s.length() == 1; // Only '0' is considered a simple number\n+    }\n+    for (char c : s.toCharArray()) {\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+    return true;\n   }\n \n+\n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {"}
{"project": "Closure", "bug_id": "129", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n\n      if (first.isCast()) {\n        first = first.getFirstChild();\n      }\n\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex d993bee7..3e157d29 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -164,6 +164,13 @@ class PrepareAst implements CompilerPass {\n \n       // ignore cast nodes.\n \n+\n+      if (first.isCast()) {\n+        first = first.getFirstChild();\n+      }\n+\n+\n+\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n       }"}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0)) ||\n          s.contains(\"\\u0004\")) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "diff": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex 144a4adc..b42ea0d7 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -187,11 +187,13 @@ public class TokenStream {\n         return id;\n     }\n \n+\n     public static boolean isJSIdentifier(String s) {\n       int length = s.length();\n \n       if (length == 0 ||\n-          !Character.isJavaIdentifierStart(s.charAt(0))) {\n+          !Character.isJavaIdentifierStart(s.charAt(0)) ||\n+          s.contains(\"\\u0004\")) {\n         return false;\n       }\n \n@@ -204,4 +206,5 @@ public class TokenStream {\n \n       return true;\n     }\n+\n }"}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "152", "eval": "PASS", "attempt": 5, "mode": "SH", "patch": "\n    if (typeOfThis != null && !(typeOfThis instanceof ObjectType)) {\n      throw new IllegalStateException(\n          \"Unexpected type for type of 'this': \"\n              + typeOfThis.toString());\n    }\n", "diff": "diff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex fc2578d8..7b39545a 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -868,7 +868,13 @@ public class FunctionType extends PrototypeObjectType {\n     // Warning about typeOfThis if it doesn't resolve to an ObjectType\n     // is handled further upstream.\n     // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n+\n+    if (typeOfThis != null && !(typeOfThis instanceof ObjectType)) {\n+      throw new IllegalStateException(\n+          \"Unexpected type for type of 'this': \"\n+              + typeOfThis.toString());\n+    }\n+\n \n     boolean changed = false;\n     ImmutableList.Builder<ObjectType> resolvedInterfaces ="}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        if (t.getScopeDepth() <= t.getScope().getDepth()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..7d44ffdf 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1993,7 +1993,7 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+        if (t.getScopeDepth() <= t.getScope().getDepth()) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")"}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "        long len = binaryData.length / 3 * 4 + 4;", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 2cd0163b..f3f737b3 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -824,7 +824,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+        long len = binaryData.length / 3 * 4 + 4;\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +"}
{"project": "Codec", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 5b14ca0c..9ca695b9 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -336,7 +336,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**"}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return cs1.length() == cs2.length() && cs1.toString().equals(cs2.toString());", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex bef55f70..2b8c5261 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -78,7 +78,7 @@ public class StringUtils {\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+        return cs1.length() == cs2.length() && cs1.toString().equals(cs2.toString());\n     }\n \n     /**"}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "13", "eval": "PASS", "attempt": 4, "mode": "SH", "patch": "\n            name = name.replace('\\\\', '/');\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 88cf183f..45371793 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -509,6 +509,9 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n      * @param name the name to use\n      */\n     protected void setName(String name) {\n+\n+            name = name.replace('\\\\', '/');\n+\n         this.name = name;\n     }\n "}
{"project": "Compress", "bug_id": "14", "eval": "PASS", "attempt": 15, "mode": "SH", "patch": "\n            if (buffer[offset] == 0) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 8239480f..d71b7381 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -62,14 +62,9 @@ public class TarUtils {\n             throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n         }\n \n-        boolean allNUL = true;\n-        for (int i = start; i < end; i++){\n-            if (buffer[i] != 0){\n-                allNUL = false;\n-                break;\n-            }\n-        }\n-        if (allNUL) {\n+\n+            if (buffer[offset] == 0) {\n+\n             return 0L;\n         }\n "}
{"project": "Compress", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "17", "eval": "PASS", "attempt": 10, "mode": "SF", "patch": "\n    public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n        long    result = 0;\n        int     end     = offset + length;\n        int     start   = offset;\n\n        if (length < 2) {\n            throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n        }\n\n        if (buffer[start] == 0) {\n            return 0L;\n        }\n\n        // Skip leading spaces\n        while (start < end && buffer[start] == ' ') {\n            start++;\n        }\n\n        // Must have trailing NUL or space\n        byte trailer;\n        trailer = buffer[end - 1];\n        if (trailer == 0 || trailer == ' ') {\n            end--;\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n        }\n\n        // May have additional NULs or spaces\n        while (start < end - 1 && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {\n            end--;\n        }\n\n        for ( ;start < end; start++) {\n            final byte currentByte = buffer[start];\n            if (currentByte < '0' || currentByte > '7') {\n                throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n            result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        }\n\n        return result;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex c5532494..ef70accc 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -99,13 +99,14 @@ public class TarUtils {\n      * @return The long value of the octal string.\n      * @throws IllegalArgumentException if the trailing space/NUL is missing or if a invalid byte is detected.\n      */\n+\n     public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n         long    result = 0;\n-        int     end = offset + length;\n-        int     start = offset;\n+        int     end     = offset + length;\n+        int     start   = offset;\n \n-        if (length < 2){\n-            throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n+        if (length < 2) {\n+            throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n         }\n \n         if (buffer[start] == 0) {\n@@ -113,43 +114,36 @@ public class TarUtils {\n         }\n \n         // Skip leading spaces\n-        while (start < end){\n-            if (buffer[start] == ' '){\n-                start++;\n-            } else {\n-                break;\n-            }\n+        while (start < end && buffer[start] == ' ') {\n+            start++;\n         }\n \n         // Must have trailing NUL or space\n         byte trailer;\n-        trailer = buffer[end-1];\n-        if (trailer == 0 || trailer == ' '){\n+        trailer = buffer[end - 1];\n+        if (trailer == 0 || trailer == ' ') {\n             end--;\n         } else {\n-            throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, end-1, trailer));\n+            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, end - 1, trailer));\n         }\n+\n         // May have additional NULs or spaces\n-        trailer = buffer[end - 1];\n-        if (trailer == 0 || trailer == ' '){\n+        while (start < end - 1 && (buffer[end - 1] == 0 || buffer[end - 1] == ' ')) {\n             end--;\n         }\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n-            // CheckStyle:MagicNumber OFF\n-            if (currentByte < '0' || currentByte > '7'){\n-                throw new IllegalArgumentException(\n-                        exceptionMessage(buffer, offset, length, start, currentByte));\n+            if (currentByte < '0' || currentByte > '7') {\n+                throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n             result = (result << 3) + (currentByte - '0'); // convert from ASCII\n-            // CheckStyle:MagicNumber ON\n         }\n \n         return result;\n     }\n \n+\n     /** \n      * Compute the value contained in a byte buffer.  If the most\n      * significant bit of the first byte in the buffer is set, this"}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "            if (rawCentralDirectoryData.length < expectedLength) {", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\nindex 134871be..fbcec484 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n@@ -256,7 +256,7 @@ public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n                 + (hasCompressedSize ? DWORD : 0)\n                 + (hasRelativeHeaderOffset ? DWORD : 0)\n                 + (hasDiskStart ? WORD : 0);\n-            if (rawCentralDirectoryData.length != expectedLength) {\n+            if (rawCentralDirectoryData.length < expectedLength) {\n                 throw new ZipException(\"central directory zip64 extended\"\n                                        + \" information extra field's length\"\n                                        + \" doesn't match central directory\""}
{"project": "Compress", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "attempt": 12, "mode": "SL", "patch": "                dictSize |= ((((long) coder.properties[i + 1]) & 0xff) << (8 * i));", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\nindex 0bc5a1ee..b1b8385d 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n@@ -109,7 +109,7 @@ class Coders {\n             byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n-                dictSize |= (coder.properties[i + 1] << (8 * i));\n+                dictSize |= ((((long) coder.properties[i + 1]) & 0xff) << (8 * i));\n             }\n             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");"}
{"project": "Compress", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        if (start == end) {\n            return 0L;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 4cf32d6f..f0b1f005 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -130,11 +130,12 @@ public class TarUtils {\n             end--;\n             trailer = buffer[end - 1];\n         }\n+\n         if (start == end) {\n-            throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, start, trailer));\n+            return 0L;\n         }\n \n+\n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n             // CheckStyle:MagicNumber OFF"}
{"project": "Compress", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "30", "eval": "PASS", "attempt": 12, "mode": "SH", "patch": "\n        if (len == 0) {\n            return 0;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\nindex e0e3b1ec..8c2bf0bd 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n@@ -166,6 +166,11 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n             throw new IOException(\"stream closed\");\n         }\n \n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+\n         final int hi = offs + len;\n         int destOffs = offs;\n         int b;"}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "attempt": 5, "mode": "SH", "patch": "\n            if (currentByte < '0' || currentByte > '7') {\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 40e7871f..52f467b2 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -132,9 +132,12 @@ public class TarUtils {\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n-            if (currentByte == 0) {\n-                break;\n+\n+            if (currentByte < '0' || currentByte > '7') {\n+                throw new IllegalArgumentException(\n+                        exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n+\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException("}
{"project": "Compress", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "38", "eval": "PASS", "attempt": 17, "mode": "SL", "patch": "            if (getName().endsWith(\"/\") && isLink()) {", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\nindex 941bbbd3..880ac80c 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -856,7 +856,7 @@ public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n             return true;\n         }\n \n-        if (getName().endsWith(\"/\")) {\n+            if (getName().endsWith(\"/\") && isLink()) {\n             return true;\n         }\n \n@@ -1250,4 +1250,3 @@ public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n         }\n     }\n }\n-"}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if (checksum == null) {\n            throw new NullPointerException(\"Checksum cannot be null\");\n        }\n        if (in == null) {\n            throw new NullPointerException(\"InputStream cannot be null\");\n        }\n        this.checksum = checksum;\n        this.in = in;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\nindex 10c7d68d..2eb7df16 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n@@ -30,14 +30,19 @@ public class ChecksumCalculatingInputStream extends InputStream {\n     private final InputStream in;\n     private final Checksum checksum;\n \n-    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n-\n-\n \n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        if (checksum == null) {\n+            throw new NullPointerException(\"Checksum cannot be null\");\n+        }\n+        if (in == null) {\n+            throw new NullPointerException(\"InputStream cannot be null\");\n+        }\n         this.checksum = checksum;\n         this.in = in;\n     }\n \n+\n     /**\n      * Reads a single byte from the stream\n      * @throws IOException if the underlying stream throws or the"}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 39ce5c1a..2000b3d0 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -471,6 +471,7 @@ public static int formatLongOctalBytes(final long value, final byte[] buf, final\n      * will not fit in the buffer.\n      * @since 1.4\n      */\n+\n     public static int formatLongOctalOrBinaryBytes(\n         final long value, final byte[] buf, final int offset, final int length) {\n \n@@ -484,13 +485,14 @@ public static int formatLongOctalOrBinaryBytes(\n \n         if (length < 9) {\n             formatLongBinary(value, buf, offset, length, negative);\n+        } else {\n+            formatBigIntegerBinary(value, buf, offset, length, negative);\n         }\n-        formatBigIntegerBinary(value, buf, offset, length, negative);\n-\n         buf[offset] = (byte) (negative ? 0xff : 0x80);\n         return offset + length;\n     }\n \n+\n     private static void formatLongBinary(final long value, final byte[] buf,\n                                          final int offset, final int length,\n                                          final boolean negative) {"}
{"project": "Compress", "bug_id": "46", "eval": "PASS", "attempt": 5, "mode": "SH", "patch": "\n        long twoToThirty = 0x7FFFFFFF;\n        if (l > twoToThirty) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\nindex f7a74406..44f4fde6 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n@@ -526,8 +526,10 @@ private static ZipLong dateToZipLong(final Date d) {\n     }\n \n     private static ZipLong unixTimeToZipLong(long l) {\n-        final long TWO_TO_32 = 0x100000000L;\n-        if (l >= TWO_TO_32) {\n+\n+        long twoToThirty = 0x7FFFFFFF;\n+        if (l > twoToThirty) {\n+\n             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n         }\n         return new ZipLong(l);"}
{"project": "Csv", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index == null) {\n            throw new IllegalArgumentException(\"No header value with name '\" + name + \"' was found.\");\n        }\n        try {\n            return values[index.intValue()];\n        } catch (ArrayIndexOutOfBoundsException e) {\n            throw new IllegalArgumentException(\"Invalid array index for header name '\" + name + \"'.\", e);\n        }\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex dc52017..92c759c 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -76,15 +76,24 @@ public class CSVRecord implements Serializable, Iterable<String> {\n      *             if the record is inconsistent\n      * @see #isConsistent()\n      */\n+\n     public String get(final String name) {\n         if (mapping == null) {\n             throw new IllegalStateException(\n                     \"No header mapping was specified, the record values can't be accessed by name\");\n         }\n         final Integer index = mapping.get(name);\n-            return index != null ? values[index.intValue()] : null;\n+        if (index == null) {\n+            throw new IllegalArgumentException(\"No header value with name '\" + name + \"' was found.\");\n+        }\n+        try {\n+            return values[index.intValue()];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            throw new IllegalArgumentException(\"Invalid array index for header name '\" + name + \"'.\", e);\n+        }\n     }\n \n+\n     /**\n      * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to\n      * the header size. Some programs can export files that fails this test but still produce parsable files."}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return this.headerMap;", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 9d56f1a..b610640 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -285,7 +285,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+        return this.headerMap;\n     }\n \n     /**"}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator == null) {\n            out.append('\\n'); // Default newline character\n        } else {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex 3255360..3e9265a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -320,12 +320,18 @@ public final class CSVPrinter implements Flushable, Closeable {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n+\n     public void println() throws IOException {\n         final String recordSeparator = format.getRecordSeparator();\n+        if (recordSeparator == null) {\n+            out.append('\\n'); // Default newline character\n+        } else {\n             out.append(recordSeparator);\n+        }\n         newRecord = true;\n     }\n \n+\n     /**\n      * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n      * characters will be escaped."}
{"project": "Csv", "bug_id": "6", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            final int col = entry.getValue().intValue();\n            if (col < values.length && col >= 0) { // Add a check to prevent ArrayIndexOutOfBoundsException\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 7380d9f..b0a471f 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -166,6 +166,7 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      *\n      * @return an iterator over the values of this record.\n      */\n+\n     public Iterator<String> iterator() {\n         return toList().iterator();\n     }\n@@ -179,11 +180,14 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n     <M extends Map<String, String>> M putIn(final M map) {\n         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n             final int col = entry.getValue().intValue();\n+            if (col < values.length && col >= 0) { // Add a check to prevent ArrayIndexOutOfBoundsException\n                 map.put(entry.getKey(), values[col]);\n+            }\n         }\n         return map;\n     }\n \n+\n     /**\n      * Returns the number of values in this record.\n      *"}
{"project": "Csv", "bug_id": "9", "eval": "PASS", "attempt": 9, "mode": "SH", "patch": "\n\n        if (values == null || mapping == null) {\n            return map;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 3abb468..6f58747 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -177,6 +177,12 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      * @return the given map.\n      */\n     <M extends Map<String, String>> M putIn(final M map) {\n+\n+\n+        if (values == null || mapping == null) {\n+            return map;\n+        }\n+\n         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n             final int col = entry.getValue().intValue();\n             if (col < values.length) {"}
{"project": "Csv", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "                    final boolean emptyHeader = (header == null || header.trim().isEmpty());", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex b6867a4..0b5c3af 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -381,7 +381,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+                    final boolean emptyHeader = (header == null || header.trim().isEmpty());\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));"}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                if (newRecord && Character.isWhitespace(c)) {", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35ee86a..44c3ef0 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1036,7 +1036,7 @@ public final class CSVFormat implements Serializable {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                if (newRecord && Character.isWhitespace(c)) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now"}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n                if (c <= COMMENT) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35c2ad1..8853f90 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1186,9 +1186,9 @@ public final class CSVFormat implements Serializable {\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n-                    quote = true;\n-                } else if (c <= COMMENT) {\n+\n+                if (c <= COMMENT) {\n+\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too."}
{"project": "Gson", "bug_id": "5", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "                if (timezoneOffset.length() < 4) timezoneOffset += \"00\";", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\nindex a326f768..1d56e7a0 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/util/ISO8601Utils.java\n@@ -211,6 +211,7 @@ public class ISO8601Utils\n                 String timezoneOffset = date.substring(offset);\n \n                 // When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n+                if (timezoneOffset.length() < 4) timezoneOffset += \"00\";\n \n                 offset += timezoneOffset.length();\n                 // 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\""}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "11", "eval": "PASS", "attempt": 16, "mode": "SL", "patch": "      case STRING:", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 6a51c64e..31beb5d6 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -368,6 +368,7 @@ public final class TypeAdapters {\n         in.nextNull();\n         return null;\n       case NUMBER:\n+      case STRING:\n         return new LazilyParsedNumber(in.nextString());\n       default:\n         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);"}
{"project": "Gson", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "13", "eval": "PASS", "attempt": 11, "mode": "SL", "patch": "    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value == Long.MIN_VALUE || !negative)) {", "diff": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 877742bf..c1d704fa 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -728,7 +728,7 @@ public class JsonReader implements Closeable {\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value == Long.MIN_VALUE || !negative)) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;"}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "16", "eval": "PASS", "attempt": 9, "mode": "SF", "patch": "\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        if (visitedTypeVariables.contains(typeVariable)) {\n          return typeVariable;\n        }\n        visitedTypeVariables.add(typeVariable);\n        // cannot reduce due to infinite recursion\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex 17ed0ff2..a2449c25 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -333,18 +333,19 @@ public final class $Gson$Types {\n     return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n   }\n \n+\n   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                               Collection<TypeVariable> visitedTypeVariables) {\n     // this implementation is made a little more complicated in an attempt to avoid object-creation\n     while (true) {\n       if (toResolve instanceof TypeVariable) {\n         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n-          // cannot reduce due to infinite recursion\n-        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n-        if (toResolve == typeVariable) {\n-          return toResolve;\n+        if (visitedTypeVariables.contains(typeVariable)) {\n+          return typeVariable;\n         }\n-\n+        visitedTypeVariables.add(typeVariable);\n+        // cannot reduce due to infinite recursion\n+        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n       } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n         Class<?> original = (Class<?>) toResolve;\n         Type componentType = original.getComponentType();\n@@ -407,6 +408,7 @@ public final class $Gson$Types {\n     }\n   }\n \n+\n   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n     Class<?> declaredByRaw = declaringClassOf(unknown);\n "}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        int len = curr.length;\n        if (len >= MAX_SEGMENT_LEN) {\n            // If the current length is already equal to or exceeds the maximum, increase by 1\n            return (_currentSegment = Arrays.copyOf(curr, len + 1));\n        }\n        // But above intended maximum, slow to increase by 25%\n        int newLen = Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex f97a083f..1e9e8b8c 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -577,16 +577,22 @@ public final class TextBuffer\n      * accommodate for more contiguous content. Usually only\n      * used when parsing tokens like names if even then.\n      */\n+\n     public char[] expandCurrentSegment()\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n-        final int len = curr.length;\n-        // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        int len = curr.length;\n+        if (len >= MAX_SEGMENT_LEN) {\n+            // If the current length is already equal to or exceeds the maximum, increase by 1\n+            return (_currentSegment = Arrays.copyOf(curr, len + 1));\n+        }\n+        // But above intended maximum, slow to increase by 25%\n+        int newLen = Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n+\n     /**\n      * Method called to expand size of the current segment, to\n      * accommodate for more contiguous content. Usually only"}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            char c = str.charAt(i);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\nindex d353b392..a8022391 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n@@ -190,7 +190,7 @@ public class JsonPointer\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+            char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }"}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "attempt": 13, "mode": "SL", "patch": "        if (!_hasSegments)  return contentsAsArray();", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex e6f1cbc5..2f34252a 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -295,6 +295,7 @@ public final class TextBuffer\n         return true;\n     }\n     \n+\n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n@@ -304,7 +305,7 @@ public final class TextBuffer\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments)  return contentsAsArray();\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }"}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            if (i < maxCode) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex 2c1f5a23..f38e4aae 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -1960,7 +1960,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+            if (i < maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }"}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        return (previous == null) || !previous.equals(ann);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\nindex f9cc5cb19..49a6303c0 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n@@ -109,8 +109,6 @@ public final class AnnotationMap implements Annotations\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+        return (previous == null) || !previous.equals(ann);\n     }\n }\n-\n-"}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex fc7961de5..23d989e83 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -791,7 +791,7 @@ public class BeanDeserializer\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                     ;\n                 } else {\n                     // Last creator property to set?"}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n\n            if(_kind == STD_LOCALE) {\n                return Locale.forLanguageTag(\"\");\n            }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex cdbd5e8ac..091a88a4b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -281,6 +281,12 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 return URI.create(\"\");\n             }\n             // As per [databind#1123], Locale too\n+\n+\n+            if(_kind == STD_LOCALE) {\n+                return Locale.forLanguageTag(\"\");\n+            }\n+\n             return super._deserializeFromEmptyString();\n         }\n     }"}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public Object generateId(Object forPojo) {\n        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n        //    need to use existing id if there is one:\n        if (id != null) {\n            return id;\n        }\n        id = generator.generateId(forPojo);\n        return id;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\nindex af141e12a..756a0d4e0 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n@@ -43,14 +43,20 @@ public final class WritableObjectId\n         return false;\n     }\n     \n+\n+\n     public Object generateId(Object forPojo) {\n         // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n         //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n         //    need to use existing id if there is one:\n-            id = generator.generateId(forPojo);\n+        if (id != null) {\n+            return id;\n+        }\n+        id = generator.generateId(forPojo);\n         return id;\n     }\n \n+\n     /**\n      * Method called to output Object Id as specified.\n      */"}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n        if (ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)) {\n            mutator.fixAccess(true);\n        }\n        \n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex df861215c..86b1c0b1b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -700,6 +700,7 @@ public class BeanDeserializerFactory\n      * @return Property constructed, if any; or null to indicate that\n      *   there should be no property based on given definitions.\n      */\n+\n     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanPropertyDefinition propDef,\n             JavaType propType0)\n@@ -707,19 +708,16 @@ public class BeanDeserializerFactory\n     {\n         // need to ensure method is callable (for non-public)\n         AnnotatedMember mutator = propDef.getNonConstructorMutator();\n-\n-        if (ctxt.canOverrideAccessModifiers()) {\n-            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n-            // never needed and attempts may cause problems on some platforms.\n-            // !!! NOTE: should be handled better for 2.8 and later\n-                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+        if (ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS)) {\n+            mutator.fixAccess(true);\n         }\n+        \n         // note: this works since we know there's exactly one argument for methods\n         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                 propType0, propDef.getWrapperName(),\n                 beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n         JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n-        // did type change?\n+\n         if (type != propType0) {\n             property = property.withType(type);\n         }\n@@ -751,6 +749,7 @@ public class BeanDeserializerFactory\n         return prop;\n     }\n \n+\n     /**\n      * Method that will construct a regular bean property setter using\n      * the given setter method."}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                found = key.equalsIgnoreCase(prop.getName());", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\nindex dc791897b..99e9102a2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n@@ -437,7 +437,7 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+                found = key.equalsIgnoreCase(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;"}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "PASS", "attempt": 6, "mode": "SH", "patch": "\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    continue;\n                }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\nindex 1629a42be..219ab99d9 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n@@ -580,27 +580,11 @@ public class BuilderBasedDeserializer\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n+\n                 if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n+                    continue;\n                 }\n+\n                 continue;\n             }\n             // Object Id property?"}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\npublic T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String text = p.getValueAsString();\n    if (text != null) { // has String representation\n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception cause = null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            Object res = _deserialize(text, ctxt);\n            if (res != null && _valueClass.isAssignableFrom(res.getClass())) {\n                return (T) res;\n            }\n            return null;\n        } catch (IllegalArgumentException iae) {\n            cause = iae;\n        } catch (MalformedURLException me) {\n            cause = me;\n        }\n        String msg = \"not a valid textual representation\";\n        if (cause != null) {\n            String m2 = cause.getMessage();\n            if (m2 != null) {\n                msg = msg + \", problem: \"+m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n        if (cause != null) {\n            e.initCause(cause);\n        }\n        throw e;\n    }\n    JsonToken t = p.getCurrentToken();\n    // [databind#381]\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex 4f4eb672a..226111cdd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -102,61 +102,64 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n-    {\n-        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n-        String text = p.getValueAsString();\n-        if (text != null) { // has String representation\n-            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n-                // 04-Feb-2013, tatu: Usually should become null; but not always\n-                return _deserializeFromEmptyString();\n-            }\n-            Exception cause = null;\n-            try {\n-                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n-                //    indicated error; but that seems wrong. Should be able to return\n-                //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                cause = iae;\n-            } catch (MalformedURLException me) {\n-                cause = me;\n-            }\n-            String msg = \"not a valid textual representation\";\n-            if (cause != null) {\n-                String m2 = cause.getMessage();\n-                if (m2 != null) {\n-                    msg = msg + \", problem: \"+m2;\n-                }\n+\n+public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n+{\n+    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n+    String text = p.getValueAsString();\n+    if (text != null) { // has String representation\n+        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n+            // 04-Feb-2013, tatu: Usually should become null; but not always\n+            return _deserializeFromEmptyString();\n+        }\n+        Exception cause = null;\n+        try {\n+            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n+            //    indicated error; but that seems wrong. Should be able to return\n+            //    `null` as value.\n+            Object res = _deserialize(text, ctxt);\n+            if (res != null && _valueClass.isAssignableFrom(res.getClass())) {\n+                return (T) res;\n             }\n-            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n-            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n-            if (cause != null) {\n-                e.initCause(cause);\n+            return null;\n+        } catch (IllegalArgumentException iae) {\n+            cause = iae;\n+        } catch (MalformedURLException me) {\n+            cause = me;\n+        }\n+        String msg = \"not a valid textual representation\";\n+        if (cause != null) {\n+            String m2 = cause.getMessage();\n+            if (m2 != null) {\n+                msg = msg + \", problem: \"+m2;\n             }\n-            throw e;\n-            // nothing to do here, yet? We'll fail anyway\n         }\n-        JsonToken t = p.getCurrentToken();\n-        // [databind#381]\n-        if (t == JsonToken.START_ARRAY) {\n-            return _deserializeFromArray(p, ctxt);\n+        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n+        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n+        if (cause != null) {\n+            e.initCause(cause);\n         }\n-        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n-            // Trivial cases; null to null, instance of type itself returned as is\n-            Object ob = p.getEmbeddedObject();\n-            if (ob == null) {\n-                return null;\n-            }\n-            if (_valueClass.isAssignableFrom(ob.getClass())) {\n-                return (T) ob;\n-            }\n-            return _deserializeEmbedded(ob, ctxt);\n+        throw e;\n+    }\n+    JsonToken t = p.getCurrentToken();\n+    // [databind#381]\n+    if (t == JsonToken.START_ARRAY) {\n+        return _deserializeFromArray(p, ctxt);\n+    }\n+    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+        // Trivial cases; null to null, instance of type itself returned as is\n+        Object ob = p.getEmbeddedObject();\n+        if (ob == null) {\n+            return null;\n+        }\n+        if (_valueClass.isAssignableFrom(ob.getClass())) {\n+            return (T) ob;\n         }\n-        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n+        return _deserializeEmbedded(ob, ctxt);\n     }\n+    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n+}\n+\n         \n     protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n "}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if (ct.getValueHandler() != null) {\n                    return true;\n                }\n                if (ct.getTypeHandler() != null) {\n                    return true;\n                }\n                // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n                JavaType keyType = t.getKeyType();\n                if (keyType != null) {\n                    if (keyType.getValueHandler() != null) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\nindex aae7e87f5..dbe450653 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n@@ -533,18 +533,30 @@ public final class DeserializerCache\n      *\n      * @since 2.8.11\n      */\n+\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n-            // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n-            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n+                if (ct.getValueHandler() != null) {\n+                    return true;\n+                }\n+                if (ct.getTypeHandler() != null) {\n+                    return true;\n+                }\n+                // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n+                JavaType keyType = t.getKeyType();\n+                if (keyType != null) {\n+                    if (keyType.getValueHandler() != null) {\n+                        return true;\n+                    }\n+                }\n             }\n         }\n         return false;\n     }\n \n+\n     private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n     {\n         if (src == null) {"}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "            paramName = candidate.paramName(0);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 7057c5427..042cf0afd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -732,7 +732,7 @@ nonAnnotatedParamIndex, ctor);\n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+            paramName = candidate.paramName(0);\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {"}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        sb.append('>');", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\nindex 4add34ee0..e8c69628c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n@@ -166,6 +166,7 @@ public class ReferenceType extends SimpleType\n         sb.append(_class.getName());\n         sb.append('<');\n         sb.append(_referencedType.toCanonical());\n+        sb.append('>');\n         return sb.toString();\n     }\n "}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n            if (docData.startsWith(\"\\uFEFF\")) {\n                docData = docData.substring(1);\n            }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex e5b044d..004b7f1 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -96,6 +96,11 @@ public class DataUtil {\n             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n             // into head mode\n \n+            if (docData.startsWith(\"\\uFEFF\")) {\n+                docData = docData.substring(1);\n+            }\n+\n+\n             doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }"}
{"project": "Jsoup", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "attempt": 17, "mode": "SL", "patch": "    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};", "diff": "diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex 40b7557..caebf4e 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -215,7 +215,7 @@ public class Tag {\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n     static {\n         // creates"}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "            if (offset < length - seq.length() + 1) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex dc1b114..e60ade8 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -88,7 +88,7 @@ class CharacterReader {\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+            if (offset < length - seq.length() + 1) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;"}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "doc = parser.parseInput(docData, baseUri);", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex d43bfe4..153ce49 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -116,6 +116,7 @@ public class DataUtil {\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n             charsetName = defaultCharset;\n+doc = parser.parseInput(docData, baseUri);\n         }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);"}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "        Validate.notNull(name);", "diff": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex 4b4a5e9..c5ab1db 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -19,7 +19,7 @@ public class DocumentType extends Node {\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+        Validate.notNull(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);"}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return this.outerHtml().equals(element.outerHtml());", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex cd2e86a..b9fee73 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1172,7 +1172,7 @@ public class Element extends Node {\n \n         Element element = (Element) o;\n \n-        return this == o;\n+        return this.outerHtml().equals(element.outerHtml());\n     }\n \n     @Override"}
{"project": "Jsoup", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "43", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "            if (element == search)", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex f1ae8dd..51cdd38 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -565,13 +565,14 @@ public class Element extends Node {\n         return siblings.size() > 1 ? siblings.get(siblings.size() - 1) : null;\n     }\n     \n+\n     private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n         Validate.notNull(search);\n         Validate.notNull(elements);\n \n         for (int i = 0; i < elements.size(); i++) {\n             E element = elements.get(i);\n-            if (element.equals(search))\n+            if (element == search)\n                 return i;\n         }\n         return null;"}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 4a58fdf..4ac8870 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -391,7 +391,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {"}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "                            accum.append(\"&#x\" + Integer.toHexString(c) + \";\");", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 6ccb84e..51d1488 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -115,7 +115,7 @@ public class Entities {\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                            accum.append(\"&#x\" + Integer.toHexString(c) + \";\");\n                         break;\n                     case '<':\n                         if (!inAttribute)"}
{"project": "Jsoup", "bug_id": "47", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "48", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else if (!values.isEmpty()) { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    header(name, String.join(\", \", values)); // join values with comma space\n                }\n            }\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex f8fd9dd..dd2b0fd 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -750,6 +750,7 @@ public class HttpConnection implements Connection {\n             return headers;\n         }\n \n+\n         void processResponseHeaders(Map<String, List<String>> resHeaders) {\n             for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                 String name = entry.getKey();\n@@ -769,13 +770,13 @@ public class HttpConnection implements Connection {\n                         if (cookieName.length() > 0)\n                             cookie(cookieName, cookieVal);\n                     }\n-                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n-                        header(name, values.get(0));\n+                } else if (!values.isEmpty()) { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+                    header(name, String.join(\", \", values)); // join values with comma space\n                 }\n             }\n         }\n \n+\n         private static String setOutputContentType(final Connection.Request req) {\n             // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n             boolean needsMulti = false;"}
{"project": "Jsoup", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "54", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "                key = attribute.getKey().replaceAll(\"[^a-zA-Z0-9_:]\", \"_\");", "diff": "diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java\nindex 20aeeda..9aefe8a 100644\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n@@ -123,6 +123,7 @@ public class W3CDom {\n             for (Attribute attribute : source.attributes()) {\n                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n+                key = attribute.getKey().replaceAll(\"[^a-zA-Z0-9_:]\", \"_\");\n                     el.setAttribute(key, attribute.getValue());\n             }\n         }"}
{"project": "Jsoup", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                it.remove();", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 49ff25d..8fdb654 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -122,7 +122,7 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n             String attrKey = it.next();\n             if (attrKey.equalsIgnoreCase(key))\n-                attributes.remove(attrKey);\n+                it.remove();\n         }\n     }\n "}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (!pendingAttributeName.isEmpty()) {\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n                }\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex 7dcfa2b..a39282f 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -97,6 +97,7 @@ abstract class Token {\n             return this;\n         }\n \n+\n         final void newAttribute() {\n             if (attributes == null)\n                 attributes = new Attributes();\n@@ -104,6 +105,7 @@ abstract class Token {\n             if (pendingAttributeName != null) {\n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n+                if (!pendingAttributeName.isEmpty()) {\n                     Attribute attribute;\n                     if (hasPendingAttributeValue)\n                         attribute = new Attribute(pendingAttributeName,\n@@ -113,6 +115,7 @@ abstract class Token {\n                     else\n                         attribute = new BooleanAttribute(pendingAttributeName);\n                     attributes.put(attribute);\n+                }\n             }\n             pendingAttributeName = null;\n             hasEmptyAttributeValue = false;\n@@ -121,6 +124,7 @@ abstract class Token {\n             pendingAttributeValueS = null;\n         }\n \n+\n         final void finaliseTag() {\n             // finalises for emit\n             if (pendingAttributeName != null) {"}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "68", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node == null || !(node instanceof Element)) {\n            return false;\n        }\n        \n        for (int i = 0; i < 6; i++) {\n            Element el = (Element) node;\n            if (el.tag.preserveWhitespace()) {\n                return true;\n            }\n            \n            if (el.parent() == null || i == 5) {\n                return false;\n            }\n            \n            node = el.parent();\n        }\n        \n        return false;\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex faca4c8..86b8a02 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1084,18 +1084,30 @@ public class Element extends Node {\n             accum.append(\" \");\n     }\n \n+\n     static boolean preserveWhitespace(Node node) {\n         // looks only at this element and five levels up, to prevent recursion & needless stack searches\n-        if (node != null && node instanceof Element) {\n+        if (node == null || !(node instanceof Element)) {\n+            return false;\n+        }\n+        \n+        for (int i = 0; i < 6; i++) {\n             Element el = (Element) node;\n-                if (el.tag.preserveWhitespace())\n-                    return true;\n-                else\n-                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n+            if (el.tag.preserveWhitespace()) {\n+                return true;\n+            }\n+            \n+            if (el.parent() == null || i == 5) {\n+                return false;\n+            }\n+            \n+            node = el.parent();\n         }\n+        \n         return false;\n     }\n \n+\n     /**\n      * Set the text of this element. Any existing contents (text or elements) will be cleared\n      * @param text unencoded text"}
{"project": "Jsoup", "bug_id": "72", "eval": "PASS", "attempt": 4, "mode": "SH", "patch": "\n        // check if the input is empty or has zero count\n        if (count <= 0) {\n            return \"\";\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 9ed4163..6a1fded 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -425,6 +425,12 @@ public final class CharacterReader {\n         if (count > maxStringCacheLen)\n             return new String(charBuf, start, count);\n \n+        // check if the input is empty or has zero count\n+        if (count <= 0) {\n+            return \"\";\n+        }\n+\n+\n         // calculate hash:\n         int hash = 0;\n         int offset = start;"}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "77", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "        String elName = endTag.name().toLowerCase();", "diff": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 65d3045..3c4e96c 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -114,7 +114,7 @@ public class XmlTreeBuilder extends TreeBuilder {\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.name();\n+        String elName = endTag.name().toLowerCase();\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {"}
{"project": "Jsoup", "bug_id": "80", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "82", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n        if (input == null) // empty body\n            return new Document(baseUri);\n        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n        Document doc = null;\n        boolean fullyRead = false;\n\n        // read the start of the stream and look for a BOM or meta charset\n        input.mark(bufferSize);\n        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n        fullyRead = input.read() == -1;\n        input.reset();\n\n        // look for BOM - overrides any other header or input\n        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n        if (bomCharset != null)\n            charsetName = bomCharset.charset;\n\n        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n            doc = parser.parseInput(docData, baseUri);\n\n            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n            for (Element meta : metaElements) {\n                if (meta.hasAttr(\"http-equiv\"))\n                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n                if (foundCharset == null && meta.hasAttr(\"charset\"))\n                    foundCharset = meta.attr(\"charset\");\n                if (foundCharset != null)\n                    break;\n            }\n\n            // look for <?xml encoding='ISO-8859-1'?>\n            if (foundCharset == null && doc.childNodeSize() > 0) {\n                Node first = doc.childNode(0);\n                XmlDeclaration decl = null;\n                if (first instanceof XmlDeclaration)\n                    decl = (XmlDeclaration) first;\n                else if (first instanceof Comment) {\n                    Comment comment = (Comment) first;\n                    if (comment.isXmlDeclaration())\n                        decl = comment.asXmlDeclaration();\n                }\n                if (decl != null) {\n                    if (decl.name().equalsIgnoreCase(\"xml\"))\n                        foundCharset = decl.attr(\"encoding\");\n                }\n            }\n            foundCharset = validateCharset(foundCharset);\n            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n                charsetName = foundCharset;\n                doc = null;\n            } else if (!fullyRead) {\n                doc = null;\n            }\n        } else { // specified by content type header (or by user on file load)\n            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n        }\n        if (doc == null) {\n            if (charsetName == null)\n                charsetName = defaultCharset;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n                reader.skip(1);\n            try {\n                doc = parser.parseInput(reader, baseUri);\n            } catch (UncheckedIOException e) {\n                // io exception when parsing (not seen before because reading the stream as we go)\n                throw e.ioException();\n            }\n            Charset charset = Charset.forName(charsetName);\n            doc.outputSettings().charset(charset);\n\n            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n            if (!charset.canEncode()) {\n                Charset encodableCharset = Charset.forName(\"UTF-8\");\n                doc.outputSettings().charset(encodableCharset);\n\n                // update the meta el with the correct charset\n                Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n                for (Element meta : metaElements) {\n                    if (meta.hasAttr(\"http-equiv\")) {\n                        String content = meta.attr(\"content\");\n                        if (content.contains(\"charset\")) {\n                            meta.attr(\"content\", content.replace(\"charset=utf-8\", \"charset=\" + encodableCharset));\n                        }\n                    } else if (meta.hasAttr(\"charset\")) {\n                        meta.attr(\"charset\", encodableCharset.toString());\n                    }\n                }\n            }\n        }\n        input.close();\n        return doc;\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex dc12cb3..932b64f 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -92,6 +92,7 @@ public final class DataUtil {\n         }\n     }\n \n+\n     static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n         if (input == null) // empty body\n             return new Document(baseUri);\n@@ -168,12 +169,31 @@ public final class DataUtil {\n             }\n             Charset charset = Charset.forName(charsetName);\n             doc.outputSettings().charset(charset);\n-                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n+\n+            // some charsets can read but not encode; switch to an encodable charset and update the meta el\n+            if (!charset.canEncode()) {\n+                Charset encodableCharset = Charset.forName(\"UTF-8\");\n+                doc.outputSettings().charset(encodableCharset);\n+\n+                // update the meta el with the correct charset\n+                Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n+                for (Element meta : metaElements) {\n+                    if (meta.hasAttr(\"http-equiv\")) {\n+                        String content = meta.attr(\"content\");\n+                        if (content.contains(\"charset\")) {\n+                            meta.attr(\"content\", content.replace(\"charset=utf-8\", \"charset=\" + encodableCharset));\n+                        }\n+                    } else if (meta.hasAttr(\"charset\")) {\n+                        meta.attr(\"charset\", encodableCharset.toString());\n+                    }\n+                }\n+            }\n         }\n         input.close();\n         return doc;\n     }\n \n+\n     /**\n      * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this\n      * method is executing on. The data read until being interrupted will be available."}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        this.key = key.trim();\n        Validate.notEmpty(key.trim()); // trimming could potentially make empty, so validate here\n        this.val = val;\n        this.parent = parent;\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 612fdeb..97b5467 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -39,14 +39,16 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      * @param val attribute value\n      * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n      * @see #createFromEncoded*/\n+\n     public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n         this.key = key.trim();\n-        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n+        Validate.notEmpty(key.trim()); // trimming could potentially make empty, so validate here\n         this.val = val;\n         this.parent = parent;\n     }\n \n+\n     /**\n      Get the attribute key.\n      @return the attribute key"}
{"project": "Jsoup", "bug_id": "86", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "88", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return val != null ? val : \"\";", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex e321b6a..5ef2c46 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -77,7 +77,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      @return the attribute value\n      */\n     public String getValue() {\n-        return val;\n+        return val != null ? val : \"\";\n     }\n \n     /**"}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public String setValue(String val) {\n        String oldVal = getValue();\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 4ff695d..81fd9b5 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -84,8 +84,9 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      Set the attribute value.\n      @param val the new attribute value; must not be null\n      */\n+\n     public String setValue(String val) {\n-        String oldVal = parent.get(this.key);\n+        String oldVal = getValue();\n         if (parent != null) {\n             int i = parent.indexOfKey(this.key);\n             if (i != Attributes.NotFound)\n@@ -95,6 +96,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n         return Attributes.checkNotNull(oldVal);\n     }\n \n+\n     /**\n      Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n      @return HTML"}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n                    if (i + 3 > j) {\n                        return false;\n                    }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex a941e48..e83f45a 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -422,6 +422,11 @@ public class HttpConnection implements Connection {\n                 }\n \n \n+                    if (i + 3 > j) {\n+                        return false;\n+                    }\n+\n+\n                 while (i < end) {\n                     i++;\n                     o = input[i];"}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "5", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        return -1;\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\nindex 6ff8d5f..a08241c 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java\n@@ -662,9 +662,9 @@ public abstract class NodePointer implements Pointer {\n         }\n \n         if (depth1 == 1) {\n-            throw new JXPathException(\n-                    \"Cannot compare pointers that do not belong to the same tree: '\"\n-                            + p1 + \"' and '\" + p2 + \"'\");\n+\n+        return -1;\n+\n         }\n         int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);\n         if (r != 0) {\n@@ -703,4 +703,4 @@ public abstract class NodePointer implements Pointer {\n             printDeep(pointer.getImmediateParentPointer(), indent + \"  \");\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String namespaceURI = element.getNamespaceURI();\n\n        if (namespaceURI != null) {\n            return namespaceURI;\n        }\n\n        String prefix = getPrefix(node);\n\n        if (prefix != null) {\n            String qname = \"xmlns:\" + prefix;\n\n            Node aNode = node;\n\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        return attr.getValue();\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n        }\n\n        return null;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex f8e3b1a..bb9fee7 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -669,6 +669,7 @@ public class DOMNodePointer extends NodePointer {\n      * @param node Node to check\n      * @return String ns uri\n      */\n+\n     public static String getNamespaceURI(Node node) {\n         if (node instanceof Document) {\n             node = ((Document) node).getDocumentElement();\n@@ -676,12 +677,19 @@ public class DOMNodePointer extends NodePointer {\n \n         Element element = (Element) node;\n \n-        String uri = element.getNamespaceURI();\n-        if (uri == null) {\n-            String prefix = getPrefix(node);\n-            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n-    \n+        String namespaceURI = element.getNamespaceURI();\n+\n+        if (namespaceURI != null) {\n+            return namespaceURI;\n+        }\n+\n+        String prefix = getPrefix(node);\n+\n+        if (prefix != null) {\n+            String qname = \"xmlns:\" + prefix;\n+\n             Node aNode = node;\n+\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                     Attr attr = ((Element) aNode).getAttributeNode(qname);\n@@ -691,11 +699,12 @@ public class DOMNodePointer extends NodePointer {\n                 }\n                 aNode = aNode.getParentNode();\n             }\n-            return null;\n         }\n-        return uri;\n+\n+        return null;\n     }\n \n+\n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();"}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1.length() != cs2.length()) {\n            return false;\n        }\n        return cs1.toString().equals(cs2.toString());\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 535a3f24..8a9bd2c9 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -778,6 +778,7 @@ public class StringUtils {\n      * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n      */\n+\n     public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == cs2) {\n             return true;\n@@ -785,9 +786,13 @@ public class StringUtils {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n-            return cs1.equals(cs2);\n+        if (cs1.length() != cs2.length()) {\n+            return false;\n+        }\n+        return cs1.toString().equals(cs2.toString());\n     }\n \n+\n     /**\n      * <p>Compares two CharSequences, returning {@code true} if they represent\n      * equal sequences of characters, ignoring case.</p>"}
{"project": "Lang", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 9a24c00f..52a44363 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&"}
{"project": "Lang", "bug_id": "22", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\nprivate static int greatestCommonDivisor(int a, int b) {\n    // Handle simple cases where one of the numbers is 0 or 1\n    if (a == 0 || b == 0) {\n        return 0;\n    }\n    if (a == 1 || b == 1 || a == -1 || b == -1) {\n        return 1;\n    }\n    // Ensure a is positive\n    if (a < 0) {\n        a = -a;\n    }\n    // Ensure b is positive\n    if (b < 0) {\n        b = -b;\n    }\n    // Use the Euclidean algorithm\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156a..4e6b8b41 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -578,50 +578,32 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n      * @param v  a non-zero number\n      * @return the greatest common divisor, never zero\n      */\n-    private static int greatestCommonDivisor(int u, int v) {\n-        // From Commons Math:\n-        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n-            return 1;\n-        }\n-        // keep u and v negative, as negative integers range down to\n-        // -2^31, while positive numbers can only be as large as 2^31-1\n-        // (i.e. we can't necessarily negate a negative number without\n-        // overflow)\n-        if (u>0) { u=-u; } // make u negative\n-        if (v>0) { v=-v; } // make v negative\n-        // B1. [Find power of 2]\n-        int k=0;\n-        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n-            u/=2; v/=2; k++; // cast out twos.\n-        }\n-        if (k==31) {\n-            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n-        }\n-        // B2. Initialize: u and v have been divided by 2^k and at least\n-        //     one is odd.\n-        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n-        // t negative: u was odd, v may be even (t replaces v)\n-        // t positive: u was even, v is odd (t replaces u)\n-        do {\n-            /* assert u<0 && v<0; */\n-            // B4/B3: cast out twos from t.\n-            while ((t&1)==0) { // while t is even..\n-                t/=2; // cast out twos\n-            }\n-            // B5 [reset max(u,v)]\n-            if (t>0) {\n-                u = -t;\n-            } else {\n-                v = t;\n-            }\n-            // B6/B3. at this point both u and v should be odd.\n-            t = (v - u)/2;\n-            // |u| larger: t positive (replace u)\n-            // |v| larger: t negative (replace v)\n-        } while (t!=0);\n-        return -u*(1<<k); // gcd is u*2^k\n+\n+private static int greatestCommonDivisor(int a, int b) {\n+    // Handle simple cases where one of the numbers is 0 or 1\n+    if (a == 0 || b == 0) {\n+        return 0;\n     }\n+    if (a == 1 || b == 1 || a == -1 || b == -1) {\n+        return 1;\n+    }\n+    // Ensure a is positive\n+    if (a < 0) {\n+        a = -a;\n+    }\n+    // Ensure b is positive\n+    if (b < 0) {\n+        b = -b;\n+    }\n+    // Use the Euclidean algorithm\n+    while (b != 0) {\n+        int temp = b;\n+        b = a % b;\n+        a = temp;\n+    }\n+    return a;\n+}\n+\n \n     // Arithmetic\n     //-------------------------------------------------------------------"}
{"project": "Lang", "bug_id": "24", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                return foundDigit && !hasExp && !hasDecPoint;", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 4a1d8459..d9b3c6de 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -1410,7 +1410,7 @@ public class NumberUtils {\n             if (chars[i] == 'l'\n                 || chars[i] == 'L') {\n                 // not allowing L with an exponent or decimal point\n-                return foundDigit && !hasExp;\n+                return foundDigit && !hasExp && !hasDecPoint;\n             }\n             // last character is illegal\n             return false;"}
{"project": "Lang", "bug_id": "26", "eval": "PASS", "attempt": 14, "mode": "SL", "patch": "        Calendar c = new GregorianCalendar(mTimeZone, Locale.FRENCH);", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e30da2a5..8a0f2955 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -817,7 +817,7 @@ public class FastDateFormat extends Format {\n      * @return the formatted string\n      */\n     public String format(Date date) {\n-        Calendar c = new GregorianCalendar(mTimeZone);\n+        Calendar c = new GregorianCalendar(mTimeZone, Locale.FRENCH);\n         c.setTime(date);\n         return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();\n     }"}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "            classes[i] = array[i] != null ? array[i].getClass() : null;", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9a..a6767c9e 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,7 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = array[i] != null ? array[i].getClass() : null;\n         }\n         return classes;\n     }"}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "attempt": 13, "mode": "SF", "patch": "\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        if (!type1.isAssignableFrom(array2.getClass().getComponentType())) {\n            throw new IllegalArgumentException(\"Cannot add array of different types\");\n        }\n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n        return joinedArray;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/lang3/ArrayUtils.java b/src/java/org/apache/commons/lang3/ArrayUtils.java\nindex 889497e9..eb197199 100644\n--- a/src/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2950,6 +2950,7 @@ public class ArrayUtils {\n      * @since 2.1\n      */\n     @SuppressWarnings(\"unchecked\")\n+\n     public static <T> T[] addAll(T[] array1, T... array2) {\n         if (array1 == null) {\n             return clone(array2);\n@@ -2957,13 +2958,16 @@ public class ArrayUtils {\n             return clone(array1);\n         }\n         final Class<?> type1 = array1.getClass().getComponentType();\n+        if (!type1.isAssignableFrom(array2.getClass().getComponentType())) {\n+            throw new IllegalArgumentException(\"Cannot add array of different types\");\n+        }\n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-            // Check if problem is incompatible types\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n         return joinedArray;\n     }\n \n+\n     /**\n      * <p>Adds all the elements of the given arrays into a new array.</p>\n      * <p>The new array contains all of the element of <code>array1</code> followed"}
{"project": "Lang", "bug_id": "38", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "            calendar.setTimeInMillis(calendar.getTimeInMillis());", "diff": "diff --git a/src/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex 6b10a94f..2b924f88 100644\n--- a/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -869,6 +869,7 @@ public class FastDateFormat extends Format {\n      */\n     public StringBuffer format(Calendar calendar, StringBuffer buf) {\n         if (mTimeZoneForced) {\n+            calendar.setTimeInMillis(calendar.getTimeInMillis());\n             calendar = (Calendar) calendar.clone();\n             calendar.setTimeZone(mTimeZone);\n         }"}
{"project": "Lang", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n", "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883e..db7bd6f4 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -613,6 +613,11 @@ public class WordUtils {\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n+\n+        if (lower > str.length()) {\n+            lower = str.length();\n+        }\n+\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {"}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                return false;", "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ecc..8b5028c4 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -679,6 +679,7 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n+                return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);"}
{"project": "Lang", "bug_id": "52", "eval": "PASS", "attempt": 8, "mode": "SH", "patch": "\n                    case '/':\n                        if (ch == '/') {\n                            out.write('\\\\');\n                        }\n                        out.write('/');\n                        break;\n", "diff": "diff --git a/src/java/org/apache/commons/lang/StringEscapeUtils.java b/src/java/org/apache/commons/lang/StringEscapeUtils.java\nindex 4fda091d..6e831df9 100644\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -233,6 +233,14 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n+\n+                    case '/':\n+                        if (ch == '/') {\n+                            out.write('\\\\');\n+                        }\n+                        out.write('/');\n+                        break;\n+\n                     default :\n                         out.write(ch);\n                         break;"}
{"project": "Lang", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if (this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n            this.runningState = STATE_STOPPED;\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/lang/time/StopWatch.java b/src/java/org/apache/commons/lang/time/StopWatch.java\nindex 8f394217..2d56265c 100644\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -111,14 +111,18 @@ public class StopWatch {\n      *\n      * @throws IllegalStateException if the StopWatch is not running.\n      */\n+\n     public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+        if (this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n-        this.runningState = STATE_STOPPED;\n+            this.runningState = STATE_STOPPED;\n+        }\n     }\n \n+\n     /**\n      * <p>Resets the stopwatch. Stops it if need be. </p>\n      * "}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);", "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e8..86b31d4b 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------"}
{"project": "Lang", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "59", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "2", "eval": "PASS", "attempt": 16, "mode": "SL", "patch": "        return (double) getSampleSize() * getNumberOfSuccesses() / getPopulationSize();", "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\nindex 27691272f..614e24044 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+        return (double) getSampleSize() * getNumberOfSuccesses() / getPopulationSize();\n     }\n \n     /**"}
{"project": "Math", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "30", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "32", "eval": "PASS", "attempt": 12, "mode": "SL", "patch": "            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {", "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex c6e7cf18c..6bc289ff0 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);"}
{"project": "Math", "bug_id": "33", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "            if (Precision.compareTo(entry, 0d, 1E-10) > 0) {", "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a55..ee71be2ee 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, 1E-10) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }"}
{"project": "Math", "bug_id": "34", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "        return Collections.unmodifiableList(chromosomes).iterator();", "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 1eb005316..bb9e18201 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return Collections.unmodifiableList(chromosomes).iterator();\n     }\n }"}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "41", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "                for (int i = begin; i < begin + length; i++) {", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..1de139f3e 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n "}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "50", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n                    if (x == x1) {\n                        x0 = x0 + FastMath.abs(x0 - x1) * (rtol * FastMath.abs(x1) + atol) / (1 + rtol);\n                        f0 = computeObjectiveValue(x0);\n                    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..0c6c1426f 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,12 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = x0 + FastMath.abs(x0 - x1) * (rtol * FastMath.abs(x1) + atol) / (1 + rtol);\n                         f0 = computeObjectiveValue(x0);\n                     }\n+\n                     break;\n                 default:\n                     // Should never happen."}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "53", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (rhs.isNaN()) {\n            return createComplex(Double.NaN, Double.NaN);\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..6fd8ab74e 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,11 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+\n+        if (rhs.isNaN()) {\n+            return createComplex(Double.NaN, Double.NaN);\n+        }\n+\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }"}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "56", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            double sum = 0;", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..e09bbc357 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);"}
{"project": "Math", "bug_id": "58", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "        return fit(guess);", "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex ae7ac3994..e1b54f49e 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,7 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        return fit(guess);\n     }\n \n     /**"}
{"project": "Math", "bug_id": "59", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        return Math.max(a, b);", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..90e4134da 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return Math.max(a, b);\n     }\n \n     /** Compute the maximum of two values"}
{"project": "Math", "bug_id": "60", "eval": "PASS", "attempt": 14, "mode": "SF", "patch": "\n    public double cumulativeProbability(double x) throws MathException {\n        final double dev = x - mean;\n        try {\n            return 0.5 * (1.0 + Erf.erf(dev / (standardDeviation * FastMath.sqrt(2.0))));\n        } catch (MathException e) {\n            if (x < (mean - 20 * standardDeviation)) {\n                return 0;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1;\n            } else {\n                throw e;\n            }\n        }\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 0e124d852..7ce09730c 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -121,22 +121,23 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n+\n     public double cumulativeProbability(double x) throws MathException {\n         final double dev = x - mean;\n         try {\n-        return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n+            return 0.5 * (1.0 + Erf.erf(dev / (standardDeviation * FastMath.sqrt(2.0))));\n+        } catch (MathException e) {\n+            if (x < (mean - 20 * standardDeviation)) {\n                 return 0;\n             } else if (x > (mean + 20 * standardDeviation)) {\n                 return 1;\n             } else {\n-                throw ex;\n+                throw e;\n             }\n         }\n     }\n \n+\n     /**\n      * Return the absolute accuracy setting of the solver used to estimate\n      * inverse cumulative probabilities."}
{"project": "Math", "bug_id": "63", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        return x == y;", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 136184990..84fbcca82 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return x == y;\n     }\n \n     /**"}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "70", "eval": "PASS", "attempt": 18, "mode": "SL", "patch": "        return solve(f, initial, max);", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..799314662 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,7 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        return solve(f, initial, max);\n     }\n \n     /** {@inheritDoc} */"}
{"project": "Math", "bug_id": "72", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "73", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "79", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "80", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "            int j = 4 * n - 4;", "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d8b..04a2ce6a8 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * n - 4;\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];"}
{"project": "Math", "bug_id": "82", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "            if (entry > 0) {", "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b40..cf736aa64 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (entry > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;"}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "85", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        if (fa * fb >= 0.000001) {", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf53..d403614fe 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb >= 0.000001) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +"}
{"project": "Math", "bug_id": "86", "eval": "PASS", "attempt": 20, "mode": "SF", "patch": "\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n            }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n            if(ltI[i] <= 0){\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\nindex acd9222f6..85a13621e 100644\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -90,6 +90,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n+\n     public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                      final double relativeSymmetryThreshold,\n                                      final double absolutePositivityThreshold)\n@@ -125,7 +126,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n                     throw new NotSymmetricMatrixException();\n                 }\n                 lJ[i] = 0;\n-           }\n+            }\n         }\n \n         // transform the matrix\n@@ -134,7 +135,9 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n             final double[] ltI = lTData[i];\n \n             // check diagonal element\n-\n+            if(ltI[i] <= 0){\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n \n@@ -150,6 +153,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n     }\n \n+\n     /** {@inheritDoc} */\n     public RealMatrix getL() {\n         if (cachedL == null) {"}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "89", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\npublic void addValue(Object v) {\n    if (v instanceof Comparable<?>) {\n        addValue((Comparable<?>) v);\n    } else {\n        throw new IllegalArgumentException(\"Value must be Comparable\");\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca31a..d726a5d7e 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -106,9 +106,15 @@ public class Frequency implements Serializable {\n      * @deprecated use {@link #addValue(Comparable)} instead\n      */\n     @Deprecated\n-    public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+\n+public void addValue(Object v) {\n+    if (v instanceof Comparable<?>) {\n+        addValue((Comparable<?>) v);\n+    } else {\n+        throw new IllegalArgumentException(\"Value must be Comparable\");\n     }\n+}\n+\n     \n     /**\n      * Adds 1 to the frequency count for v."}
{"project": "Math", "bug_id": "91", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        int nOd = numerator * object.denominator;\n        int dOn = denominator * object.numerator;\n", "diff": "diff --git a/src/java/org/apache/commons/math/fraction/Fraction.java b/src/java/org/apache/commons/math/fraction/Fraction.java\nindex 0706f8c41..5a48f6a08 100644\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n@@ -256,8 +256,10 @@ public class Fraction extends Number implements Comparable<Fraction> {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+\n+        int nOd = numerator * object.denominator;\n+        int dOn = denominator * object.numerator;\n+\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     "}
{"project": "Math", "bug_id": "94", "eval": "PASS", "attempt": 15, "mode": "SL", "patch": "        if (u == 0 || v == 0) {", "diff": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex c5342aeb3..841714262 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+        if (u == 0 || v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to"}
{"project": "Math", "bug_id": "95", "eval": "PASS", "attempt": 11, "mode": "SF", "patch": "\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d < 3) {\n            ret = 0.0;\n        } else {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97aef..2ce0ba525 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -140,13 +140,18 @@ public class FDistributionImpl\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n+        if (d < 3) {\n+            ret = 0.0;\n+        } else {\n             ret = d / (d - 2.0);\n+        }\n         return ret;\n     }\n+\n     \n     /**\n      * Modify the numerator degrees of freedom."}
{"project": "Math", "bug_id": "96", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());", "diff": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 3571567f8..7bc9e2688 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception"}
{"project": "Math", "bug_id": "97", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\n    public double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) < 1e-10) {\n                return min;\n            } else if (Math.abs(yMax) < 1e-10) {\n                return max;\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        }\n\n        return ret;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..0135475a3 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,6 +122,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n+\n     public double solve(double min, double max) throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n         \n@@ -137,11 +138,17 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         double sign = yMin * yMax;\n         if (sign >= 0) {\n             // check if either value is close to a zero\n+            if (Math.abs(yMin) < 1e-10) {\n+                return min;\n+            } else if (Math.abs(yMax) < 1e-10) {\n+                return max;\n+            } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            }\n         } else {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n@@ -150,6 +157,7 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n \n         return ret;\n     }\n+\n         \n     /**\n      * Find a zero starting search according to the three provided points."}
{"project": "Math", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "103", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "1", "eval": "PASS", "attempt": 17, "mode": "SH", "patch": "\n                return;\n", "diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex 7b877b1e2..0140a06b2 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -120,7 +120,9 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArgumensF\n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+\n+                return;\n+\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {"}
{"project": "Mockito", "bug_id": "5", "eval": "PASS", "attempt": 15, "mode": "SL", "patch": "            catch (AssertionError e) {", "diff": "diff --git a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\nindex c5a66c501..4ea2463ad 100644\n--- a/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n+++ b/src/org/mockito/internal/verification/VerificationOverTimeImpl.java\n@@ -88,7 +88,7 @@ public class VerificationOverTimeImpl implements VerificationMode {\n             } catch (MockitoAssertionError e) {\n                 error = handleVerifyException(e);\n             }\n-            catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n+            catch (AssertionError e) {\n                 error = handleVerifyException(e);\n             }\n         }"}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "12", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof ParameterizedType) {\n                actual = ((ParameterizedType) actual).getRawType();\n            }\n            return (Class) actual;\n        }\n        \n        return Object.class;\n    }\n", "diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMaster.java b/src/org/mockito/internal/util/reflection/GenericMaster.java\nindex 64bf1540f..bcb08e8ef 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n@@ -13,14 +13,18 @@ public class GenericMaster {\n      * @param field\n      * @return\n      */\n-    public Class getGenericType(Field field) {        \n-        Type generic = field.getGenericType();\n-        if (generic != null && generic instanceof ParameterizedType) {\n-            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n-                return (Class) actual;\n-                //in case of nested generics we don't go deep\n-        }\n-        \n-        return Object.class;\n-    }\n+\n+    public Class getGenericType(Field field) {        \n+        Type generic = field.getGenericType();\n+        if (generic != null && generic instanceof ParameterizedType) {\n+            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n+            if (actual instanceof ParameterizedType) {\n+                actual = ((ParameterizedType) actual).getRawType();\n+            }\n+            return (Class) actual;\n+        }\n+        \n+        return Object.class;\n+    }\n+\n }"}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        primitiveValues.put(double.class, 0D);", "diff": "diff --git a/src/org/mockito/internal/util/Primitives.java b/src/org/mockito/internal/util/Primitives.java\nindex b44b8253d..48ab82398 100644\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public class Primitives {\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+        primitiveValues.put(double.class, 0D);\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "29", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        description.appendText(String.valueOf(wanted));", "diff": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex 6c172fee2..45e7ba4af 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,7 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        description.appendText(String.valueOf(wanted));\n         appendQuoting(description);\n         description.appendText(\")\");\n     }"}
{"project": "Mockito", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "            if (m instanceof CapturesArguments && k < i.getArguments().length) {", "diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex c72b119dd..26fa82feb 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -103,10 +103,10 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+            if (m instanceof CapturesArguments && k < i.getArguments().length) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        return arg == null ? m.toString().equals(\"null\") : StringDescription.toString(m).equals(arg.toString());", "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc539..93e0857eb 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -44,7 +44,8 @@ public class ArgumentMatchingTool {\n         }\n     }\n \n+\n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        return arg == null ? m.toString().equals(\"null\") : StringDescription.toString(m).equals(arg.toString());\n     }\n }"}
{"project": "Time", "bug_id": "4", "eval": "PASS", "attempt": 11, "mode": "SL", "patch": "            Partial newPartial = new Partial(newTypes, newValues);", "diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf47..9a91995c 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,7 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+            Partial newPartial = new Partial(newTypes, newValues);\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }"}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "19", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "            } else if (offsetLocal >= 0) {", "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad05..7a42704a 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+            } else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);"}
{"project": "Time", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
