{"project": "Chart", "bug_id": "1", "eval": "PASS", "patch": "if (dataset == null) {", "rollout": 1}
{"project": "Chart", "bug_id": "3", "eval": "PASS", "patch": "copy.minY = Double.POSITIVE_INFINITY;\ncopy.maxY = Double.NEGATIVE_INFINITY;", "rollout": 5}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "patch": "    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (r != null) {\n                    if (isDomainAxis) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n                }\n                else {\n                    if (isDomainAxis) {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }", "rollout": 2}
{"project": "Chart", "bug_id": "5", "eval": "PASS", "patch": "public XYDataItem addOrUpdate(Number x, Number y) {\n    if (x == null) {\n        throw new IllegalArgumentException(\"Null 'x' argument.\");\n    }\n\n    // if we get to here, we know that duplicate X values are not permitted\n    XYDataItem overwritten = null;\n    int index = indexOf(x);\n    if (index >= 0 && !this.allowDuplicateXValues) {\n        XYDataItem existing = (XYDataItem) this.data.get(index);\n        try {\n            overwritten = (XYDataItem) existing.clone();\n        }\n        catch (CloneNotSupportedException e) {\n            throw new SeriesException(\"Couldn't clone XYDataItem!\");\n        }\n        existing.setY(y);\n    }\n    else {\n        this.data.add(new XYDataItem(x, y));\n        // check if this addition will exceed the maximum item count...\n        if (getItemCount() > this.maximumItemCount) {\n            this.data.remove(0);\n        }\n    }\n    fireSeriesChanged();\n    return overwritten;\n}", "rollout": 8}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "patch": "    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n\n        // Replacing minMiddleIndex with correct variable maxMiddleIndex\n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }", "rollout": 1}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "patch": "        this(time, TimeZone.getDefault(), Locale.getDefault());", "rollout": 2}
{"project": "Chart", "bug_id": "9", "eval": "PASS", "patch": "        if (endIndex < 0 || endIndex < startIndex) {", "rollout": 4}
{"project": "Chart", "bug_id": "10", "eval": "PASS", "patch": "        return \" title=\\\"\" + toolTipText.replace(\"\\\"\", \"&quot;\")", "rollout": 2}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "patch": "PathIterator iterator2 = p2.getPathIterator(null);", "rollout": 1}
{"project": "Chart", "bug_id": "12", "eval": "PASS", "patch": "    setDataset(dataset);", "rollout": 1}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "patch": "                    new Range(0.0, constraint.getWidth() < w[2] ? 0.0 : constraint.getWidth() - w[2]),", "rollout": 3}
{"project": "Chart", "bug_id": "17", "eval": "PASS", "patch": "        TimeSeries clone = createCopy(0, Math.max(0, getItemCount() - 1));", "rollout": 9}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "rollout": 2}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "3", "eval": "PASS", "patch": "            return org.apache.commons.lang.math.NumberUtils.createDouble(str);", "rollout": 5}
{"project": "Cli", "bug_id": "4", "eval": "PASS", "patch": "            StringBuffer buff = new StringBuffer();\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n            }\n            if (buff.length() > 1) {\n                buff.insert(0, \"Missing required options: \");\n            } else {\n                buff.insert(0, \"Missing required option: \");\n            }", "rollout": 2}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "patch": "        if (str == null) {\n            return null;\n        }", "rollout": 2}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "patch": "            pos = findWrapPos(text, width, 0);", "rollout": 3}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "patch": "    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n            // loop through the required options\n            if(iter.hasNext()){\n                buff.append(iter.next());\n                while (iter.hasNext())\n                {\n                    buff.append(\", \");\n                    buff.append(iter.next());\n                }\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }", "rollout": 1}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "patch": "        if (option.hasArg() && (!option.getArgName().isEmpty()))", "rollout": 1}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "14", "eval": "PASS", "patch": "    public void validate(final WriteableCommandLine commandLine)\n        throws OptionException {\n        // number of options found\n        int present = 0;\n\n        // reference to first unexpected option\n        Option unexpected = null;\n\n        Iterator i = options.iterator();\n        while(i.hasNext()) {\n            Option option = (Option) i.next();\n\n            // needs validation?\n            boolean validate = option.isRequired() || option instanceof Group;\n            if (validate) {\n                option.validate(commandLine);\n            }\n\n            // if the child option is present then validate it\n            if (commandLine.hasOption(option)) {\n                if (++present > maximum) {\n                    unexpected = option;\n\n                    break;\n                }\n\n                // Don't cast the return value to a String\n                // option.validate(commandLine); // Removed duplicated validation\n            }\n        }\n\n        // too many options\n        if (unexpected != null) {\n            throw new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\n                                      unexpected.getPreferredName());\n        }\n\n        // too few option\n        if (present < minimum) {\n            throw new OptionException(this, ResourceConstants.MISSING_OPTION);\n        }\n\n        // validate each anonymous argument\n        i = anonymous.iterator();\n        while(i.hasNext()) {\n            Option option = (Option) i.next();\n            option.validate(commandLine);\n        }\n    }", "rollout": 13}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "24", "eval": "PASS", "patch": "// a condition to ensure the total width is not less than the nextLineTabStop\n            if (width <= nextLineTabStop)\n            {\n                nextLineTabStop = width - 1;\n            }", "rollout": 8}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "patch": "                    continue;", "rollout": 2}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "32", "eval": "PASS", "patch": "        while ((pos > startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r'))\n        {\n            --pos;\n        }\n\n        if (pos == startPos) {\n            pos = startPos + width;\n        }", "rollout": 7}
{"project": "Cli", "bug_id": "35", "eval": "PASS", "patch": "        if (longOpts.containsKey(opt)) {\n            matchingOpts.add(opt);\n            return matchingOpts;\n        }", "rollout": 2}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "patch": "private boolean isShortOption(String token) {\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if(token.startsWith(\"-\") && token.length() >= 2) {\n        String subStr = token.substring(1);\n        int eqIdx = subStr.indexOf('=');\n        if (eqIdx != -1) {\n            subStr = subStr.substring(0, eqIdx);\n        }\n        return options.hasShortOption(subStr);\n    }\n    return false;\n}", "rollout": 14}
{"project": "Cli", "bug_id": "38", "eval": "PASS", "patch": "    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        \n        if(options.hasShortOption(optName)) {\n            return true;\n        }\n        \n        for(int i = 0; i < optName.length(); i++) {\n            if (!options.hasShortOption(String.valueOf(optName.charAt(i)))) {\n                return false;\n            }\n        }\n        return true;\n    }", "rollout": 9}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "patch": "            throw new ParseException(\"Unsupported class for createValue: \" + clazz.getName());", "rollout": 3}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "patch": "  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    if (interfaceType == null) {\n      return;\n    }\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    if (implicitProto != null) {\n      Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();\n      for (String name : currentPropertyNames) {\n        ObjectType oType = properties.get(name);\n        if (oType != null) {\n          if (!interfaceType.getPropertyType(name).isEquivalentTo(\n              oType.getPropertyType(name))) {\n            compiler.report(\n                t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                    functionName, name, oType.toString(),\n                    interfaceType.toString()));\n          }\n        }\n        currentProperties.put(name, interfaceType);\n      }\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }", "rollout": 1}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "patch": "      return mayBeStringHelper(n);", "rollout": 1}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "13", "eval": "PASS", "patch": "  private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext(); // Get the next node before traversing 'c'\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many iterations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }", "rollout": 1}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "15", "eval": "PASS", "patch": "        if (n.isExprResult() && n.getFirstChild().isDelProp()) {\n          return true;\n        }", "rollout": 1}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "patch": "if (options.dependencyOptions.needsManagement()) {", "rollout": 2}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n    case Token.THIS:\n      scope.inferSlotType(\"this\", type);\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}", "rollout": 2}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "patch": "options.skipAllPasses ||", "rollout": 8}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "patch": "    return len > 0 && !s.startsWith(\"0\") && !s.startsWith(\"0x\");", "rollout": 10}
{"project": "Closure", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "56", "eval": "PASS", "patch": "public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n      if (pos >= js.length()) {\n        return null;\n      } else {\n        return js.substring(pos);  // Change the return value here\n      }\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n}", "rollout": 6}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "patch": "          if (target != null && target.getType() == Token.STRING) { ", "rollout": 4}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "62", "eval": "PASS", "patch": "          && 0 <= charno && charno <= sourceExcerpt.length()) {", "rollout": 3}
{"project": "Closure", "bug_id": "65", "eval": "PASS", "patch": "case '\\0': sb.append(\"\\\\000\"); break;", "rollout": 3}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "patch": "            if (c >= 0x20 && c <= 0x7E) {", "rollout": 1}
{"project": "Closure", "bug_id": "77", "eval": "PASS", "patch": " case '\\0': sb.append(\"\\\\0\"); break;", "rollout": 2}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "patch": "        return false;", "rollout": 3}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "patch": "          int indexOfDot = namespace.lastIndexOf('.');", "rollout": 3}
{"project": "Closure", "bug_id": "94", "eval": "PASS", "patch": "static boolean isValidDefineValue(Node val, Set<String> defines) {\n  switch (val.getType()) {\n    case Token.STRING:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n\n    // Uniary operators are valid if the child is valid.\n    case Token.NOT:\n    case Token.NEG:\n      return isValidDefineValue(val.getFirstChild(), defines);\n\n    // Binary operators are only valid if both children are valid.\n    case Token.BITAND:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.ADD:\n    case Token.SUB:\n    case Token.MUL:\n    case Token.DIV:\n    case Token.MOD:\n      Node left = val.getFirstChild();\n      Node right = left.getNext();\n      return isValidDefineValue(left, defines) && isValidDefineValue(right, defines);\n\n    // Names are valid if and only if they are defines themselves.\n    case Token.NAME:\n    case Token.GETPROP:\n      String qualifiedName = val.getQualifiedName();\n      if (val.isQualifiedName() && qualifiedName != null) {\n        return defines.contains(qualifiedName);\n      }\n      return false;\n\n    default:\n      return false;\n  }\n}", "rollout": 11}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "104", "eval": "PASS", "patch": "      if (result != null && !result.isNoType()) {", "rollout": 1}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "107", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "119", "eval": "PASS", "patch": "        case Token.CATCH:", "rollout": 9}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "122", "eval": "PASS", "patch": "if (comment.getValue() != null && (comment.getValue().contains(\"@\"))) {", "rollout": 5}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "patch": "  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    if (node.isGetProp()) {\n      Node getPropNode = node;\n      while (getPropNode.isGetProp()) {\n        getPropNode = getPropNode.getFirstChild();\n      }\n      if (getPropNode.isName() && isNameAssignedTo(getPropNode.getString(), replacement)) {\n        return false;\n      }\n    }\n    return true;\n  }", "rollout": 7}
{"project": "Closure", "bug_id": "125", "eval": "PASS", "patch": "if (type.isConstructor()) {", "rollout": 13}
{"project": "Closure", "bug_id": "126", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "128", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "129", "eval": "PASS", "patch": "      while (first.isCast()) {\n        first = first.getFirstChild();\n      }", "rollout": 3}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "patch": "    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isLetter(s.charAt(0)) && s.charAt(0) != '_' && s.charAt(0) != '$') {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        char c = s.charAt(i);\n        if (!Character.isLetterOrDigit(c) && c != '_' && c != '$') {\n          return false;\n        }\n      }\n\n      return true;\n    }", "rollout": 2}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "152", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "patch": "      if (n.isFunction()) {", "rollout": 3}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "6", "eval": "PASS", "patch": "public int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int maxReads = 1000; // limit the number of tries to prevent infinite loop\n        while (true) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            int readLen = base64.readResults(b, offset, len);\n            if (readLen > 0) {\n                return readLen;\n            } else if (readLen == 0) {\n                if (--maxReads <= 0) {\n                    throw new IOException(\"readResults() always returns 0\");\n                }\n            } else {\n                return readLen;\n            }\n        }\n    }\n}", "rollout": 1}
{"project": "Codec", "bug_id": "7", "eval": "PASS", "patch": "        return StringUtils.newStringUtf8(encodeBase64(binaryData));", "rollout": 4}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "patch": "int len = 4 * ((binaryData.length + 2) / 3);", "rollout": 8}
{"project": "Codec", "bug_id": "10", "eval": "PASS", "patch": "txt = txt.replaceAll(\"mb(?![aeiou])(\\\\b|$)\", \"M\");", "rollout": 7}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "patch": "        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);", "rollout": 3}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "patch": "return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());", "rollout": 4}
{"project": "Collections", "bug_id": "25", "eval": "PASS", "patch": "    public static Iterator collatedIterator(Comparator comparator,\n                                           Iterator iterator1,\n                                           Iterator iterator2) {\n        if (comparator == null) {\n            comparator = ComparatorUtils.naturalComparator();\n        }\n        return new CollatingIterator(comparator, iterator1, iterator2);\n    }", "rollout": 13}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "12", "eval": "PASS", "patch": "try {\n    currEntry = new TarArchiveEntry(headerBuf);\n} catch (IllegalArgumentException e) {\n    IOException newException = new IOException(\"Invalid byte 0 at offset \" + e.getMessage());\n    newException.initCause(e);\n    throw newException;\n}", "rollout": 8}
{"project": "Compress", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "15", "eval": "PASS", "patch": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    String myName = getName();\n    String otherName = other.getName();\n    if (myName == null) {\n        if (otherName != null) {\n            return false;\n        }\n    } else if (!myName.equals(otherName)) {\n        return false;\n    }\n    String myComment = getComment();\n    String otherComment = other.getComment();\n    if (myComment == null) {\n        if (otherComment != null && !otherComment.isEmpty()) {\n            return false;\n        }\n    } else if (!myComment.equals(otherComment)) {\n        return false;\n    }\n    return getTime() == other.getTime()\n        && getInternalAttributes() == other.getInternalAttributes()\n        && getPlatform() == other.getPlatform()\n        && getExternalAttributes() == other.getExternalAttributes()\n        && getMethod() == other.getMethod()\n        && getSize() == other.getSize()\n        && getCrc() == other.getCrc()\n        && getCompressedSize() == other.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         other.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         other.getLocalFileDataExtra())\n        && gpb.equals(other.gpb);\n}", "rollout": 1}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "patch": "            if (rawCentralDirectoryData.length < expectedLength) {", "rollout": 3}
{"project": "Compress", "bug_id": "21", "eval": "PASS", "patch": "    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == -1) {\n                header.writeByte(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift < 7) {\n            header.writeByte(cache);\n        }\n    }", "rollout": 1}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "patch": "                dictSize = (coder.properties[1] & 0xff) | ((coder.properties[2] & 0xff) << 8) | ((coder.properties[3] & 0xff) << 16);", "rollout": 1}
{"project": "Compress", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "patch": "        // Buffer trimmed, check again.\n        if (start == end) {\n            return 0L; // return instead of throwing exception\n        }", "rollout": 1}
{"project": "Compress", "bug_id": "28", "eval": "PASS", "patch": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    if (offset < 0 || numToRead < 0 || numToRead > buf.length - offset) {\n        throw new IndexOutOfBoundsException();\n    }\n    if (currEntry == null) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n    if (hasHitEOF || entryOffset >= entrySize) {\n        return -1;\n    }\n    numToRead = Math.min(numToRead, available());\n\n    int totalRead = is.read(buf, offset, numToRead);\n    if (totalRead == -1) {\n        hasHitEOF = true;\n        throw new IOException(\"Truncated TAR entry\");\n    }\n    count(totalRead);\n\n    // Only increment the entryOffset if we read a positive number of bytes\n    if (totalRead > 0) {\n        entryOffset += totalRead;\n    }\n\n    return totalRead;\n}", "rollout": 4}
{"project": "Compress", "bug_id": "30", "eval": "PASS", "patch": "        if (len == 0) {\n            return 0;\n        }", "rollout": 1}
{"project": "Compress", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "patch": "    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val)); // Changed Integer.parseInt to Long.parseLong\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Long.parseLong(val)); // Changed Integer.parseInt to Long.parseLong\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        }\n    }", "rollout": 1}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "38", "eval": "PASS", "patch": "        if (getName().endsWith(\"/\") && linkFlag != LF_DIR && new File(getName()).exists() && new File(getName()).isDirectory()) {", "rollout": 11}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "patch": "    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if (checksum == null) {\n            throw new NullPointerException(\"Checksum not allowed to be null.\");\n        }\n        if (in == null) {\n            throw new NullPointerException(\"InputStream not allowed to be null.\");\n        }\n        this.checksum = checksum;\n        this.in = in;\n    }", "rollout": 1}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "patch": "    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }", "rollout": 3}
{"project": "Compress", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "1", "eval": "PASS", "patch": "        if ((current == '\\n' || current == '\\r') && lastChar != '\\r') {", "rollout": 16}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "patch": "    public String get(final String name) {\n        if (mapping == null) {\n            throw new IllegalStateException(\n                    \"No header mapping was specified, the record values can't be accessed by name\");\n        }\n        final Integer index = mapping.get(name);\n        if (index != null && index < values.length) {\n            return values[index.intValue()];\n        } else {\n            throw new IllegalArgumentException(\"No header named \" + name + \" in the record\");\n        }\n    }", "rollout": 6}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "patch": "        return this.headerMap != null ? new LinkedHashMap<String, Integer>(this.headerMap) : null;", "rollout": 2}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "patch": "    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if(recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }", "rollout": 1}
{"project": "Csv", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "10", "eval": "PASS", "patch": "if (format.getHeader() != null && format.getHeader().length > 0) {\n    printRecord(format.getHeader());\n}", "rollout": 1}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "patch": "                    final boolean emptyHeader = header == null ? true : header.trim().isEmpty();", "rollout": 2}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "patch": "                if (newRecord && (c < ' ' || c > '~')) {", "rollout": 4}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "patch": "                if (newRecord && (c == ' ' || c < '#')) {\n                    quote = true;\n                } else if (c <= ' ') {", "rollout": 2}
{"project": "Gson", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "11", "eval": "PASS", "patch": "      case STRING:", "rollout": 1}
{"project": "Gson", "bug_id": "12", "eval": "PASS", "patch": "\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      if (stackSize > 0) {\n        pathNames[stackSize - 2] = \"null\";\n      }\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n", "rollout": 4}
{"project": "Gson", "bug_id": "13", "eval": "PASS", "patch": "    if (last == NUMBER_CHAR_DIGIT && fitsInLong && !(value == 0 && negative)) {", "rollout": 5}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "16", "eval": "PASS", "patch": "\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        // cannot reduce due to infinite recursion\n        if (visitedTypeVariables.contains(typeVariable)) {\n          return typeVariable;\n        }\n        visitedTypeVariables.add(typeVariable);\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n", "rollout": 1}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "patch": "    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above MAX_SEGMENT_LEN, slow to increase by 25%\n        int newLen = (len < MAX_SEGMENT_LEN) ? Math.min(MAX_SEGMENT_LEN, len + (len >> 1)) : (len + 1);\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }", "rollout": 1}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "patch": "char c = str.charAt(i);", "rollout": 1}
{"project": "JacksonCore", "bug_id": "6", "eval": "PASS", "patch": "        if (str.charAt(0) == '0' && str.length() > 1) {\n            return -1;\n        }\n        for (int i = 0; i < len; ++i) {\n            char c = str.charAt(i);", "rollout": 6}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "patch": " if (!_hasSegments) return contentsAsArray();", "rollout": 1}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "patch": "            if (i < maxCode) {", "rollout": 1}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "PASS", "patch": "    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    AnnotatedMethod existing = mixIns.find(m);\n                    if (existing == null) {\n                        // Well, or, as per [Issue#515], multi-level merge within mixins...\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "PASS", "patch": "        return (_valueTypeDeserializer != null || _ignorableProperties != null)", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "patch": "        return (previous != ann);", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "PASS", "patch": "    public BaseSettings withDateFormat(DateFormat df) {\n        if (_dateFormat == df) {\n            return this;\n        }\n        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n                _timeZone, _defaultBase64);\n    }", "rollout": 7}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "patch": "                if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "rollout": 5}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "PASS", "patch": "        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            else if (p.getCurrentToken() == JsonToken.END_OBJECT) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            else if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n        }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "PASS", "patch": "            // As per [databind#1123], Locale too\n            if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n            }", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "PASS", "patch": "        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), ", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "PASS", "patch": "    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        boolean orig = ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS);\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n            boolean shouldOverride = !(mutator.getRawType().equals(Throwable.class) && mutator.getName().equals(\"cause\"));\n            if (shouldOverride) {\n                mutator.fixAccess(orig);\n            }\n        }\n\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "patch": "                found = key != null && key.equals(getPropertyName(prop));", "rollout": 4}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "PASS", "patch": "                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    continue;\n                }", "rollout": 5}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "PASS", "patch": "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    String text = p.getValueAsString();\n    if (text != null) { \n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            return _deserializeFromEmptyString();\n        }\n        \n        try {\n            return _deserialize(text, ctxt);\n        } catch (Exception e) {\n            JsonMappingException ex = ctxt.weirdStringException(text, _valueClass, \"not a valid textual representation, problem: \"+e.getMessage());\n            throw ex;\n        }\n    }\n    JsonToken t = p.getCurrentToken();\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}", "rollout": 4}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "PASS", "patch": "    protected JavaType _typeFromId(String id, DatabindContext ctxt) throws IOException\n    {\n        TypeFactory tf = ctxt.getTypeFactory();\n        if (id.indexOf('<') > 0) {\n            JavaType t = tf.constructFromCanonical(id);\n            // check assignment compatibility with _baseType\n            if (!_baseType.getRawClass().isAssignableFrom(t.getRawClass())) {\n                throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'), not subtype of \"+_baseType);\n            }\n            return t;\n        }\n        Class<?> cls;\n        try {\n            cls =  tf.findClass(id);\n        } catch (ClassNotFoundException e) {\n            if (ctxt instanceof DeserializationContext) {\n                DeserializationContext dctxt = (DeserializationContext) ctxt;\n                return dctxt.handleUnknownTypeId(_baseType, id, this, \"no such class found\");\n            }\n            // ... meaning that we really should never get here.\n            return null;\n        } \n        JavaType type = tf.constructSpecializedType(_baseType, cls);\n        if (!_baseType.getRawClass().isAssignableFrom(type.getRawClass())) {\n            throw new IllegalArgumentException(\"Invalid type id '\"+id+\"' (for id type 'Id.class'), not subtype of \"+_baseType);\n        }\n        return type;\n    }", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "PASS", "patch": "    private final static Class[] INIT_CAUSE_PARAMS = new Class[] { Throwable.class };\n\n    private final static Class[] NO_VIEWS = new Class[0];\n\n    /**\n     * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n     * and should (and is) prevented by default.\n     *\n     * @since 2.8.9\n     */\n    protected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\n    static {\n        Set<String> s = new HashSet<String>();\n        \n        // Add the \"nasty classes\" identified by the test cases\n        s.add(\"java.util.logging.FileHandler\");\n        s.add(\"java.rmi.server.UnicastRemoteObject\");\n        s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n        s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n        s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n        s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n        s.add(\"org.springframework.beans.factory.ObjectFactory\");\n        s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n        s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n        s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n        s.add(\"com.mchange.v2.c3p0.JndiRefForwardingDataSource\");\n        s.add(\"com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\");\n\n        DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n    }", "rollout": 15}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "PASS", "patch": "private boolean _hasCustomHandlers(JavaType t) {\n    if (t.isContainerType()) {\n        // First: value types may have both value and type handlers\n        JavaType ct = t.getContentType();\n        if (ct != null) {\n            if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                return true;\n            }\n        }\n        // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n        if (t.isMapLikeType()) {\n            JavaType keyType = t.getKeyType();\n            if (keyType != null && keyType.getValueHandler() != null) {\n                return true;\n            }\n        }\n    }\n    return false;\n}", "rollout": 6}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "patch": "            paramName = candidate.paramName(0);", "rollout": 5}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "PASS", "patch": "if (property != null) {\n    //...\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "5", "eval": "PASS", "patch": "        if(!tq.matchesWhitespace() && !tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty())\n            tq.consume();", "rollout": 5}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "10", "eval": "PASS", "patch": "                if (relUrl.startsWith(\"?\")) {\n                    // append the query string to the current url\n                    String currentPath = base.getPath();\n                    if (currentPath.endsWith(\"/\")) {\n                        currentPath = currentPath.substring(0, currentPath.length() - 1);\n                    }\n                    base = new URL(base.getProtocol(), base.getHost(), base.getPort(), currentPath + relUrl);\n                    return base.toExternalForm();\n                }", "rollout": 3}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "patch": "            if (docData.length() > 0 && docData.charAt(0) == '\\uFEFF') {\n                docData = docData.substring(1);\n            }", "rollout": 1}
{"project": "Jsoup", "bug_id": "24", "eval": "PASS", "patch": "r. consumeLetterSequence();", "rollout": 4}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "patch": "private static final String[] preserveWhitespaceTags = { \"pre\", \"plaintext\", \"title\", \"textarea\" }; ", "rollout": 3}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "patch": "            if (offset + seq.length() <= length) {", "rollout": 2}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "patch": "doc = parser.parseInput(docData, baseUri);", "rollout": 1}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "patch": "        super.attr(\"name\", name);", "rollout": 1}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "patch": "        return this.outerHtml().equals(((Element)o).outerHtml());", "rollout": 1}
{"project": "Jsoup", "bug_id": "42", "eval": "PASS", "patch": "    public List<Connection.KeyVal> formData() {\n        ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n        // iterate the form control elements and accumulate their values\n        for (Element el: elements) {\n            if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n            String name = el.attr(\"name\");\n            if (name.length() == 0 || el.hasAttr(\"disabled\")) continue; // ignore elements with no name or that are disabled\n            String type = el.attr(\"type\");\n\n            if (\"select\".equals(el.tagName())) {\n                Elements options = el.select(\"option[selected]\");\n                boolean set = false;\n                for (Element option: options) {\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n                    set = true;\n                }\n                if (!set) {\n                    Element option = el.select(\"option\").first();\n                    if (option != null)\n                        data.add(HttpConnection.KeyVal.create(name, option.val()));\n                }\n            } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n                // only add checkbox or radio if they have the checked attribute\n                if (el.hasAttr(\"checked\")) {\n                    final String val = el.hasAttr(\"value\") ? el.val() : \"on\";\n                    data.add(HttpConnection.KeyVal.create(name, val));\n                }\n            } else {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n        return data;\n    }", "rollout": 3}
{"project": "Jsoup", "bug_id": "43", "eval": "PASS", "patch": "            if (element == search)", "rollout": 1}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "patch": "            } else if (\"td\".equals(name) || \"th\".equals(name) && !last) {", "rollout": 1}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "patch": "                            accum.append(\"&nbsp;\");", "rollout": 1}
{"project": "Jsoup", "bug_id": "47", "eval": "PASS", "patch": "            if (!inAttribute || (inAttribute && escapeMode == EscapeMode.xhtml))", "rollout": 12}
{"project": "Jsoup", "bug_id": "48", "eval": "PASS", "patch": "        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    StringBuilder sb = new StringBuilder();\n                    for (String value : values) {\n                        if (value != null) {\n                            sb.append(value);\n                            sb.append(\", \");\n                        }\n                    }\n                    if (sb.length() > 0) {\n                        sb.setLength(sb.length() - 2); // remove last comma and space\n                        header(name, sb.toString());\n                    }\n                }\n            }\n        }", "rollout": 1}
{"project": "Jsoup", "bug_id": "49", "eval": "PASS", "patch": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    for (int i = 0; i < children.length; i++) {\n        Node in = children[i];\n        reparentChild(in);\n        childNodes.add(index + i, in);\n        // We move the reindexChildren into the loop:\n        reindexChildren(index + i);\n    }\n}", "rollout": 12}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "55", "eval": "PASS", "patch": "                    r.unconsume();", "rollout": 3}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "patch": "                it.remove();", "rollout": 2}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "patch": "        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if(!pendingAttributeName.isEmpty()){\n                    Attribute attribute;\n                    if (hasPendingAttributeValue)\n                        attribute = new Attribute(pendingAttributeName,\n                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                    else if (hasEmptyAttributeValue)\n                        attribute = new Attribute(pendingAttributeName, \"\");\n                    else\n                        attribute = new BooleanAttribute(pendingAttributeName);\n                    attributes.put(attribute);\n                }\n                pendingAttributeName = null;\n                hasEmptyAttributeValue = false;\n                hasPendingAttributeValue = false;\n                reset(pendingAttributeValue);\n                pendingAttributeValueS = null;\n            }\n        }", "rollout": 2}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "68", "eval": "PASS", "patch": "        int bottom = stack.size() -1;", "rollout": 2}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "patch": "static boolean preserveWhitespace(Node node) {\n    if (node != null && node instanceof Element) {\n        Element el = (Element) node;\n        if (el.tag.preserveWhitespace()) {\n            return true;\n        } else {\n            for(int i=0; i<5; i++) {\n                el = el.parent();\n                if (el == null) break;\n                if (el.tag.preserveWhitespace()) return true;\n            }\n        }\n    }\n    return false;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "72", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "77", "eval": "PASS", "patch": "        String elName = endTag.name().toLowerCase();", "rollout": 5}
{"project": "Jsoup", "bug_id": "80", "eval": "PASS", "patch": "    void insert(Token.Comment commentToken) {\n        Comment comment = new Comment(commentToken.getData());\n        Node insert = comment;\n        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n            String data = comment.getData();\n            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n                // Check if doc has child(0)\n                if (doc != null && !doc.children().isEmpty()) {\n                    Element el = doc.child(0);\n                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                    insert.attributes().addAll(el.attributes());\n                }\n            }\n        }\n        insertNode(insert);\n    }", "rollout": 1}
{"project": "Jsoup", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "patch": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    this.key = key.trim();\n    Validate.notEmpty(this.key); // trimming could potentially make empty, so validate here\n    this.val = val;\n    this.parent = parent;\n}", "rollout": 3}
{"project": "Jsoup", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "patch": "public String setValue(String val) {\n    String oldVal = this.val;\n    this.val = val;\n    \n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.vals[i] = val;\n    }\n    \n    return Attributes.checkNotNull(oldVal);\n}", "rollout": 2}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "patch": "if (end > input.length) {\n    return false;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "5", "eval": "PASS", "patch": "        if (depth1 == 1) {\n            if (p1 != null && !p1.equals(p2)) {\n                return p1.compareTo(p2);\n            }\n        }", "rollout": 1}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "8", "eval": "PASS", "patch": "    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n        \n        if (Double.isNaN(ld) || Double.isNaN(rd)) {\n            // handle NaN cases\n            if (Double.isNaN(ld) && Double.isNaN(rd)) {\n                return evaluateCompare(0); // NaN equals to NaN\n            } else {\n                return false; // NaN is not greater than or less than any number\n            }\n        }\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }", "rollout": 8}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "patch": "    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1.length() != cs2.length()) {\n            return false;\n        }\n        for (int i = 0; i < cs1.length(); i++) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }", "rollout": 1}
{"project": "Lang", "bug_id": "16", "eval": "PASS", "patch": "        if ( str.toLowerCase().startsWith(\"0x\") || str.toLowerCase().startsWith(\"-0x\") ) {", "rollout": 3}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "rollout": 3}
{"project": "Lang", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "28", "eval": "PASS", "patch": "    public int translate(CharSequence input, int index, Writer out) throws IOException {\n        // Check if sequence length is long enough\n        if (index + 2 >= input.length()) {\n            return 0;\n        }\n\n        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n            int start = index + 2;\n            boolean isHex = false;\n\n            // Check if sequence length is long enough\n            if(start >= input.length()) {\n                return 0;\n            }\n\n            char firstChar = input.charAt(start);\n            if(firstChar == 'x' || firstChar == 'X') {\n                start++;\n                isHex = true;\n            }\n\n            int end = start;\n            // Check if sequence length is long enough\n            if(end >= input.length()) {\n                return 0;\n            }\n\n            while(input.charAt(end) != ';') {\n                end++;\n                // Check if sequence length is long enough\n                if(end >= input.length()) {\n                    return 0;\n                }\n            }\n\n            int entityValue;\n            try {\n                if(isHex) {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n                } else {\n                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n                }\n            } catch(NumberFormatException nfe) {\n                return 0;\n            }\n\n            if (entityValue > Character.MAX_VALUE) {\n                char[] chars = Character.toChars(entityValue);\n                out.write(chars);\n                return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n            }\n            out.write(entityValue);\n            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n        }\n        return 0;\n    }", "rollout": 4}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "patch": "            classes[i] = (array[i] != null) ? array[i].getClass() : null;", "rollout": 2}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "patch": "public static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    Class<?> type1 = array1.getClass().getComponentType();\n    Class<?> type2 = array2.getClass().getComponentType();\n    if (!type1.isAssignableFrom(type2) && !type2.isAssignableFrom(type1)) {\n        throw new IllegalArgumentException(\"Array types are not compatible\");\n    }\n    @SuppressWarnings(\"unchecked\")\n    T[] joinedArray = (T[]) Array.newInstance(type1.isAssignableFrom(type2) ? type1 : type2, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    return joinedArray;\n}", "rollout": 7}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "39", "eval": "PASS", "patch": "            if (searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) {\n                noMoreMatchesForReplIndex[i] = true;\n                continue;\n            }", "rollout": 3}
{"project": "Lang", "bug_id": "40", "eval": "PASS", "patch": "        for (int i = 0; i <= str.length() - searchStr.length(); i++) {\n            boolean match = true;\n            for (int j = 0; j < searchStr.length() && (i + j) < str.length(); j++) {\n                if (Character.toUpperCase(str.charAt(i + j)) != Character.toUpperCase(searchStr.charAt(j))) {\n                    match = false;\n                    break;\n                }\n            }\n            if (match) {\n                return true;\n            }\n        }\n        return false;", "rollout": 4}
{"project": "Lang", "bug_id": "42", "eval": "PASS", "patch": "    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        char[] cbuf = new char[2];\n        for (int i = 0; i < len; ) {\n            int cp = str.codePointAt(i);\n            Character.toChars(cp, cbuf, 0);\n            char c = cbuf[0];\n            String entityName = this.entityName(cp);\n            if (entityName == null) {\n                if (cp > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(cp, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n            i += Character.charCount(cp);\n        }\n    }", "rollout": 2}
{"project": "Lang", "bug_id": "43", "eval": "PASS", "patch": "pos.setIndex(pos.getIndex() + 1);", "rollout": 5}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "patch": "        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n        // if the lower value is less than 0, set to 0\n        if (lower < 0) {\n            lower = 0;\n        }", "rollout": 3}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "patch": "                return false;", "rollout": 1}
{"project": "Lang", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "patch": "    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n        if(this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n        }\n        this.runningState = STATE_STOPPED;\n    }", "rollout": 4}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "patch": "        return LocaleUtils.availableLocaleSet().contains(locale);", "rollout": 12}
{"project": "Lang", "bug_id": "58", "eval": "PASS", "patch": "                        && (numeric.charAt(0) != '-' || isDigits(numeric.substring(1)))\n                    ) {", "rollout": 14}
{"project": "Lang", "bug_id": "59", "eval": "PASS", "patch": "                str.getChars(0, Math.min(strLen, width), buffer, size);", "rollout": 1}
{"project": "Lang", "bug_id": "61", "eval": "PASS", "patch": "        int len = size - strLen + 1;", "rollout": 9}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "2", "eval": "PASS", "patch": "return Math.max((double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(), 0.0);", "rollout": 3}
{"project": "Math", "bug_id": "3", "eval": "PASS", "patch": "public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                aHigh * bHigh) -\n                                               aLow * bHigh) -\n                                              aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n    double result = 0;\n    if(len > 0) {\n        final double prodHighCur = prodHigh[0];\n        double prodHighNext;\n        if(len > 1) {\n            prodHighNext = prodHigh[1];\n        } else {\n            prodHighNext = 0;\n        }\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            if(i+1 < len) {\n                prodHighNext = prodHigh[i + 1];\n            } else {\n                prodHighNext = 0;\n            }\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        result = sHighPrev + (prodLowSum + sLowSum);\n    }\n\n    if (Double.isNaN(result)) {\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}", "rollout": 4}
{"project": "Math", "bug_id": "5", "eval": "PASS", "patch": "            return Complex.INF;", "rollout": 2}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "17", "eval": "PASS", "patch": "    public Dfp multiply(final int x) {\n        return multiply(new Dfp(field, x));\n    }", "rollout": 1}
{"project": "Math", "bug_id": "19", "eval": "PASS", "patch": "\n        if (boundaries != null) {\n            for (int i = 0; i < lB.length; i++) {\n                if (boundaries[1][i] - boundaries[0][i] > Double.MAX_VALUE) {\n                    throw new NumberIsTooLargeException(boundaries[1][i] - boundaries[0][i], Double.MAX_VALUE, true);\n                }\n            }\n        }\n", "rollout": 3}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "26", "eval": "PASS", "patch": "    private Fraction(double value, double epsilon, int maxDenominator, int maxIterations)\n        throws FractionConversionException\n    {\n        long overflow = Integer.MAX_VALUE;\n        double r0 = value;\n        long a0 = (long)FastMath.floor(r0);\n        if (a0 > overflow || a0 < Integer.MIN_VALUE) {\n            throw new FractionConversionException(value, a0, 1l);\n        }\n\n        // check for (almost) integer arguments, which should not go\n        // to iterations.\n        if (FastMath.abs(a0 - value) < epsilon) {\n            this.numerator = (int) a0;\n            this.denominator = 1;\n            return;\n        }\n\n        long p0 = 1;\n        long q0 = 0;\n        long p1 = a0;\n        long q1 = 1;\n\n        long p2 = 0;\n        long q2 = 1;\n\n        int n = 0;\n        boolean stop = false;\n        do {\n            ++n;\n            double r1 = 1.0 / (r0 - a0);\n            long a1 = (long)FastMath.floor(r1);\n\n            if ((a1 * p1) + p0 > overflow || (a1 * p1) + p0 < Integer.MIN_VALUE) {\n                throw new FractionConversionException(value, (a1 * p1) + p0, 1l);\n            }\n            if ((a1 * q1) + q0 > overflow || (a1 * q1) + q0 < Integer.MIN_VALUE) {\n                throw new FractionConversionException(value, a1, (a1 * q1) + q0);\n            }\n\n            p2 = (a1 * p1) + p0;\n            q2 = (a1 * q1) + q0;\n            if (p2 > overflow || p2 < Integer.MIN_VALUE || q2 > overflow || q2 < Integer.MIN_VALUE) {\n                throw new FractionConversionException(value, p2, q2);\n            }\n\n            double convergent = (double)p2 / (double)q2;\n            if (n < maxIterations && FastMath.abs(convergent - value) > epsilon && q2 < maxDenominator) {\n                p0 = p1;\n                p1 = p2;\n                q0 = q1;\n                q1 = q2;\n                a0 = a1;\n                r0 = r1;\n            } else {\n                stop = true;\n            }\n        } while (!stop);\n\n        if (n >= maxIterations) {\n            throw new FractionConversionException(value, maxIterations);\n        }\n\n        if (q2 < maxDenominator) {\n            this.numerator = (int) p2;\n            this.denominator = (int) q2;\n        } else {\n            this.numerator = (int) p1;\n            this.denominator = (int) q1;\n        }\n\n    }", "rollout": 9}
{"project": "Math", "bug_id": "27", "eval": "PASS", "patch": "        return ((double) numerator) / denominator * 100;", "rollout": 1}
{"project": "Math", "bug_id": "28", "eval": "PASS", "patch": "private int getPivotRow(SimplexTableau tableau, final int col) {\n    int minRatioRow = -1;\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            final double ratio = rhs / entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp <= 0) {\n                minRatio = ratio;\n                minRatioRow = i;\n            }\n        }\n    }\n\n    if (minRatioRow < 0) {\n        throw new UnboundedSolutionException(); // throw exception if no pivot row found\n    }\n\n    // checks for potential cycling and artificial variables aren't provided in this example\n\n    return minRatioRow;\n}", "rollout": 16}
{"project": "Math", "bug_id": "30", "eval": "PASS", "patch": "        long n1n2prod = n1 * n2;", "rollout": 7}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "32", "eval": "PASS", "patch": "            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {", "rollout": 1}
{"project": "Math", "bug_id": "33", "eval": "PASS", "patch": "            if (Precision.compareTo(entry, 0d, 1e-15) > 0) {", "rollout": 7}
{"project": "Math", "bug_id": "34", "eval": "PASS", "patch": "        return Collections.unmodifiableCollection(chromosomes).iterator();", "rollout": 2}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "41", "eval": "PASS", "patch": "                for (int i = begin; i < begin + length; i++) {", "rollout": 1}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "50", "eval": "PASS", "patch": "                    if (x == x1) {\n                        x0 = x1 - FastMath.max(rtol * FastMath.abs(x1), atol);\n                        f0 = computeObjectiveValue(x0);\n                    }", "rollout": 1}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "53", "eval": "PASS", "patch": "if (Double.isNaN(real) || Double.isNaN(rhs.getReal()) || Double.isNaN(imaginary) || Double.isNaN(rhs.getImaginary())) {\n    return Complex.NaN;\n}", "rollout": 1}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "57", "eval": "PASS", "patch": "            double sum = 0;", "rollout": 2}
{"project": "Math", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "59", "eval": "PASS", "patch": "return Math.max(a, b);", "rollout": 4}
{"project": "Math", "bug_id": "60", "eval": "PASS", "patch": "public double cumulativeProbability(double x) throws MathException {\n    if (standardDeviation <= 0) {\n        throw new MathException(\"Standard deviation must be positive\");\n    }\n    final double dev = x - mean;\n    if (Math.abs(dev) > 20 * standardDeviation) {\n        if (dev < 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    } else {\n        try {\n            if (x == Double.POSITIVE_INFINITY) {\n                return 1.0;\n            } else if (x == Double.NEGATIVE_INFINITY) {\n                return 0.0;\n            } else {\n                return 0.5 * (1.0 + Erf.erf((dev) /\n                    (standardDeviation * FastMath.sqrt(2.0))));\n            }\n        } catch (MaxIterationsExceededException ex) {\n            if (x < (mean - 20 * standardDeviation)) { \n                return 0;\n            } else if (x > (mean + 20 * standardDeviation)) {\n                return 1;\n            } else {\n                throw ex;\n            }\n        }\n    }\n}", "rollout": 12}
{"project": "Math", "bug_id": "63", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "72", "eval": "PASS", "patch": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n    }", "rollout": 3}
{"project": "Math", "bug_id": "73", "eval": "PASS", "patch": "        if (yInitial * yMax > 0) {\n            throw new IllegalArgumentException(\"Initial guess does not bracket the root\");\n        }", "rollout": 1}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "79", "eval": "PASS", "patch": "    public static double distance(int[] p1, int[] p2) {\n      double sum = 0;\n      for (int i = 0; i < p1.length && i < p2.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }", "rollout": 1}
{"project": "Math", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "82", "eval": "PASS", "patch": "            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {", "rollout": 2}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "85", "eval": "PASS", "patch": "if (fa * fb > 0.0) {", "rollout": 1}
{"project": "Math", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "89", "eval": "PASS", "patch": "public void addValue(Object v) {\n    if (v instanceof Comparable) {\n        addValue((Comparable<?>) v);\n    } else {\n        throw new IllegalArgumentException(\"Object is not Comparable\");\n    }\n}", "rollout": 1}
{"project": "Math", "bug_id": "91", "eval": "PASS", "patch": "        int nOd = numerator * object.denominator;\n        int dOn = object.numerator * denominator;", "rollout": 1}
{"project": "Math", "bug_id": "94", "eval": "PASS", "patch": "        if (u == 0 || v == 0) {", "rollout": 1}
{"project": "Math", "bug_id": "95", "eval": "PASS", "patch": "    protected double getInitialDomain(double p) {\n        double ret; // initialize ret to a valid value\n        double d = getDenominatorDegreesOfFreedom();\n        // use mean\n        ret = (d / 2.0) + 1.0;\n        return ret;\n    }", "rollout": 4}
{"project": "Math", "bug_id": "96", "eval": "PASS", "patch": "                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());", "rollout": 2}
{"project": "Math", "bug_id": "97", "eval": "PASS", "patch": "public double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n    \n    clearResult();\n    verifyInterval(min, max);\n    \n    double ret = Double.NaN;\n    \n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    \n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign > 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= getAbsoluteAccuracy()){\n            return min;\n        }\n        if (Math.abs(yMax) <= getAbsoluteAccuracy()){\n            return max;\n        }\n        // neither value is close to zero and min and max do not bracket root.\n        throw new IllegalArgumentException\n        (\"Function values at endpoints do not have different signs.\" +\n                \"  Endpoints: [\" + min + \",\" + max + \"]\" +\n                \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else if (sign < 0) {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    } else {\n        // one of the values is zero\n        if (yMin == 0){\n            return min;\n        } else {\n            return max;\n        }\n    }\n\n    return ret;\n}", "rollout": 2}
{"project": "Math", "bug_id": "101", "eval": "PASS", "patch": "        if (endIndex > source.length() ||", "rollout": 1}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "103", "eval": "PASS", "patch": "    public double cumulativeProbability(double x) throws MathException {\n        double y = (x - mean) / (standardDeviation * Math.sqrt(2.0));\n        if (y < -20) {  // check if extremely negative\n            return 0;  // return 0 instead of a very small value\n        } \n        else if (y > 20) { // check if extremely positive, add this condition\n            return 1; // return 1 instead of a very large value\n        }\n        else {\n            return 0.5 * (1.0 + Erf.erf(y));\n        }\n    }", "rollout": 10}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "5", "eval": "PASS", "patch": "            catch (AssertionError e) {", "rollout": 5}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "12", "eval": "PASS", "patch": "    public Class getGenericType(Field field) {        \n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n                if (actual instanceof Class) \n                    return (Class) actual;\n                else if (actual instanceof ParameterizedType)\n                    return (Class) ((ParameterizedType) actual).getRawType();\n                \n                //in case of nested generics we don't go deep\n        }\n        \n        return Object.class;\n    }", "rollout": 1}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "patch": "primitiveValues.put(double.class, 0.0);", "rollout": 1}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "29", "eval": "PASS", "patch": "        description.appendText(String.valueOf(wanted));", "rollout": 16}
{"project": "Mockito", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "patch": "            if (m instanceof CapturesArguments && k < i.getArguments().length) {", "rollout": 2}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "patch": "        return arg == null ? StringDescription.toString(m).equals(\"null\") : StringDescription.toString(m).equals(arg.toString());", "rollout": 2}
{"project": "Time", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "18", "eval": "PASS", "patch": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // First, check if this might be a valid date in the Julian calendar\n        if (iJulianChronology.isLeapYear(year) && monthOfYear == 2 && dayOfMonth == 29) {\n            long instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            // If the instant is less than the cutover, then we have a Julian date.\n            if (instant < iCutoverMillis) {\n                return instant;\n            }\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n        // If the instant is less than the cutover, then we have a Julian date.\n        if (instant < iCutoverMillis) {\n            instant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n            if (instant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n        }\n        return instant;\n    }", "rollout": 7}
{"project": "Time", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "20", "eval": "PASS", "patch": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n    String str = text.substring(position);\n    for (String id : ALL_IDS) {\n        // Avoid partial matching of timezone IDs by ensuring we're parsing complete IDs\n        if (str.startsWith(id) && (id.endsWith(\"/\") || str.length() == id.length() || str.charAt(id.length()) == '/')) {\n            bucket.setZone(DateTimeZone.forID(id));\n            return position + id.length();\n        }\n    }\n    return ~position;\n}", "rollout": 3}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "23", "eval": "PASS", "patch": "    private static synchronized String getConvertedId(String id) {\n        Map<String, String> map = cZoneIdConversion;\n        if (map == null) {\n            // Backwards compatibility with TimeZone.\n            map = new HashMap<String, String>();\n            map.put(\"GMT\", \"UTC\");\n            map.put(\"WET\", \"WET\");\n            map.put(\"CET\", \"CET\");\n            map.put(\"MET\", \"CET\");\n            map.put(\"ECT\", \"CET\");\n            map.put(\"EET\", \"EET\");\n            map.put(\"MIT\", \"Pacific/Apia\");\n            map.put(\"HST\", \"Pacific/Honolulu\");\n            map.put(\"AST\", \"America/Anchorage\");\n            map.put(\"PST\", \"America/Los_Angeles\");\n            map.put(\"MST\", \"America/Denver\");\n            map.put(\"PNT\", \"America/Phoenix\");\n            map.put(\"CST\", \"America/Chicago\");\n            map.put(\"EST\", \"America/New_York\");\n            map.put(\"IET\", \"America/Indiana/Indianapolis\");\n            map.put(\"PRT\", \"America/Puerto_Rico\");\n            map.put(\"CNT\", \"America/St_Johns\");\n            map.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n            map.put(\"BET\", \"America/Sao_Paulo\");\n            map.put(\"ART\", \"Africa/Cairo\");\n            map.put(\"CAT\", \"Africa/Harare\");\n            map.put(\"EAT\", \"Africa/Addis_Ababa\");\n            map.put(\"NET\", \"Asia/Yerevan\");\n            map.put(\"PLT\", \"Asia/Karachi\");\n            map.put(\"IST\", \"Asia/Kolkata\");\n            map.put(\"BST\", \"Asia/Dhaka\");\n            map.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n            map.put(\"CTT\", \"Asia/Shanghai\");\n            map.put(\"JST\", \"Asia/Tokyo\");\n            map.put(\"ACT\", \"Australia/Darwin\");\n            map.put(\"AET\", \"Australia/Sydney\");\n            map.put(\"SST\", \"Pacific/Guadalcanal\");\n            map.put(\"NST\", \"Pacific/Auckland\");\n            cZoneIdConversion = map;\n        }\n        return map.get(id);\n    }", "rollout": 3}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
