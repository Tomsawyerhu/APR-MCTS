{"project": "Chart", "bug_id": "1", "eval": "PASS", "patch": "if (dataset == null) {", "rollout": 1}
{"project": "Chart", "bug_id": "3", "eval": "PASS", "patch": "// Initialize minY and maxY properties of the copied time series\ncopy.minY = Double.POSITIVE_INFINITY;\ncopy.maxY = Double.NEGATIVE_INFINITY;\n\nif (this.data.size() > 0) {\n    for (int index = start; index <= end; index++) {\n        TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index);\n        TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone();\n        try {\n            copy.add(clone);\n        } catch (SeriesException e) {\n            e.printStackTrace();\n        }\n\n        // Update minY and maxY\n        double yValue = clone.getValue().doubleValue();\n        if (yValue < copy.minY) {\n            copy.minY = yValue;\n        }\n        if (yValue > copy.maxY) {\n            copy.maxY = yValue;\n        }\n    }\n}", "rollout": 3}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "patch": "public Range getDataRange(ValueAxis axis) {\n\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false; // Only set to false if it's a range axis\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (isDomainAxis) {\n                if (r != null) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                } else {\n                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\n                }\n            } else {\n                if (r != null) {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                } else {\n                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\n                }\n            }\n\n            // Add annotations only if it's a domain or range axis\n            Collection c = r == null ? Collections.EMPTY_LIST : r.getAnnotations();\n            Iterator i = c.iterator();\n            while (i.hasNext()) {\n                XYAnnotation a = (XYAnnotation) i.next();\n                if (a instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(a);\n                }\n            }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            } else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n\n}", "rollout": 2}
{"project": "Chart", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "patch": "private void updateBounds(TimePeriod period, int index) {\n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) {\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) {\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n}", "rollout": 1}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "patch": "        this(time, zone, Locale.getDefault());", "rollout": 1}
{"project": "Chart", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "10", "eval": "PASS", "patch": "        return \" title=\\\"\" + toolTipText.replace(\"\\\"\", \"&quot;\")", "rollout": 1}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "patch": "PathIterator iterator2 = p2.getPathIterator(null);", "rollout": 1}
{"project": "Chart", "bug_id": "12", "eval": "PASS", "patch": "this.setDataset(dataset);", "rollout": 3}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "patch": "                    new Range(0.0, constraint.getWidth()),", "rollout": 1}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "rollout": 1}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "26", "eval": "PASS", "patch": "protected AxisState drawLabel(String label, Graphics2D g2, \n        Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n        AxisState state, PlotRenderingInfo plotState) {\n\n    // it is unlikely that 'state' will be null, but check anyway...\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    \n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    \n    if (edge == RectangleEdge.TOP) {\n        // ... (rest of the TOP code remains the same)\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        // ... (rest of the BOTTOM code remains the same)\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        // ... (rest of the LEFT code remains the same)\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n        // ... (rest of the RIGHT code remains the same)\n    }\n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n            EntityCollection entities = owner.getEntityCollection();\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, \n                        this.labelToolTip, this.labelURL));\n            }\n    }\n    return state;\n\n}", "rollout": 1}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "3", "eval": "PASS", "patch": "return Double.parseDouble(str);", "rollout": 4}
{"project": "Cli", "bug_id": "4", "eval": "PASS", "patch": "StringBuffer buff = new StringBuffer(requiredOptions.size() == 1 ? \"Missing required option: \" : \"Missing required options: \");", "rollout": 9}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "patch": "if (str == null) {\n    return null;\n}", "rollout": 1}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "patch": "pos = findWrapPos(text, width, 0);", "rollout": 3}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "patch": "protected void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processed\n    if (getRequiredOptions().size() > 0)\n    {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n        // loop through the required options\n        int i = 0;\n        while (iter.hasNext())\n        {\n            i++;\n            buff.append(iter.next());\n            if (i < getRequiredOptions().size())\n            {\n                buff.append(\", \");\n            }\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}", "rollout": 1}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "patch": "if (option.hasArg() && (option.getArgName() != null && !option.getArgName().isEmpty()))", "rollout": 1}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "24", "eval": "PASS", "patch": "        if (nextLineTabStop >= width) {\n            nextLineTabStop = width - 1;\n        }", "rollout": 3}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "patch": "continue;", "rollout": 2}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "32", "eval": "PASS", "patch": "        if (pos < startPos) {\n            pos = startPos;\n        } else if (pos >= text.length()) {\n            pos = -1;\n        }", "rollout": 11}
{"project": "Cli", "bug_id": "35", "eval": "PASS", "patch": "if (longOpts.containsKey(opt)) {\n    matchingOpts.add(opt);\n    return matchingOpts; // Return immediately after finding an exact match\n}", "rollout": 1}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "patch": "private boolean isShortOption(String token)\n{\n    // Check if the token starts with a hyphen and has a length of at least 2\n    if (!token.startsWith(\"-\") || token.length() < 2) {\n        return false;\n    }\n\n    // Remove the leading hyphen\n    String shortOption = token.substring(1);\n\n    // Check if the remaining part is a valid short option\n    return options.hasShortOption(shortOption);\n}", "rollout": 1}
{"project": "Cli", "bug_id": "38", "eval": "PASS", "patch": "private boolean isShortOption(String token) {\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    if (!token.startsWith(\"-\") || token.length() == 1) {\n        return false;\n    }\n\n    // remove leading \"-\" and \"=value\"\n    int pos = token.indexOf(\"=\");\n    String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n\n    // check if the option name starts with another option name\n    if (optName.length() > 1 && options.hasShortOption(optName.substring(0, 1))) {\n        // it's a concatenated short option, treat each option separately\n        for (int i = 1; i < optName.length(); i++) {\n            if (!options.hasShortOption(optName.substring(i, i + 1))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    return options.hasShortOption(optName);\n}", "rollout": 1}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "patch": "            throw new ParseException(\"Unsupported type: \" + clazz.getName());", "rollout": 1}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "patch": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n    String functionName, HashMap<String, ObjectType> properties,\n    HashMap<String, ObjectType> currentProperties,\n    ObjectType interfaceType) {\n  ObjectType implicitProto = interfaceType.getImplicitPrototype();\n  Set<String> currentPropertyNames = null;\n  // This can be the case if interfaceType is proxy to a non-existent\n  // object (which is a bad type annotation, but shouldn't crash).\n  if (implicitProto != null) {\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n  }\n  if (currentPropertyNames != null) {\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n  }\n  for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n    checkInterfaceConflictProperties(t, n, functionName, properties,\n        currentProperties, iType);\n  }\n}", "rollout": 1}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "5", "eval": "PASS", "patch": "if (gramps.isDelProp() && gramps.getFirstChild() == parent) {\n  // If the property is being deleted, we should not allow inlining.\n  return false;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "7", "eval": "PASS", "patch": "public JSType caseObjectType(ObjectType type) {\n  if (value.equals(\"function\")) {\n    JSType ctorType = getNativeType(U2U_CONSTRUCTOR_TYPE);\n    return resultEqualsValue && ctorType.isSubtype(type) ? ctorType : type;\n    // Objects are restricted to \"Function\", subtypes are left\n    // Only filter out subtypes of \"function\"\n  }\n  return matchesExpectation(\"object\") ? type : null;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "patch": "      return mayBeStringHelper(n);", "rollout": 1}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "patch": "if (options.dependencyOptions.needsManagement()) {", "rollout": 1}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      Preconditions.checkNotNull(qualifiedName);\n\n      JSType origType = node.getJSType();\n      origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n    case Token.THIS:\n      // \"this\" references aren't currently modeled in the CFG.\n      break;\n\n    default:\n      throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n          node.toStringTree());\n  }\n}", "rollout": 1}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "patch": "          options.skipAllPasses ||", "rollout": 2}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "patch": "    return len > 0 && s.charAt(0) != '0' && (len == 1 || s.charAt(1) != 'x') && (len <= 31 || s.length() < 10) && (len <= 32 || s.length() < 11) && (len <= 53 || s.length() < 17);", "rollout": 13}
{"project": "Closure", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "56", "eval": "PASS", "patch": "public String getLine(int lineNumber) {\n  String js = \"\";\n  try {\n    // NOTE(nicksantos): Right now, this is optimized for few warnings.\n    // This is probably the right trade-off, but will be slow if there\n    // are lots of warnings in one file.\n    js = getCode();\n  } catch (IOException e) {\n    return null;\n  }\n\n  int pos = 0;\n  int startLine = 1;\n\n  // If we've saved a previous offset and it's for a line less than the\n  // one we're searching for, then start at that point.\n  if (lineNumber >= lastLine) {\n    pos = lastOffset;\n    startLine = lastLine;\n  }\n\n  for (int n = startLine; n < lineNumber; n++) {\n    int nextpos = js.indexOf('\\n', pos);\n    if (nextpos == -1) {\n      return null;\n    }\n    pos = nextpos + 1;\n  }\n\n  // Remember this offset for the next search we do.\n  lastOffset = pos;\n  lastLine = lineNumber;\n\n  int nextNewLine = js.indexOf('\\n', pos);\n  if (nextNewLine == -1) {\n    // If next new line cannot be found, there are two cases\n    // 1. pos already reaches the end of file, then null should be returned\n    // 2. otherwise, return the contents between pos and the end of file.\n    if (pos == js.length()) {\n      return null;\n    } else {\n      return js.substring(pos);\n    }\n  } else {\n    return js.substring(pos, nextNewLine);\n  }\n}", "rollout": 1}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "patch": "if (target != null && target.getType() == Token.STRING) {", "rollout": 1}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "61", "eval": "PASS", "patch": "// Functions in the \"Math\" namespace have no side effects.\nif (nameNode.getType() == Token.GETPROP && nameNode.getFirstChild().getType() == Token.NAME && nameNode.getFirstChild().getString().equals(\"Math\")) {\n  return false;\n}\n\nif (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n  if (nameNode.getFirstChild().getType() == Token.REGEXP\n      && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n    return false;\n  } else if (nameNode.getFirstChild().getType() == Token.STRING\n      && STRING_REGEXP_METHODS.contains(\n          nameNode.getLastChild().getString())) {\n    Node param = nameNode.getNext();\n    if (param != null &&\n        (param.getType() == Token.STRING\n            || param.getType() == Token.REGEXP))\n      return false;\n  }\n}", "rollout": 7}
{"project": "Closure", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "65", "eval": "PASS", "patch": "        case '\\0': sb.append(\"\\\\000\"); break;", "rollout": 1}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "patch": "            if (c >= 0x20 && c <= 0x7e) {", "rollout": 1}
{"project": "Closure", "bug_id": "77", "eval": "PASS", "patch": "case '\\0': sb.append(\"\\\\0\"); break;", "rollout": 1}
{"project": "Closure", "bug_id": "78", "eval": "PASS", "patch": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n          || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  double result;\n\n  // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n  // to zero so this is a little akward here.\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITOR:\n      result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n      break;\n    case Token.BITXOR:\n      result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n      break;\n    case Token.ADD:\n      result = lval + rval;\n      break;\n    case Token.SUB:\n      result = lval - rval;\n      break;\n    case Token.MUL:\n      result = lval * rval;\n      break;\n    case Token.MOD:\n      if (rval == 0) {\n        // Return null or an appropriate value indicating an error\n        return null;\n      }\n      result = lval % rval;\n      break;\n    case Token.DIV:\n      if (rval == 0) {\n        // Return null or an appropriate value indicating an error\n        return null;\n      }\n      result = lval / rval;\n      break;\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n\n  // TODO(johnlenz): consider removing the result length check.\n  // length of the left and right value plus 1 byte for the operator.\n  if (String.valueOf(result).length() <=\n      String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n      // Do not try to fold arithmetic for numbers > 2^53. After that\n      // point, fixed-point math starts to break down and become inaccurate.\n      Math.abs(result) <= MAX_FOLD_NUMBER) {\n    Node newNumber = Node.newNumber(result);\n    return newNumber;\n  } else if (Double.isNaN(result)) {\n    return Node.newString(Token.NAME, \"NaN\");\n  } else if (result == Double.POSITIVE_INFINITY) {\n    return Node.newString(Token.NAME, \"Infinity\");\n  } else if (result == Double.NEGATIVE_INFINITY) {\n    return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n  }\n\n  return null;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "patch": "        return false;", "rollout": 1}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "88", "eval": "PASS", "patch": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n    if (NodeUtil.isLhs(n, n.getParent())) {\n      return VariableLiveness.KILL;\n    } else {\n      return VariableLiveness.READ;\n    }\n  }\n\n  if (n.getType() == Token.AND) {\n    VariableLiveness leftState = isVariableReadBeforeKill(n.getFirstChild(), variable);\n    VariableLiveness rightState = isVariableReadBeforeKill(n.getFirstChild().getNext(), variable);\n    if (leftState == VariableLiveness.READ) {\n      return VariableLiveness.READ;\n    }\n    return rightState;\n  }\n\n  VariableLiveness currentState = VariableLiveness.MAYBE_LIVE;\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    if (!ControlFlowGraph.isEnteringNewCfgNode(child)) {\n      VariableLiveness state = isVariableReadBeforeKill(child, variable);\n      if (state == VariableLiveness.READ) {\n        currentState = VariableLiveness.READ;\n      } else if (state == VariableLiveness.KILL) {\n        currentState = VariableLiveness.KILL;\n      }\n    }\n  }\n  return currentState;\n}", "rollout": 6}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "patch": "int indexOfDot = namespace != null ? namespace.lastIndexOf('.') : namespace.length();", "rollout": 4}
{"project": "Closure", "bug_id": "94", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "97", "eval": "PASS", "patch": "          // Convert the result to an unsigned 32-bit integer\n          result = (lvalInt >>> rvalInt) & 0xFFFFFFFFL;", "rollout": 1}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "101", "eval": "PASS", "patch": "protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    if (flags.process_closure_primitives) {\n      options.closurePass = true;\n    } else {\n      options.closurePass = false;\n    }\n\n    initOptionsFromFlags(options);\n    return options;\n}", "rollout": 2}
{"project": "Closure", "bug_id": "102", "eval": "PASS", "patch": "public void process(Node externs, Node root) {\n  NodeTraversal.traverse(compiler, root, this);\n  if (MAKE_LOCAL_NAMES_UNIQUE) {\n    MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.getType() == Token.NAME && \"arguments\".equals(n.getString())) {\n          // Skip renaming the 'arguments' variable\n          return;\n        }\n        super.visit(t, n, parent);\n      }\n    };\n    NodeTraversal t = new NodeTraversal(compiler, renamer);\n    t.traverseRoots(externs, root);\n  }\n  removeDuplicateDeclarations(root);\n  new PropogateConstantAnnotations(compiler, assertOnChange)\n      .process(externs, root);\n}", "rollout": 1}
{"project": "Closure", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "107", "eval": "PASS", "patch": "options.messageBundle = null;", "rollout": 1}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "119", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "122", "eval": "PASS", "patch": "if (comment.getValue().startsWith(\"/*\") && comment.getValue().endsWith(\"*/\") && comment.getValue().indexOf(\"@\") != -1) {", "rollout": 3}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "patch": "private boolean isSafeReplacement(Node node, Node replacement) {\n  // No checks are needed for simple names.\n  if (node.isName()) {\n    return true;\n  }\n  Preconditions.checkArgument(node.isGetProp());\n\n  node = node.getFirstChild();\n  if (node.isName()\n      && isNameAssignedTo(node.getString(), replacement)) {\n    return false;\n  }\n\n  while (node.isGetProp()) {\n    node = node.getFirstChild();\n    if (node.isName()\n        && isNameAssignedTo(node.getString(), replacement)) {\n      return false;\n    }\n  }\n\n  return true;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "125", "eval": "PASS", "patch": "      if (fnType != null && fnType.isConstructor()) {", "rollout": 1}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "patch": "// Skip processing the finally block", "rollout": 4}
{"project": "Closure", "bug_id": "128", "eval": "PASS", "patch": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  if (len == 0) {\n    return false;\n  }\n\n  // Check for leading zero\n  if (s.charAt(0) == '0' && len > 1) {\n    return false;\n  }\n\n  // Check for floating point numbers\n  if (s.indexOf('.') != s.lastIndexOf('.')) {\n    return false;\n  }\n\n  // Check for hexadecimal numbers\n  if (len > 2 && (s.charAt(1) == 'x' || s.charAt(1) == 'X') && Character.isDigit(s.charAt(2))) {\n    for (int i = 2; i < len; i++) {\n      char c = s.charAt(i);\n      if (!(Character.isDigit(c) || c >= 'a' && c <= 'f' || c >= 'A' && c <= 'F')) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // Check for integer numbers\n  for (int i = 0; i < len; i++) {\n    char c = s.charAt(i);\n    if (!Character.isDigit(c)) {\n      return false;\n    }\n  }\n  return true;\n}", "rollout": 7}
{"project": "Closure", "bug_id": "129", "eval": "PASS", "patch": "if (first.isCast()) {\n  first = first.getFirstChild();\n}", "rollout": 1}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "patch": "public static boolean isJSIdentifier(String s) {\n    int length = s.length();\n\n    if (length == 0 ||\n        !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n    }\n\n    for (int i = 1; i < length; i++) {\n        char c = s.charAt(i);\n        if (\n            !Character.isJavaIdentifierPart(c) ||\n            c < 32) { // Check for control characters\n          return false;\n        }\n    }\n\n    return true;\n}", "rollout": 1}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "152", "eval": "PASS", "patch": "", "rollout": 8}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "patch": "      if (parent.isFunction()) {", "rollout": 1}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "5", "eval": "PASS", "patch": "if (buffer == null || buffer.length - pos < decodeSize) {\n    resizeBuffer();\n}", "rollout": 2}
{"project": "Codec", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "patch": "int len = ((binaryData.length + 2) / 3) * 4;", "rollout": 2}
{"project": "Codec", "bug_id": "10", "eval": "PASS", "patch": "        txt = txt.replaceAll(\"mb$\", \"m2\");", "rollout": 1}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "patch": "        return (bytes == null) ? null : new String(bytes, Charsets.ISO_8859_1);", "rollout": 1}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "patch": "        return cs1.toString().equals(cs2.toString());", "rollout": 2}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "11", "eval": "PASS", "patch": "public ArchiveInputStream createArchiveInputStream(final InputStream in) throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read the first block\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        int tarHeaderLength = in.read(tarheader);\n        in.reset();\n\n        // Ensure the first block is at least 512 bytes long\n        if (tarHeaderLength >= 512) {\n            if (TarArchiveInputStream.matches(tarheader, tarHeaderLength)) {\n                return new TarArchiveInputStream(in);\n            }\n\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                byte[] tarheaderCopy = new byte[tarHeaderLength];\n                System.arraycopy(tarheader, 0, tarheaderCopy, 0, tarHeaderLength);\n                ByteArrayInputStream tempIn = new ByteArrayInputStream(tarheaderCopy);\n                TarArchiveInputStream tais = new TarArchiveInputStream(tempIn);\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}", "rollout": 12}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "15", "eval": "PASS", "patch": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    String myName = getName();\n    String otherName = other.getName();\n    if (myName == null) {\n        if (otherName != null) {\n            return false;\n        }\n    } else if (!myName.equals(otherName)) {\n        return false;\n    }\n    String myComment = getComment();\n    String otherComment = other.getComment();\n    if ((myComment == null && otherComment != null && !\"\".equals(otherComment))\n        || (myComment != null && !myComment.equals(otherComment))) {\n        return false;\n    }\n    return getTime() == other.getTime()\n        && getInternalAttributes() == other.getInternalAttributes()\n        && getPlatform() == other.getPlatform()\n        && getExternalAttributes() == other.getExternalAttributes()\n        && getMethod() == other.getMethod()\n        && getSize() == other.getSize()\n        && getCrc() == other.getCrc()\n        && getCompressedSize() == other.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         other.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         other.getLocalFileDataExtra())\n        && gpb.equals(other.gpb);\n}", "rollout": 3}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "18", "eval": "PASS", "patch": "void writePaxHeaders(String entryName,\n                     Map<String, String> headers) throws IOException {\n    String name = \"./PaxHeaders.X/\" + stripTo7Bits(entryName);\n    // TarEntry's constructor would think this is a directory\n    // and not allow any data to be written\n    if (name.length() >= TarConstants.NAMELEN) {\n        name = name.substring(0, TarConstants.NAMELEN - 1);\n    }\n    // Remove trailing slash if it exists\n    if (name.endsWith(\"/\")) {\n        name = name.substring(0, name.length() - 1);\n    }\n    TarArchiveEntry pex = new TarArchiveEntry(name,\n                                              TarConstants.LF_PAX_EXTENDED_HEADER_LC);\n\n    StringWriter w = new StringWriter();\n    for (Map.Entry<String, String> h : headers.entrySet()) {\n        String key = h.getKey();\n        String value = h.getValue();\n        int len = key.length() + value.length()\n            + 3 /* blank, equals and newline */\n            + 2 /* guess 9 < actual length < 100 */;\n        String line = len + \" \" + key + \"=\" + value + \"\\n\";\n        int actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        while (len != actualLength) {\n            // Adjust for cases where length < 10 or > 100\n            // or where UTF-8 encoding isn't a single octet\n            // per character.\n            // Must be in loop as size may go from 99 to 100 in\n            // first pass so we'd need a second.\n            len = actualLength;\n            line = len + \" \" + key + \"=\" + value + \"\\n\";\n            actualLength = line.getBytes(CharsetNames.UTF_8).length;\n        }\n        w.write(line);\n    }\n    byte[] data = w.toString().getBytes(CharsetNames.UTF_8);\n    pex.setSize(data.length);\n    putArchiveEntry(pex);\n    write(data);\n    closeArchiveEntry();\n}", "rollout": 1}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "patch": "if (rawCentralDirectoryData.length < expectedLength) {", "rollout": 1}
{"project": "Compress", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "patch": "dictSize = (dictSize << 8) | coder.properties[i + 1] & 0xFF;", "rollout": 6}
{"project": "Compress", "bug_id": "24", "eval": "PASS", "patch": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long result = 0;\n    int end = offset + length;\n    int start = offset;\n\n    if (length < 2) {\n        throw new IllegalArgumentException(\"Length \" + length + \" must be at least 2\");\n    }\n\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n\n    // Skip leading spaces\n    while (start < end && buffer[start] == ' ') {\n        start++;\n    }\n\n    // Skip trailing spaces and null bytes\n    while (start < end && (buffer[end - 1] == ' ' || buffer[end - 1] == 0)) {\n        end--;\n        if (end <= start) {\n            throw new IllegalArgumentException(\"Not all NULs\");\n        }\n    }\n\n    for (; start < end; start++) {\n        final byte currentByte = buffer[start];\n        // CheckStyle:MagicNumber OFF\n        if (currentByte < '0' || currentByte > '7') {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, currentByte));\n        }\n        result = (result << 3) + (currentByte - '0'); // convert from ASCII\n        // CheckStyle:MagicNumber ON\n    }\n\n    return result;\n}", "rollout": 11}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "patch": "// Check if there is at least one valid octal digit after skipping spaces\nif (start == end) {\n    return 0L;\n}", "rollout": 2}
{"project": "Compress", "bug_id": "28", "eval": "PASS", "patch": "public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    int totalRead = 0;\n\n    if (hasHitEOF || entryOffset >= entrySize) {\n        return -1;\n    }\n\n    if (currEntry == null) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n\n    numToRead = Math.min(numToRead, available());\n\n    totalRead = is.read(buf, offset, numToRead);\n    count(totalRead);\n\n    if (totalRead == -1) {\n        hasHitEOF = true;\n    } else {\n        entryOffset += totalRead;\n    }\n\n    if (totalRead < numToRead) {\n        throw new IOException(\"Truncated tar entry\");\n    }\n\n    return totalRead;\n}", "rollout": 1}
{"project": "Compress", "bug_id": "30", "eval": "PASS", "patch": "if (len == 0) {\n    return 0;\n}", "rollout": 1}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "patch": "if (currentByte < '0' || currentByte > '7') {\n    throw new IllegalArgumentException(\n        exceptionMessage(buffer, offset, length, start, currentByte));\n}", "rollout": 7}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "patch": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    for (Map.Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Long.parseLong(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Long.parseLong(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "rollout": 1}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "38", "eval": "PASS", "patch": "if (file != null && file.isDirectory() && getName().endsWith(\"/\")) {", "rollout": 1}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "patch": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n    if (checksum == null) {\n        throw new NullPointerException(\"Checksum cannot be null\");\n    }\n    if (in == null) {\n        throw new NullPointerException(\"InputStream cannot be null\");\n    }\n\n    this.checksum = checksum;\n    this.in = in;\n}", "rollout": 1}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "patch": "public static int formatLongOctalOrBinaryBytes(\n    final long value, final byte[] buf, final int offset, final int length) {\n\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n\n    if (length < 9) {\n        formatLongBinary(value, buf, offset, length, negative);\n    } else {\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n    }\n\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}", "rollout": 1}
{"project": "Compress", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "1", "eval": "PASS", "patch": "if (current == '\\n' || (current == '\\r' && lookAhead() != '\\n')) {", "rollout": 11}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "patch": "public String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer index = mapping.get(name);\n    if (index == null) {\n        return null;\n    }\n    if (index < 0 || index >= values.length) {\n        throw new IllegalArgumentException(\"Invalid index: \" + index);\n    }\n    return values[index.intValue()];\n}", "rollout": 1}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "patch": "return this.headerMap;", "rollout": 4}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "patch": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    if (recordSeparator != null) {\n        out.append(recordSeparator);\n    } else {\n        out.append(\"\"); // Append an empty string if recordSeparator is null\n    }\n    newRecord = true;\n}", "rollout": 1}
{"project": "Csv", "bug_id": "6", "eval": "PASS", "patch": "public Iterator<String> iterator() {\n    return toList().iterator();\n}\n\n/**\n * Puts all values of this record into the given Map.\n *\n * @param map The Map to populate.\n * @return the given map.\n */\npublic <M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length) { // Check if the column index is within bounds\n            map.put(entry.getKey(), values[col]);\n        } else {\n            // Handle the case where the column index is out of bounds\n            // For example, you can skip adding this entry or set a default value\n            // Here, we will skip adding this entry\n        }\n    }\n    return map;\n}", "rollout": 1}
{"project": "Csv", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "patch": "                    final boolean emptyHeader = header == null || header.trim().isEmpty();", "rollout": 1}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "patch": "if (c == delimChar || c == quoteChar || c == '\\n' || c == '\\r' || c == COMMENT) {", "rollout": 6}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "patch": "                if (newRecord && c < 0x20) {\n                    quote = true;\n                } else if (c <= COMMENT) {", "rollout": 1}
{"project": "Gson", "bug_id": "5", "eval": "PASS", "patch": "timezoneOffset = (timezoneOffset.length() < 5) ? timezoneOffset + \"00\" : timezoneOffset;", "rollout": 8}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "11", "eval": "PASS", "patch": "case STRING:", "rollout": 1}
{"project": "Gson", "bug_id": "12", "eval": "PASS", "patch": "@Override public void skipValue() throws IOException {\n  if (peek() == JsonToken.NAME) {\n    nextName();\n    if (stackSize >= 2) {\n      pathNames[stackSize - 2] = \"null\";\n    }\n  } else {\n    if (stackSize > 0) {\n      popStack();\n    }\n    if (stackSize > 0) {\n      pathNames[stackSize - 1] = \"null\";\n    }\n  }\n  if (stackSize > 0) {\n    pathIndices[stackSize - 1]++;\n  }\n}", "rollout": 1}
{"project": "Gson", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "15", "eval": "PASS", "patch": "if (!isLenient() && (Double.isNaN(value) || Double.isInfinite(value))) {", "rollout": 1}
{"project": "Gson", "bug_id": "16", "eval": "PASS", "patch": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                            Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n        if (toResolve instanceof TypeVariable) {\n            TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n            if (visitedTypeVariables.contains(typeVariable)) {\n                // If the type variable has already been visited, return it as is\n                return toResolve;\n            }\n            visitedTypeVariables.add(typeVariable);\n            // cannot reduce due to infinite recursion\n            toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n            if (toResolve == typeVariable) {\n                return toResolve;\n            }\n        } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n            Class<?> original = (Class<?>) toResolve;\n            Type componentType = original.getComponentType();\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n            return componentType == newComponentType\n                ? original\n                : arrayOf(newComponentType);\n        } else if (toResolve instanceof GenericArrayType) {\n            GenericArrayType original = (GenericArrayType) toResolve;\n            Type componentType = original.getGenericComponentType();\n            Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n            return componentType == newComponentType\n                ? original\n                : arrayOf(newComponentType);\n        } else if (toResolve instanceof ParameterizedType) {\n            ParameterizedType original = (ParameterizedType) toResolve;\n            Type ownerType = original.getOwnerType();\n            Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n            boolean changed = newOwnerType != ownerType;\n\n            Type[] args = original.getActualTypeArguments();\n            for (int t = 0, length = args.length; t < length; t++) {\n                Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n                if (resolvedTypeArgument != args[t]) {\n                    if (!changed) {\n                        args = args.clone();\n                        changed = true;\n                    }\n                    args[t] = resolvedTypeArgument;\n                }\n            }\n\n            return changed\n                ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n                : original;\n        } else if (toResolve instanceof WildcardType) {\n            WildcardType original = (WildcardType) toResolve;\n            Type[] originalLowerBound = original.getLowerBounds();\n            Type[] originalUpperBound = original.getUpperBounds();\n\n            if (originalLowerBound.length == 1) {\n                Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n                if (lowerBound != originalLowerBound[0]) {\n                    return supertypeOf(lowerBound);\n                }\n            } else if (originalUpperBound.length == 1) {\n                Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n                if (upperBound != originalUpperBound[0]) {\n                    return subtypeOf(upperBound);\n                }\n            }\n            return original;\n        } else {\n            return toResolve;\n        }\n    }\n}", "rollout": 1}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "patch": "public char[] expandCurrentSegment()\n{\n    final char[] curr = _currentSegment;\n    // Let's grow by 25% by default\n    final int len = curr.length;\n    // but above intended maximum, slow to increase by 25%\n    int newLen = (len == MAX_SEGMENT_LEN) ? MAX_SEGMENT_LEN : len + (len / 4);\n    return (_currentSegment = Arrays.copyOf(curr, newLen));\n}", "rollout": 6}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "patch": "char c = str.charAt(i);", "rollout": 1}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "patch": "if (!_hasSegments && _currentSegment != null) return _currentSegment;", "rollout": 2}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "patch": "if (i < maxCode && codes[i] != 0) {", "rollout": 1}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "PASS", "patch": "protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n{\n    final int mask = (1 << typeIndex);\n    _hasNonDefaultCreator = true;\n    AnnotatedWithParams oldOne = _creators[typeIndex];\n    // already had an explicitly marked one?\n    if (oldOne != null) {\n\n        if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n            // but skip, if new one not annotated\n            if (!explicit) {\n                return;\n            }\n            // both explicit: verify\n            // otherwise only verify if neither explicitly annotated.\n        }\n\n        // one more thing: ok to override in sub-class\n        if (oldOne.getClass() == newOne.getClass()) {\n            // [databind#667]: avoid one particular class of bogus problems\n            if (explicit && (_explicitCreators & mask) != 0) {\n                throw new IllegalArgumentException(\"Conflicting \" + TYPE_DESCS[typeIndex]\n                        + \" creators: already had explicitly marked \" + oldOne + \", encountered \" + newOne);\n            }\n            // otherwise, which one to choose?\n            // new type more generic, use old\n            // new type more specific, use it\n        }\n    }\n    if (explicit) {\n        _explicitCreators |= mask;\n    }\n    _creators[typeIndex] = _fixAccess(newOne);\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "patch": "        return previous == null;", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "PASS", "patch": "                        && !TreeNode.class.isAssignableFrom(t.getRawClass()));", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "PASS", "patch": "public BaseSettings withDateFormat(DateFormat df) {\n    if (_dateFormat == df) {\n        return this;\n    }\n    TimeZone tz = (df == null) ? _timeZone : (TimeZone) _timeZone.clone();\n    DateFormat newDf = df; // Directly use the provided DateFormat object if it's not null\n    if (newDf != null) {\n        newDf.setTimeZone(tz);\n    }\n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n            _typeResolverBuilder, newDf, _handlerInstantiator, _locale,\n            tz, _defaultBase64);\n}", "rollout": 6}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "patch": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "PASS", "patch": "if (_kind == STD_LOCALE) {\n    return Locale.ROOT;\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "PASS", "patch": "protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n    throws JsonMappingException\n{\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // !!! NOTE: should be handled better for 2.8 and later\n        if (!(mutator.getDeclaringClass() == Throwable.class && mutator.getName().equals(\"cause\"))) {\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    // did type change?\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if(objectIdInfo != null){\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "PASS", "patch": "public String getDescription() {\n    if (_desc == null) {\n        StringBuilder sb = new StringBuilder();\n\n        if (_from == null) {\n            sb.append(\"UNKNOWN\");\n        } else {\n            Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n            // Use Class.getName() to get the fully qualified name of the class\n            String clsName = cls.getName();\n            sb.append(clsName);\n            sb.append('[');\n            if (_fieldName != null) {\n                sb.append('\"');\n                sb.append(_fieldName);\n                sb.append('\"');\n            } else if (_index >= 0) {\n                sb.append(_index);\n            } else {\n                sb.append('?');\n            }\n            sb.append(']');\n        }\n        _desc = sb.toString();\n    }\n    return _desc;\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "patch": "                found = key.equalsIgnoreCase(prop.getName());", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "PASS", "patch": "public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String text = p.getValueAsString();\n    if (text != null) { // has String representation\n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception cause = null;\n        try {\n            return _deserialize(text, ctxt);\n        } catch (IllegalArgumentException iae) {\n            cause = iae;\n        } catch (MalformedURLException me) {\n            cause = me;\n        }\n        String msg = \"not a valid textual representation\";\n        if (cause != null) {\n            String m2 = cause.getMessage();\n            if (m2 != null) {\n                msg = msg + \", problem: \"+m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n        if (cause != null) {\n            e.initCause(cause);\n        }\n        throw e;\n        // nothing to do here, yet? We'll fail anyway\n    }\n    JsonToken t = p.getCurrentToken();\n    // [databind#381]\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "PASS", "patch": "private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n\nprivate final static Class<?>[] NO_VIEWS = new Class<?>[0];\n\n/**\n * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n * and should (and is) prevented by default.\n *\n * @since 2.8.9\n */\nprotected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(createDefaultNoDeserClassNames());\n\nprivate static Set<String> createDefaultNoDeserClassNames() {\n    Set<String> s = new HashSet<>();\n    // Courtesy of [https://github.com/kantega/notsoserial]:\n    // (and wrt [databind#1599])\n    s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n    s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n    s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n    s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n    s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n    s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n    s.add(\"org.springframework.beans.factory.ObjectFactory\");\n    s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n    s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n    // [databind#1680]: may or may not be problem, take no chance\n    s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n    // [databind#1737]; JDK provided\n    s.add(\"java.util.logging.FileHandler\");\n    s.add(\"java.rmi.server.UnicastRemoteObject\");\n\n    return s;\n}", "rollout": 13}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "PASS", "patch": "private final static Class<?>[] INIT_CAUSE_PARAMS = new Class<?>[] { Throwable.class };\n\nprivate final static Class<?>[] NO_VIEWS = new Class<?>[0];\n\n/**\n * Set of well-known \"nasty classes\", deserialization of which is considered dangerous\n * and should (and is) prevented by default.\n */\nprotected final static Set<String> DEFAULT_NO_DESER_CLASS_NAMES;\nstatic {\n    Set<String> s = new HashSet<String>();\n    // Courtesy of [https://github.com/kantega/notsoserial]:\n    // (and wrt [databind#1599])\n    s.add(\"org.apache.commons.collections.functors.InvokerTransformer\");\n    s.add(\"org.apache.commons.collections.functors.InstantiateTransformer\");\n    s.add(\"org.apache.commons.collections4.functors.InvokerTransformer\");\n    s.add(\"org.apache.commons.collections4.functors.InstantiateTransformer\");\n    s.add(\"org.codehaus.groovy.runtime.ConvertedClosure\");\n    s.add(\"org.codehaus.groovy.runtime.MethodClosure\");\n    s.add(\"org.springframework.beans.factory.ObjectFactory\");\n    s.add(\"com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl\");\n    s.add(\"org.apache.xalan.xsltc.trax.TemplatesImpl\");\n    // [databind#1680]: may or may not be problem, take no chance\n    s.add(\"com.sun.rowset.JdbcRowSetImpl\");\n    // [databind#1737]; JDK provided\n    s.add(\"java.util.logging.FileHandler\");\n    s.add(\"java.rmi.server.UnicastRemoteObject\");\n\n    DEFAULT_NO_DESER_CLASS_NAMES = Collections.unmodifiableSet(s);\n}", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "patch": "paramName = (paramName == null) ? PropertyName.construct(paramDef.getName()) : paramName;", "rollout": 10}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "PASS", "patch": "            ctxt.defaultSerializeValue(_value, gen);", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "PASS", "patch": "sb.append('>');", "rollout": 6}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "PASS", "patch": "public byte[] getBinaryValue(Base64Variant b64variant)\n    throws IOException, JsonParseException\n{\n    // Multiple possibilities...\n    JsonNode n = currentNode();\n    if (n != null) {\n        // [databind#2096]: although `binaryValue()` works for real binary node\n        // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n        if (n instanceof BinaryNode) {\n            byte[] data = n.binaryValue();\n            if (data != null) {\n                return data;\n            }\n        } else if (n.isPojo()) {\n            Object ob = ((POJONode) n).getPojo();\n            if (ob instanceof byte[]) {\n                return (byte[]) ob;\n            }\n        } else if (n.isTextual()) {\n            String text = n.asText();\n            try {\n                byte[] data = b64variant.decode(text);\n                if (data != null) {\n                    return data;\n                }\n            } catch (Exception e) {\n                // Handle the exception if decoding fails\n                // For example, log the error and return null\n                e.printStackTrace();\n            }\n        }\n    }\n    // otherwise return null to mark we have no binary content\n    return null;\n}", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "PASS", "patch": "        // Skip the check for null property value", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "3", "eval": "PASS", "patch": "public String nextTextValue() throws IOException {\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        _currToken = JsonToken.VALUE_STRING;\n        return _currText; // Add this line to return the attribute value immediately\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n\n            // NOTE: this is different from nextToken() -- NO work-around\n            // for otherwise empty List/array\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // If not a leaf, need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}", "rollout": 1}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "5", "eval": "PASS", "patch": "            if (!tq.isEmpty() && !tq.matchesWhitespace() && !tq.matchesAny(\">\", \"/>\")) {\n                tq.consume();\n            }", "rollout": 8}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "patch": "            // there are times where there is a spurious byte-order-mark at the start of the text. Shouldn't be present\n            // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n            // into head mode\n            if (docData.startsWith(\"\\uFEFF\")) {\n                docData = docData.substring(1);\n            }", "rollout": 1}
{"project": "Jsoup", "bug_id": "24", "eval": "PASS", "patch": "t.tagPending.appendTagName(name.toLowerCase());", "rollout": 2}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "patch": "    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};", "rollout": 1}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "32", "eval": "PASS", "patch": "clone.classNames = (this.classNames == null) ? null : new HashSet<String>(this.classNames);", "rollout": 2}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "patch": "            if (offset + seq.length() <= length) {", "rollout": 1}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "patch": "doc = null;", "rollout": 3}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "patch": "        if (name != null && !name.isEmpty()) attr(\"name\", name);", "rollout": 1}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "patch": "return this.outerHtml().equals(element.outerHtml());", "rollout": 1}
{"project": "Jsoup", "bug_id": "42", "eval": "PASS", "patch": "public List<Connection.KeyVal> formData() {\n    ArrayList<Connection.KeyVal> data = new ArrayList<Connection.KeyVal>();\n\n    // iterate the form control elements and accumulate their values\n    for (Element el : elements) {\n        if (!el.tag().isFormSubmittable()) continue; // contents are form listable, superset of submitable\n        String name = el.attr(\"name\");\n        if (name.length() == 0) continue;\n        String type = el.attr(\"type\");\n\n        if (\"select\".equals(el.tagName())) {\n            Elements options = el.select(\"option[selected]\");\n            boolean set = false;\n            for (Element option : options) {\n                data.add(HttpConnection.KeyVal.create(name, option.val()));\n                set = true;\n            }\n            if (!set) {\n                Element option = el.select(\"option\").first();\n                if (option != null)\n                    data.add(HttpConnection.KeyVal.create(name, option.val()));\n            }\n        } else if (\"checkbox\".equalsIgnoreCase(type) || \"radio\".equalsIgnoreCase(type)) {\n            // only add checkbox or radio if they have the checked attribute\n            if (el.hasAttr(\"checked\")) {\n                final String val = el.hasAttr(\"value\") ? el.val() : \"on\";\n                data.add(HttpConnection.KeyVal.create(name, val));\n            }\n        } else {\n            // Check if the input element is not disabled\n            if (!el.hasAttr(\"disabled\")) {\n                data.add(HttpConnection.KeyVal.create(name, el.val()));\n            }\n        }\n    }\n    return data;\n}", "rollout": 3}
{"project": "Jsoup", "bug_id": "43", "eval": "PASS", "patch": "if (element == search)", "rollout": 1}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "patch": "} else if (\"td\".equals(name) || \"th\".equals(name)) {", "rollout": 1}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "patch": "                    accum.append(\"&#xa0;\");", "rollout": 1}
{"project": "Jsoup", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "48", "eval": "PASS", "patch": "void processResponseHeaders(Map<String, List<String>> resHeaders) {\n    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n        String name = entry.getKey();\n        if (name == null)\n            continue; // http/1.1 line\n\n        List<String> values = entry.getValue();\n        if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n            for (String value : values) {\n                if (value == null)\n                    continue;\n                TokenQueue cd = new TokenQueue(value);\n                String cookieName = cd.chompTo(\"=\").trim();\n                String cookieVal = cd.consumeTo(\";\").trim();\n                // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                // name not blank, value not null\n                if (cookieName.length() > 0)\n                    cookie(cookieName, cookieVal);\n            }\n        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (!values.isEmpty()) {\n                StringBuilder combinedValue = new StringBuilder();\n                for (String value : values) {\n                    if (combinedValue.length() > 0)\n                        combinedValue.append(\", \");\n                    combinedValue.append(value);\n                }\n                header(name, combinedValue.toString());\n            }\n        }\n    }\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "49", "eval": "PASS", "patch": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    if (index < 0 || index > childNodes.size()) {\n        throw new IndexOutOfBoundsException(\"Index \" + index + \" is out of bounds for current child nodes size \" + childNodes.size());\n    }\n\n    // Create a temporary list to store the reparented nodes\n    List<Node> reparentedChildren = new ArrayList<Node>(children.length);\n\n    // Reparent each node and add it to the temporary list\n    for (Node node : children) {\n        reparentChild(node);\n        reparentedChildren.add(node);\n    }\n\n    // Add the reparented nodes to the childNodes list at the specified index\n    childNodes.addAll(index, reparentedChildren);\n\n    // Reindex the children starting from the specified index\n    reindexChildren(index);\n}", "rollout": 15}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "patch": "                it.remove();", "rollout": 1}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "patch": "final void newAttribute() {\n    if (attributes == null)\n        attributes = new Attributes();\n\n    if (pendingAttributeName != null) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n        if (pendingAttributeName.length() > 0) {\n            Attribute attribute;\n            if (hasPendingAttributeValue)\n                attribute = new Attribute(pendingAttributeName,\n                    pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n            else if (hasEmptyAttributeValue)\n                attribute = new Attribute(pendingAttributeName, \"\");\n            else\n                attribute = new BooleanAttribute(pendingAttributeName);\n            attributes.put(attribute);\n        }\n    }\n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "68", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "patch": "static boolean preserveWhitespace(Node node) {\n    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n    int levelsToCheck = 5;\n    while (node != null && levelsToCheck > 0) {\n        if (node instanceof Element) {\n            Element el = (Element) node;\n            if (el.tag.preserveWhitespace()) {\n                return true;\n            }\n        }\n        node = node.parent();\n        levelsToCheck--;\n    }\n    return false;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "72", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "77", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "80", "eval": "PASS", "patch": "void insert(Token.Comment commentToken) {\n    Comment comment = new Comment(commentToken.getData());\n    Node insert = comment;\n    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String data = comment.getData();\n        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n            Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n            if (!doc.children().isEmpty()) { // Check if the document has children\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n    }\n    insertNode(insert);\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "82", "eval": "PASS", "patch": "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException {\n    if (input == null) {\n        throw new IllegalArgumentException(\"Input stream cannot be null\");\n    }\n\n    if (input.available() == 0) {\n        return new Document(baseUri);\n    }\n\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null) {\n        charsetName = bomCharset.charset;\n    }\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        // some charsets can read but not encode; switch to an encodable charset and update the meta el\n    }\n\n    // Ensure the document uses UTF-8 if the detected charset cannot be encoded\n    if (charsetName != null) {\n        Charset detectedCharset = Charset.forName(charsetName);\n        if (!detectedCharset.canEncode()) {\n            doc.charset(Charset.forName(\"UTF-8\"));\n            Elements metaElements = doc.select(\"meta[charset]\");\n            if (!metaElements.isEmpty()) {\n                metaElements.first().attr(\"charset\", \"UTF-8\");\n            } else {\n                doc.head().appendElement(\"meta\").attr(\"charset\", \"UTF-8\");\n            }\n        }\n    }\n\n    input.close();\n    return doc;\n}", "rollout": 7}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "patch": "public Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    this.key = key.trim();\n    if (this.key.isEmpty()) {\n        throw new IllegalArgumentException(\"Key cannot be empty after trimming\");\n    }\n    this.val = val;\n    this.parent = parent;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "86", "eval": "PASS", "patch": "if (doc.children().size() > 0) {", "rollout": 5}
{"project": "Jsoup", "bug_id": "88", "eval": "PASS", "patch": "        return val != null ? val : \"\";", "rollout": 1}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "patch": "public String setValue(String val) {\n    String oldVal = parent == null ? this.val : parent.get(this.key);\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound)\n            parent.vals[i] = val;\n    }\n    this.val = val;\n    return Attributes.checkNotNull(oldVal);\n}", "rollout": 6}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "patch": "if (end > input.length) {\n    return false;\n}", "rollout": 1}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "8", "eval": "PASS", "patch": "private boolean compute(Object left, Object right) {\n    left = reduce(left);\n    right = reduce(right);\n\n    if (left instanceof InitialContext) {\n        ((InitialContext) left).reset();\n    }\n    if (right instanceof InitialContext) {\n        ((InitialContext) right).reset();\n    }\n    if (left instanceof Iterator && right instanceof Iterator) {\n        return findMatch((Iterator) left, (Iterator) right);\n    }\n    if (left instanceof Iterator) {\n        return containsMatch((Iterator) left, right);\n    }\n    if (right instanceof Iterator) {\n        return containsMatch((Iterator) right, left);\n    }\n\n    double ld = InfoSetUtil.doubleValue(left);\n    double rd = InfoSetUtil.doubleValue(right);\n\n    // Check for NaN values\n    if (Double.isNaN(ld) || Double.isNaN(rd)) {\n        return false;\n    }\n\n    return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n}", "rollout": 1}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "patch": "public static String getNamespaceURI(Node node) {\n    // Convert the node to the DocumentElement if it is a Document\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    // Check if the node is not an Element\n    if (!(node instanceof Element)) {\n        return null;\n    }\n\n    // Cast the node to an Element\n    Element element = (Element) node;\n\n    // Get the namespace URI of the element\n    String uri = element.getNamespaceURI();\n    if (uri != null && !uri.isEmpty()) {\n        // If the namespace URI is not empty, return it\n        return uri;\n    }\n\n    // Get the prefix of the element\n    String prefix = element.getPrefix();\n\n    // Set the qname to \"xmlns\" if the prefix is null, otherwise set it to \"xmlns:prefix\"\n    String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n    // Check if the prefix is null and directly look for the xmlns attribute\n    if (prefix == null) {\n        Attr attr = element.getAttributeNodeNS(null, \"xmlns\");\n        if (attr != null) {\n            // Return the value of the attribute\n            return attr.getValue();\n        }\n    }\n\n    // Iterate over the parent nodes\n    Node aNode = node.getParentNode();\n    while (aNode != null) {\n        if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n            // Cast the parent node to an Element\n            Element currentElement = (Element) aNode;\n\n            // Get the attribute node for the current qname\n            Attr attr = currentElement.getAttributeNodeNS(null, \"xmlns\");\n            if (attr != null) {\n                // Return the value of the attribute\n                return attr.getValue();\n            }\n        }\n        aNode = aNode.getParentNode();\n    }\n    return null;\n}", "rollout": 16}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "patch": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.toString().equals(cs2.toString());\n}", "rollout": 1}
{"project": "Lang", "bug_id": "16", "eval": "PASS", "patch": "        if (str.regionMatches(true, 0, \"0x\", 0, 2) || str.regionMatches(true, 0, \"-0x\", 0, 3)) {", "rollout": 1}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "rollout": 1}
{"project": "Lang", "bug_id": "22", "eval": "PASS", "patch": "private static int greatestCommonDivisor(int u, int v) {\n    // From Commons Math:\n    // if either operand is abs 1, return 1:\n    if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) { u = -u; } // make u negative\n    if (v > 0) { v = -v; } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n        u >>= 1; v >>= 1; k++; // cast out twos.\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int t = ((u & 1) == 1) ? v : -(u >> 1); // B3\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u < 0 && v < 0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t >>= 1; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) >> 1;\n        // |u| larger: t positive (replace u)\n        // |v| larger: t negative (replace v)\n    } while (t != 0);\n    return -u << k; // gcd is u * 2^k\n}", "rollout": 9}
{"project": "Lang", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "28", "eval": "PASS", "patch": "public int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n    if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n\n        int end = start;\n        while(input.charAt(end) != ';') {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n            return 0;\n        }\n\n        // Handle supplementary characters\n        if (entityValue > 0xFFFF) {\n            char[] chars = Character.toChars(entityValue);\n            out.write(chars);\n        } else {\n            out.write(entityValue);\n        }\n        return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n    }\n    return 0;\n}", "rollout": 1}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "patch": "classes[i] = (array[i] == null) ? null : array[i].getClass();", "rollout": 1}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "patch": "public static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    final Class<?> type2 = array2.getClass().getComponentType();\n\n    // Check if the types are assignable from each other\n    if (!type1.isAssignableFrom(type2) && !type2.isAssignableFrom(type1)) {\n        throw new IllegalArgumentException(\"Incompatible types: \" + type1 + \" and \" + type2);\n    }\n\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    return joinedArray;\n}", "rollout": 1}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "40", "eval": "PASS", "patch": "        if (searchStr.length() > str.length()) {\n            return false;\n        }\n        return contains(str.toUpperCase(Locale.ROOT), searchStr.toUpperCase(Locale.ROOT));", "rollout": 6}
{"project": "Lang", "bug_id": "42", "eval": "PASS", "patch": "public void escape(Writer writer, String str) throws IOException {\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        if (Character.isHighSurrogate(c)) {\n            // Handle high surrogate\n            if (i + 1 < len && Character.isLowSurrogate(str.charAt(i + 1))) {\n                // Append the low surrogate as well\n                char highSurrogate = c;\n                char lowSurrogate = str.charAt(++i);\n                int codePoint = Character.toCodePoint(highSurrogate, lowSurrogate);\n                if (codePoint > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(codePoint, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                // Handle invalid surrogate pair\n                writer.write(\"&#\");\n                writer.write(Integer.toString(c, 10));\n                writer.write(';');\n            }\n        } else if (Character.isLowSurrogate(c)) {\n            // Handle low surrogate (should not happen in normal string processing)\n            writer.write(\"&#\");\n            writer.write(Integer.toString(c, 10));\n            writer.write(';');\n        } else {\n            String entityName = this.entityName(c);\n            if (entityName == null) {\n                if (c > 0x7F) {\n                    writer.write(\"&#\");\n                    writer.write(Integer.toString(c, 10));\n                    writer.write(';');\n                } else {\n                    writer.write(c);\n                }\n            } else {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            }\n        }\n    }\n}", "rollout": 1}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "patch": "// if the lower value is greater than the length of the string,\n// set to the length of the string\nif (lower > str.length()) {\n    lower = str.length();\n}", "rollout": 1}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "patch": "if (str.length() < 4) return false;", "rollout": 1}
{"project": "Lang", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "patch": "public void stop() {\n    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running or suspended.\");\n    }\n    if (this.runningState == STATE_RUNNING) {\n        stopTime = System.currentTimeMillis();\n    }\n    this.runningState = STATE_STOPPED;\n}", "rollout": 1}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "patch": "        return Arrays.asList(Locale.getAvailableLocales()).contains(locale);", "rollout": 14}
{"project": "Lang", "bug_id": "58", "eval": "PASS", "patch": "                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))\n                        && isDigits(numeric.substring((numeric.charAt(0) == '-') ? 1 : 0))) {", "rollout": 1}
{"project": "Lang", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "2", "eval": "PASS", "patch": "return getSampleSize() * (getNumberOfSuccesses() / (double) getPopulationSize());", "rollout": 2}
{"project": "Math", "bug_id": "3", "eval": "PASS", "patch": "public static double linearCombination(final double[] a, final double[] b)\n    throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n\n    // Revert to scalar multiplication.\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                aHigh * bHigh) -\n                                               aLow * bHigh) -\n                                              aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n    double result;\n    if (len == 1) {\n        result = prodHigh[0] + prodLowSum;\n    } else {\n        final double prodHighCur = prodHigh[0];\n        double sHighPrev = prodHighCur;\n        double sPrime = 0;\n        double sLowSum = 0;\n\n        for (int i = 1; i < len; i++) {\n            final double prodHighNext = prodHigh[i];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        result = sHighPrev + (prodLowSum + sLowSum);\n    }\n\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}", "rollout": 1}
{"project": "Math", "bug_id": "5", "eval": "PASS", "patch": "return Complex.INF;", "rollout": 1}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "17", "eval": "PASS", "patch": "    public Dfp multiply(final int x) {\n        Dfp dfpX = new Dfp(field, x);\n        return multiply(dfpX);\n    }", "rollout": 1}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "28", "eval": "PASS", "patch": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, 1) > 0) {\n            final double ratio = rhs / entry;\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        Integer minRow = null;\n        int minIndex = tableau.getWidth();\n\n        for (Integer row : minRatioPositions) {\n            for (int i = 0; i < tableau.getWidth(); i++) {\n                if (row == tableau.getBasicRow(i)) {\n                    if (i < minIndex) {\n                        minIndex = i;\n                        minRow = row;\n                    }\n                }\n            }\n        }\n        return minRow;\n    }\n    return minRatioPositions.get(0);\n}", "rollout": 2}
{"project": "Math", "bug_id": "30", "eval": "PASS", "patch": "        final double n1n2prod = (double) n1 * n2;", "rollout": 1}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "32", "eval": "PASS", "patch": "if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {", "rollout": 1}
{"project": "Math", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "34", "eval": "PASS", "patch": "return Collections.unmodifiableList(chromosomes).iterator();", "rollout": 6}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "41", "eval": "PASS", "patch": "                    for (int i = begin; i < begin + length; i++) {", "rollout": 1}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "50", "eval": "PASS", "patch": "                    if (x == x1) {\n                        x0 = x0 + (x1 - x0) * 0.5; // Update x0 to the midpoint\n                        f0 = computeObjectiveValue(x0);\n                    }", "rollout": 1}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "53", "eval": "PASS", "patch": "if (Double.isNaN(rhs.getReal()) || Double.isNaN(rhs.getImaginary())) {\n    return createComplex(Double.NaN, Double.NaN);\n}", "rollout": 1}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "57", "eval": "PASS", "patch": "double sum = 0.0;", "rollout": 1}
{"project": "Math", "bug_id": "58", "eval": "PASS", "patch": "return fit(guess);", "rollout": 3}
{"project": "Math", "bug_id": "59", "eval": "PASS", "patch": "return Float.isNaN(a) || Float.isNaN(b) ? Float.NaN : (a <= b) ? b : a;", "rollout": 1}
{"project": "Math", "bug_id": "60", "eval": "PASS", "patch": "public double cumulativeProbability(double x) throws MathException {\n    final double dev = x - mean;\n    if (Double.isInfinite(x)) {\n        return x > 0 ? 1.0 : 0.0;\n    }\n    if (x > mean + 20 * standardDeviation) {\n        return 1.0;\n    }\n    if (x < mean - 20 * standardDeviation) {\n        return 0.0;\n    }\n    return 0.5 * (1.0 + Erf.erf((dev) / (standardDeviation * FastMath.sqrt(2.0))));\n}", "rollout": 2}
{"project": "Math", "bug_id": "63", "eval": "PASS", "patch": "        return (x == y) || (x == Double.POSITIVE_INFINITY && y == Double.POSITIVE_INFINITY) || (x == Double.NEGATIVE_INFINITY && y == Double.NEGATIVE_INFINITY);", "rollout": 6}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "69", "eval": "PASS", "patch": "out[i][j] = nVars > 2 ? 2 * (1 - tDistribution.cumulativeProbability(Math.abs(t))) : 1.0;", "rollout": 9}
{"project": "Math", "bug_id": "70", "eval": "PASS", "patch": "        return solve(f, min, max);", "rollout": 1}
{"project": "Math", "bug_id": "72", "eval": "PASS", "patch": "public double solve(final UnivariateRealFunction f,\n                   final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    // check if initial guess is equal to one of the endpoints\n    if (initial == min || initial == max) {\n        double midpoint = (min + max) / 2.0;\n        return midpoint;\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}", "rollout": 12}
{"project": "Math", "bug_id": "73", "eval": "PASS", "patch": "// check if initial guess and endpoints bracket the root\nif (yInitial * yMin > 0 && yInitial * yMax > 0) {\n    throw new IllegalArgumentException(\"Non-bracketing interval\");\n}", "rollout": 1}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "79", "eval": "PASS", "patch": "public static double distance(int[] p1, int[] p2) {\n    if (p1 == null || p2 == null) {\n        throw new IllegalArgumentException(\"Points must not be null\");\n    }\n    if (p1.length != p2.length) {\n        throw new IllegalArgumentException(\"Points must have the same length\");\n    }\n    long sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final long dp = (long) p1[i] - (long) p2[i];\n        sum += dp * dp;\n    }\n    return Math.sqrt(sum);\n}", "rollout": 6}
{"project": "Math", "bug_id": "80", "eval": "PASS", "patch": "int j = 4 * (n - 1) + pingPong;", "rollout": 5}
{"project": "Math", "bug_id": "82", "eval": "PASS", "patch": "            if (entry > 0) {", "rollout": 3}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "85", "eval": "PASS", "patch": "if (fa * fb > 0.0 || a < lowerBound || b > upperBound) {", "rollout": 1}
{"project": "Math", "bug_id": "86", "eval": "PASS", "patch": "public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                 final double relativeSymmetryThreshold,\n                                 final double absolutePositivityThreshold)\n    throws NonSquareMatrixException,\n           NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n    if (!matrix.isSquare()) {\n        throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                           matrix.getColumnDimension());\n    }\n\n    final int order = matrix.getRowDimension();\n    lTData   = matrix.getData();\n    cachedL  = null;\n    cachedLT = null;\n\n    // check the matrix before transformation\n    for (int i = 0; i < order; ++i) {\n\n        final double[] lI = lTData[i];\n\n        // check off-diagonal elements (and reset them to 0)\n        for (int j = i + 1; j < order; ++j) {\n            final double[] lJ = lTData[j];\n            final double lIJ = lI[j];\n            final double lJI = lJ[i];\n            final double maxDelta =\n                relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n            if (Math.abs(lIJ - lJI) > maxDelta) {\n                throw new NotSymmetricMatrixException();\n            }\n            lJ[i] = 0;\n       }\n    }\n\n    // check the diagonal elements\n    for (int i = 0; i < order; ++i) {\n        if (lTData[i][i] < absolutePositivityThreshold) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n    }\n\n    // transform the matrix\n    for (int i = 0; i < order; ++i) {\n\n        final double[] ltI = lTData[i];\n\n        // check diagonal element\n        final double diagonal = ltI[i];\n        if (diagonal <= 0) {\n            throw new NotPositiveDefiniteMatrixException();\n        }\n        ltI[i] = Math.sqrt(diagonal);\n        final double inverse = 1.0 / ltI[i];\n\n        for (int q = order - 1; q > i; --q) {\n            ltI[q] *= inverse;\n            final double[] ltQ = lTData[q];\n            for (int p = q; p < order; ++p) {\n                ltQ[p] -= ltI[q] * ltI[p];\n            }\n        }\n\n    }\n\n}", "rollout": 4}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "89", "eval": "PASS", "patch": "public void addValue(Object v) {\n    if (v instanceof Comparable<?>) {\n        addValue((Comparable<?>) v);\n    } else {\n        throw new IllegalArgumentException(\"Object is not Comparable and cannot be added to Frequency\");\n    }\n}", "rollout": 1}
{"project": "Math", "bug_id": "91", "eval": "PASS", "patch": "        int nOd = this.numerator * object.denominator;\n        int dOn = this.denominator * object.numerator;", "rollout": 1}
{"project": "Math", "bug_id": "94", "eval": "PASS", "patch": "if (u == 0 || v == 0) {", "rollout": 1}
{"project": "Math", "bug_id": "95", "eval": "PASS", "patch": "protected double getInitialDomain(double p) {\n    double ret;\n    double d = getDenominatorDegreesOfFreedom();\n    if (d <= 2.0) {\n        ret = 0.0; // or handle it in another way\n    } else {\n        // use mean\n        ret = d / (d - 2.0);\n    }\n    return ret;\n}", "rollout": 2}
{"project": "Math", "bug_id": "96", "eval": "PASS", "patch": "ret = this.real == rhs.real && this.imaginary == rhs.imaginary;", "rollout": 5}
{"project": "Math", "bug_id": "97", "eval": "PASS", "patch": "public double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n    \n    clearResult();\n    verifyInterval(min, max);\n    \n    double ret = Double.NaN;\n    \n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    \n    // Verify bracketing\n    double epsilon = 1e-12; // small tolerance for floating-point comparison\n    double sign = yMin * yMax;\n    if (sign >= 0 && Math.abs(sign) > epsilon) {\n        // check if either value is close to a zero\n        // neither value is close to zero and min and max do not bracket root.\n        throw new IllegalArgumentException\n        (\"Function values at endpoints do not have different signs.\" +\n                \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n\n    return ret;\n}", "rollout": 1}
{"project": "Math", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "103", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "1", "eval": "PASS", "patch": "for (int position = 0; position < indexOfVararg; position++) {\n    Matcher m = matchers.get(position);\n    if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n    }\n}", "rollout": 12}
{"project": "Mockito", "bug_id": "5", "eval": "PASS", "patch": "catch (AssertionError e) {", "rollout": 7}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "12", "eval": "PASS", "patch": "public Class<?> getGenericType(Field field) {        \n    Type generic = field.getGenericType();\n    if (generic != null && generic instanceof ParameterizedType) {\n        Type[] actualTypes = ((ParameterizedType) generic).getActualTypeArguments();\n        for (Type actual : actualTypes) {\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                // Handle nested generics\n                Type nestedType = ((ParameterizedType) actual).getRawType();\n                if (nestedType instanceof Class) {\n                    return (Class<?>) nestedType;\n                }\n            }\n        }\n    }\n    \n    return Object.class;\n}", "rollout": 2}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "24", "eval": "PASS", "patch": "return invocation.getMock() == invocation.getArguments()[0] ? 0 : 1;", "rollout": 4}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "patch": "        primitiveValues.put(double.class, 0.0);", "rollout": 1}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "33", "eval": "PASS", "patch": "public boolean hasSameMethod(Invocation candidate) {\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n\n    // Compare method names and parameter types\n    return m1.getName().equals(m2.getName()) && \n           java.util.Arrays.equals(m1.getParameterTypes(), m2.getParameterTypes());\n}", "rollout": 1}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "patch": "if (k < i.getArguments().length && m instanceof CapturesArguments) {", "rollout": 7}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "patch": "        return arg != null && StringDescription.toString(m).equals(arg.toString());", "rollout": 1}
{"project": "Time", "bug_id": "4", "eval": "PASS", "patch": "Partial newPartial = new Partial(newTypes, newValues);", "rollout": 10}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "19", "eval": "PASS", "patch": "} else {", "rollout": 10}
{"project": "Time", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
