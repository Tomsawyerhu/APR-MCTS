{"project": "Chart", "bug_id": "1", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "if (dataset == null) {", "diff": "diff --git a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\nindex 226b25a..f8cca61 100644\n--- a/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n+++ b/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java\n@@ -1794,7 +1794,7 @@ public abstract class AbstractCategoryItemRenderer extends AbstractRenderer\n         }\n         int index = this.plot.getIndexOf(this);\n         CategoryDataset dataset = this.plot.getDataset(index);\n-        if (dataset != null) {\n+if (dataset == null) {\n             return result;\n         }\n         int seriesCount = dataset.getRowCount();"}
{"project": "Chart", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic Range getDataRange(ValueAxis axis) {\n\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                new Integer(domainIndex)));\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                new Integer(rangeIndex)));\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        if (d != null) {\n            XYItemRenderer r = getRendererForDataset(d);\n            if (r != null) { // check if r is not null before proceeding\n                if (isDomainAxis) {\n                    result = Range.combine(result, r.findDomainBounds(d));\n                } else {\n                    result = Range.combine(result, r.findRangeBounds(d));\n                }\n                \n                // Check if c is not null before proceeding\n                Collection c = r.getAnnotations();\n                if(c != null) {\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n                }\n            } else {\n                if (isDomainAxis) {\n                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\n                } else {\n                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\n                }\n            }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            } else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n\n}\n", "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..cc8fb45 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4422,101 +4422,100 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n      *\n      * @return The range.\n      */\n-    public Range getDataRange(ValueAxis axis) {\n-\n-        Range result = null;\n-        List mappedDatasets = new ArrayList();\n-        List includedAnnotations = new ArrayList();\n-        boolean isDomainAxis = true;\n-\n-        // is it a domain axis?\n-        int domainIndex = getDomainAxisIndex(axis);\n-        if (domainIndex >= 0) {\n-            isDomainAxis = true;\n-            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n-                    new Integer(domainIndex)));\n-            if (domainIndex == 0) {\n-                // grab the plot's annotations\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // or is it a range axis?\n-        int rangeIndex = getRangeAxisIndex(axis);\n-        if (rangeIndex >= 0) {\n-            isDomainAxis = false;\n-            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n-                    new Integer(rangeIndex)));\n-            if (rangeIndex == 0) {\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // iterate through the datasets that map to the axis and get the union\n-        // of the ranges.\n-        Iterator iterator = mappedDatasets.iterator();\n-        while (iterator.hasNext()) {\n-            XYDataset d = (XYDataset) iterator.next();\n-            if (d != null) {\n-                XYItemRenderer r = getRendererForDataset(d);\n-                if (isDomainAxis) {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findDomainBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findDomainBounds(d));\n-                    }\n-                }\n-                else {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findRangeBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findRangeBounds(d));\n-                    }\n-                }\n-                \n-                    Collection c = r.getAnnotations();\n-                    Iterator i = c.iterator();\n-                    while (i.hasNext()) {\n-                        XYAnnotation a = (XYAnnotation) i.next();\n-                        if (a instanceof XYAnnotationBoundsInfo) {\n-                            includedAnnotations.add(a);\n-                        }\n-                    }\n-            }\n-        }\n-\n-        Iterator it = includedAnnotations.iterator();\n-        while (it.hasNext()) {\n-            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n-            if (xyabi.getIncludeInDataBounds()) {\n-                if (isDomainAxis) {\n-                    result = Range.combine(result, xyabi.getXRange());\n-                }\n-                else {\n-                    result = Range.combine(result, xyabi.getYRange());\n-                }\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n+\n+public Range getDataRange(ValueAxis axis) {\n+\n+    Range result = null;\n+    List mappedDatasets = new ArrayList();\n+    List includedAnnotations = new ArrayList();\n+    boolean isDomainAxis = true;\n+\n+    // is it a domain axis?\n+    int domainIndex = getDomainAxisIndex(axis);\n+    if (domainIndex >= 0) {\n+        isDomainAxis = true;\n+        mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n+                new Integer(domainIndex)));\n+        if (domainIndex == 0) {\n+            // grab the plot's annotations\n+            Iterator iterator = this.annotations.iterator();\n+            while (iterator.hasNext()) {\n+                XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                if (annotation instanceof XYAnnotationBoundsInfo) {\n+                    includedAnnotations.add(annotation);\n+                }\n+            }\n+        }\n+    }\n+\n+    // or is it a range axis?\n+    int rangeIndex = getRangeAxisIndex(axis);\n+    if (rangeIndex >= 0) {\n+        isDomainAxis = false;\n+        mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n+                new Integer(rangeIndex)));\n+        if (rangeIndex == 0) {\n+            Iterator iterator = this.annotations.iterator();\n+            while (iterator.hasNext()) {\n+                XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                if (annotation instanceof XYAnnotationBoundsInfo) {\n+                    includedAnnotations.add(annotation);\n+                }\n+            }\n+        }\n+    }\n+\n+    // iterate through the datasets that map to the axis and get the union\n+    // of the ranges.\n+    Iterator iterator = mappedDatasets.iterator();\n+    while (iterator.hasNext()) {\n+        XYDataset d = (XYDataset) iterator.next();\n+        if (d != null) {\n+            XYItemRenderer r = getRendererForDataset(d);\n+            if (r != null) { // check if r is not null before proceeding\n+                if (isDomainAxis) {\n+                    result = Range.combine(result, r.findDomainBounds(d));\n+                } else {\n+                    result = Range.combine(result, r.findRangeBounds(d));\n+                }\n+                \n+                // Check if c is not null before proceeding\n+                Collection c = r.getAnnotations();\n+                if(c != null) {\n+                    Iterator i = c.iterator();\n+                    while (i.hasNext()) {\n+                        XYAnnotation a = (XYAnnotation) i.next();\n+                        if (a instanceof XYAnnotationBoundsInfo) {\n+                            includedAnnotations.add(a);\n+                        }\n+                    }\n+                }\n+            } else {\n+                if (isDomainAxis) {\n+                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\n+                } else {\n+                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\n+                }\n+            }\n+        }\n+    }\n+\n+    Iterator it = includedAnnotations.iterator();\n+    while (it.hasNext()) {\n+        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n+        if (xyabi.getIncludeInDataBounds()) {\n+            if (isDomainAxis) {\n+                result = Range.combine(result, xyabi.getXRange());\n+            } else {\n+                result = Range.combine(result, xyabi.getYRange());\n+            }\n+        }\n+    }\n+\n+    return result;\n+\n+}\n+\n \n     /**\n      * Receives notification of a change to the plot's dataset."}
{"project": "Chart", "bug_id": "5", "eval": "PASS", "attempt": 19, "mode": "SF", "patch": "\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0 && !this.allowDuplicateXValues) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n            this.data.set(index, existing);\n        }\n        else if (index < 0 && this.autoSort) {\n            index = -index - 1;\n            if (index == this.data.size()) {\n                this.data.add(new XYDataItem(x, y));\n            } else {\n                this.data.add(index, new XYDataItem(x, y));\n            }\n        } else {\n            // if the series is not sorted, just append the value to the list...\n            this.data.add(new XYDataItem(x, y));\n        }\n        if (getItemCount() > this.maximumItemCount) {\n            if (this.autoSort) {\n                this.data.remove(0);\n            } else {\n                this.data.remove(this.data.size() - 1);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n", "diff": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex 0b37e6e..e452565 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -537,43 +537,48 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n      * @return A copy of the overwritten data item, or <code>null</code> if no\n      *         item was overwritten.\n      */\n-    public XYDataItem addOrUpdate(Number x, Number y) {\n-        if (x == null) {\n-            throw new IllegalArgumentException(\"Null 'x' argument.\");\n-        }\n-\n-        // if we get to here, we know that duplicate X values are not permitted\n-        XYDataItem overwritten = null;\n-        int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n-            XYDataItem existing = (XYDataItem) this.data.get(index);\n-            try {\n-                overwritten = (XYDataItem) existing.clone();\n-            }\n-            catch (CloneNotSupportedException e) {\n-                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n-            }\n-            existing.setY(y);\n-        }\n-        else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n-            // check if this addition will exceed the maximum item count...\n-            if (getItemCount() > this.maximumItemCount) {\n-                this.data.remove(0);\n-            }\n-        }\n-        fireSeriesChanged();\n-        return overwritten;\n-    }\n+\n+    public XYDataItem addOrUpdate(Number x, Number y) {\n+        if (x == null) {\n+            throw new IllegalArgumentException(\"Null 'x' argument.\");\n+        }\n+\n+        // if we get to here, we know that duplicate X values are not permitted\n+        XYDataItem overwritten = null;\n+        int index = indexOf(x);\n+        if (index >= 0 && !this.allowDuplicateXValues) {\n+            XYDataItem existing = (XYDataItem) this.data.get(index);\n+            try {\n+                overwritten = (XYDataItem) existing.clone();\n+            }\n+            catch (CloneNotSupportedException e) {\n+                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n+            }\n+            existing.setY(y);\n+            this.data.set(index, existing);\n+        }\n+        else if (index < 0 && this.autoSort) {\n+            index = -index - 1;\n+            if (index == this.data.size()) {\n+                this.data.add(new XYDataItem(x, y));\n+            } else {\n+                this.data.add(index, new XYDataItem(x, y));\n+            }\n+        } else {\n+            // if the series is not sorted, just append the value to the list...\n+            this.data.add(new XYDataItem(x, y));\n+        }\n+        if (getItemCount() > this.maximumItemCount) {\n+            if (this.autoSort) {\n+                this.data.remove(0);\n+            } else {\n+                this.data.remove(this.data.size() - 1);\n+            }\n+        }\n+        fireSeriesChanged();\n+        return overwritten;\n+    }\n+\n \n     /**\n      * Returns the index of the item with the specified x-value, or a negative"}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprivate void updateBounds(TimePeriod period, int index) {\n    \n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + ((end - start) / 2);\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) { // Changed from \"if (middle < minMiddleIndex)\" to \"if (middle < minMiddle)\"\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) { // Changed from \"if (middle > getPeriod(this.maxMiddleIndex).getStart().getTime())\" to \"if (middle > maxMiddle)\"\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n    \n}\n", "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..33bb03b 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -254,85 +254,87 @@ public class TimePeriodValues extends Series implements Serializable {\n      * @param period  the time period.\n      * @param index  the index of the time period.\n      */\n-    private void updateBounds(TimePeriod period, int index) {\n-        \n-        long start = period.getStart().getTime();\n-        long end = period.getEnd().getTime();\n-        long middle = start + ((end - start) / 2);\n-\n-        if (this.minStartIndex >= 0) {\n-            long minStart = getDataItem(this.minStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start < minStart) {\n-                this.minStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minStartIndex = index;\n-        }\n-        \n-        if (this.maxStartIndex >= 0) {\n-            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start > maxStart) {\n-                this.maxStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxStartIndex = index;\n-        }\n-        \n-        if (this.minMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long minMiddle = s + (e - s) / 2;\n-            if (middle < minMiddle) {\n-                this.minMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minMiddleIndex = index;\n-        }\n-        \n-        if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long maxMiddle = s + (e - s) / 2;\n-            if (middle > maxMiddle) {\n-                this.maxMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxMiddleIndex = index;\n-        }\n-        \n-        if (this.minEndIndex >= 0) {\n-            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end < minEnd) {\n-                this.minEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minEndIndex = index;\n-        }\n-       \n-        if (this.maxEndIndex >= 0) {\n-            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end > maxEnd) {\n-                this.maxEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxEndIndex = index;\n-        }\n-        \n-    }\n+\n+private void updateBounds(TimePeriod period, int index) {\n+    \n+    long start = period.getStart().getTime();\n+    long end = period.getEnd().getTime();\n+    long middle = start + ((end - start) / 2);\n+\n+    if (this.minStartIndex >= 0) {\n+        long minStart = getDataItem(this.minStartIndex).getPeriod()\n+            .getStart().getTime();\n+        if (start < minStart) {\n+            this.minStartIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minStartIndex = index;\n+    }\n+    \n+    if (this.maxStartIndex >= 0) {\n+        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n+            .getStart().getTime();\n+        if (start > maxStart) {\n+            this.maxStartIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxStartIndex = index;\n+    }\n+    \n+    if (this.minMiddleIndex >= 0) {\n+        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+            .getTime();\n+        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+            .getTime();\n+        long minMiddle = s + (e - s) / 2;\n+        if (middle < minMiddle) { // Changed from \"if (middle < minMiddleIndex)\" to \"if (middle < minMiddle)\"\n+            this.minMiddleIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minMiddleIndex = index;\n+    }\n+    \n+    if (this.maxMiddleIndex >= 0) {\n+        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n+            .getTime();\n+        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n+            .getTime();\n+        long maxMiddle = s + (e - s) / 2;\n+        if (middle > maxMiddle) { // Changed from \"if (middle > getPeriod(this.maxMiddleIndex).getStart().getTime())\" to \"if (middle > maxMiddle)\"\n+            this.maxMiddleIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxMiddleIndex = index;\n+    }\n+    \n+    if (this.minEndIndex >= 0) {\n+        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n+            .getTime();\n+        if (end < minEnd) {\n+            this.minEndIndex = index;           \n+        }\n+    }\n+    else {\n+        this.minEndIndex = index;\n+    }\n+   \n+    if (this.maxEndIndex >= 0) {\n+        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n+            .getTime();\n+        if (end > maxEnd) {\n+            this.maxEndIndex = index;           \n+        }\n+    }\n+    else {\n+        this.maxEndIndex = index;\n+    }\n+    \n+}\n+\n     \n     /**\n      * Recalculates the bounds for the collection of items."}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        this(time, zone, Locale.getDefault());", "diff": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 3cc4138..183bac2 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+        this(time, zone, Locale.getDefault());\n     }\n \n     /**"}
{"project": "Chart", "bug_id": "9", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "        if (startIndex > endIndex) {", "diff": "diff --git a/source/org/jfree/data/time/TimeSeries.java b/source/org/jfree/data/time/TimeSeries.java\nindex 4067e3e..79389c8 100644\n--- a/source/org/jfree/data/time/TimeSeries.java\n+++ b/source/org/jfree/data/time/TimeSeries.java\n@@ -941,7 +941,7 @@ public class TimeSeries extends Series implements Cloneable, Serializable {\n             endIndex = -(endIndex + 1); // this is first item AFTER end period\n             endIndex = endIndex - 1;    // so this is last item BEFORE end\n         }\n-        if (endIndex < 0) {\n+        if (startIndex > endIndex) {\n             emptyRange = true;\n         }\n         if (emptyRange) {"}
{"project": "Chart", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        PathIterator iterator2 = p2.getPathIterator(null);", "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();"}
{"project": "Chart", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "                    new Range(0.0, constraint.getWidth() - w[3]),", "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..5f726a3 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, constraint.getWidth() - w[3]),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);"}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "super(paint, stroke, outlinePaint, outlineStroke, alpha);", "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..ce5cf41 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     "}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "attempt": 4, "mode": "SH", "patch": "\nif (str == null)\n{\n    return null;\n}\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex 2d88c30..ad3ced2 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -33,6 +33,12 @@ class Util {\n      */\n     static String stripLeadingHyphens(String str)\n     {\n+\n+if (str == null)\n+{\n+    return null;\n+}\n+\n         if (str.startsWith(\"--\"))\n         {\n             return str.substring(2, str.length());\n@@ -64,4 +70,4 @@ class Util {\n         }\n         return str;\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "            pos = findWrapPos(text, width, 0);", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 639b9d5..40873f5 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -809,7 +809,7 @@ public class HelpFormatter {\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+            pos = findWrapPos(text, width, 0);\n \n             if (pos == -1)\n             {"}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\nprotected void checkRequiredOptions()\n        throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processsed\n    if (getRequiredOptions().size() > 0)\n    {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n        // loop through the required options\n        while (iter.hasNext())\n        {\n            Object obj = iter.next();\n            if (obj instanceof String)\n            {\n                buff.append((String) obj);\n                buff.append(\", \");\n            }\n        }\n\n        // remove the trailing comma and space\n        if (buff.length() > 0)\n        {\n            buff.delete(buff.length() - 2, buff.length());\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex dbace06..c3cbc12 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -300,28 +300,40 @@ public abstract class Parser implements CommandLineParser {\n      * @throws MissingOptionException if any of the required Options\n      * are not present.\n      */\n-    protected void checkRequiredOptions()\n+\n+protected void checkRequiredOptions()\n         throws MissingOptionException\n+{\n+    // if there are required options that have not been\n+    // processsed\n+    if (getRequiredOptions().size() > 0)\n     {\n-        // if there are required options that have not been\n-        // processsed\n-        if (getRequiredOptions().size() > 0)\n-        {\n-            Iterator iter = getRequiredOptions().iterator();\n-            StringBuffer buff = new StringBuffer(\"Missing required option\");\n-            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n-            buff.append(\": \");\n-\n+        Iterator iter = getRequiredOptions().iterator();\n+        StringBuffer buff = new StringBuffer(\"Missing required option\");\n+        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n+        buff.append(\": \");\n \n-            // loop through the required options\n-            while (iter.hasNext())\n+        // loop through the required options\n+        while (iter.hasNext())\n+        {\n+            Object obj = iter.next();\n+            if (obj instanceof String)\n             {\n-                buff.append(iter.next());\n+                buff.append((String) obj);\n+                buff.append(\", \");\n             }\n+        }\n \n-            throw new MissingOptionException(buff.toString());\n+        // remove the trailing comma and space\n+        if (buff.length() > 0)\n+        {\n+            buff.delete(buff.length() - 2, buff.length());\n         }\n+\n+        throw new MissingOptionException(buff.toString());\n     }\n+}\n+\n \n     /**\n      * <p>Process the argument values for the specified Option"}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "if (option.hasArg() && (option.getArgName() != null && !option.getArgName().isEmpty()))", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 183cae3..31a735c 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -629,7 +629,7 @@ public class HelpFormatter {\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+if (option.hasArg() && (option.getArgName() != null && !option.getArgName().isEmpty()))\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }"}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                    continue;", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex 6b39536..c106932 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -287,7 +287,7 @@ public abstract class Parser implements CommandLineParser\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+                    continue;\n                 }\n \n                 cmd.addOption(opt);"}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "32", "eval": "PASS", "attempt": 16, "mode": "SH", "patch": "\n        while ((pos >= startPos) && ((c = text.charAt(pos)) == '\\r'))\n        {\n            --pos;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 6b74e4e..d41c6f0 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -934,11 +934,12 @@ public class HelpFormatter\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n+\n+        while ((pos >= startPos) && ((c = text.charAt(pos)) == '\\r'))\n         {\n-            ++pos;\n-        }        \n+            --pos;\n+        }\n+\n         return pos == text.length() ? -1 : pos;\n     }\n "}
{"project": "Cli", "bug_id": "35", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        // for a perfect match return the single option only\n        if (longOpts.containsKey(opt)) {\n            matchingOpts.add(opt);\n            return matchingOpts;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/Options.java b/src/main/java/org/apache/commons/cli/Options.java\nindex e9a0aa9..199680b 100644\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n@@ -238,6 +238,13 @@ public class Options implements Serializable\n \n         // for a perfect match return the single option only\n \n+        // for a perfect match return the single option only\n+        if (longOpts.containsKey(opt)) {\n+            matchingOpts.add(opt);\n+            return matchingOpts;\n+        }\n+\n+\n         for (String longOpt : longOpts.keySet())\n         {\n             if (longOpt.startsWith(opt))"}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprivate boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return token.startsWith(\"-\") && token.length() >= 2\n            && (token.length() > 2 || !token.substring(1, 2).matches(\"[0-9]\"))\n            && options.hasShortOption(token.substring(1));\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 6aeaebe..1ac1f56 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -296,13 +296,15 @@ public class DefaultParser implements CommandLineParser\n      * \n      * @param token\n      */\n-    private boolean isShortOption(String token)\n-    {\n-        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n \n-        // remove leading \"-\" and \"=value\"\n-    }\n+private boolean isShortOption(String token)\n+{\n+    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n+    return token.startsWith(\"-\") && token.length() >= 2\n+            && (token.length() > 2 || !token.substring(1, 2).matches(\"[0-9]\"))\n+            && options.hasShortOption(token.substring(1));\n+}\n+\n \n     /**\n      * Tells if the token looks like a long option."}
{"project": "Cli", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            throw new ParseException(\"Unsupported class for value creation: \" + clazz);", "diff": "diff --git a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex 6bd84b0..cb10cfc 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -100,7 +100,7 @@ public class TypeHandler\n         }\n         else\n         {\n-            return null;\n+            throw new ParseException(\"Unsupported class for value creation: \" + clazz);\n         }\n     }\n "}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn't make the code crash).\n    // This is a hack to prevent a NPE.\n    if (implicitProto == null) {\n      return;\n    }\n    currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db9..31e3e859 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1563,15 +1563,20 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * that have been visited\n    * @param interfaceType The super interface that is being visited\n    */\n+\n   private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       String functionName, HashMap<String, ObjectType> properties,\n       HashMap<String, ObjectType> currentProperties,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n-      // This can be the case if interfaceType is proxy to a non-existent\n-      // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n+    // This can be the case if interfaceType is proxy to a non-existent\n+    // object (which is a bad type annotation, but shouldn't make the code crash).\n+    // This is a hack to prevent a NPE.\n+    if (implicitProto == null) {\n+      return;\n+    }\n+    currentPropertyNames = implicitProto.getOwnPropertyNames();\n     for (String name : currentPropertyNames) {\n       ObjectType oType = properties.get(name);\n       if (oType != null) {\n@@ -1591,6 +1596,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     }\n   }\n \n+\n   /**\n    * Visits a {@link Token#FUNCTION} node.\n    *"}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      return mayBeStringHelper(n);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef27927..fb514773 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return mayBeStringHelper(n);\n     } else {\n       return mayBeStringHelper(n);\n     }"}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "13", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\nprivate void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node next = null;\n      for (Node c = node.getFirstChild(); c != null; c = next) {\n        next = c.getNext();\n        traverse(c);\n      }\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many iterations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\nindex b51c088e..139095d5 100644\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -110,7 +110,8 @@ class PeepholeOptimizationsPass\n     compiler.removeChangeHandler(handler);\n   }\n \n-  private void traverse(Node node) {\n+\n+private void traverse(Node node) {\n     // The goal here is to avoid retraversing\n     // the entire AST to catch newly created opportunities.\n     // So we track whether a \"unit of code\" has changed,\n@@ -121,21 +122,20 @@ class PeepholeOptimizationsPass\n \n     int visits = 0;\n     do {\n-      Node c = node.getFirstChild();\n-      while(c != null) {\n+      Node next = null;\n+      for (Node c = node.getFirstChild(); c != null; c = next) {\n+        next = c.getNext();\n         traverse(c);\n-        Node next = c.getNext();\n-        c = next;\n       }\n-\n       visit(node);\n       visits++;\n \n-      Preconditions.checkState(visits < 10000, \"too many interations\");\n+      Preconditions.checkState(visits < 10000, \"too many iterations\");\n     } while (shouldRetraverse(node));\n \n     exitNode(node);\n-  }\n+}\n+\n \n   private boolean shouldRetraverse(Node node) {\n     if (node.getParent() != null && node.isFunction() || node.isScript()) {"}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      if (options.dependencyOptions.needsManagement()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77f..3756b998 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process."}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprotected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        scope.inferSlotType(\"this\", type);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..e196b985 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,7 +154,8 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n         scope.inferSlotType(node.getString(), type);\n@@ -169,13 +170,16 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n+      case Token.THIS:\n+        scope.inferSlotType(\"this\", type);\n+        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n             node.toStringTree());\n     }\n-  }\n+}\n+\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)"}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "21", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() || n.isComma()) {\n      return;\n    }\n\n    if (parent == null) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle\n    // these cases when we visit the child, and the peephole passes will\n    // fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) continue;\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {\n              if(!NodeUtil.isExpressionResultUsed(an))continue;\n          }\n          break;\n        }\n      }\n    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n        return;\n      }\n    }\n    if (\n        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n      String msg = \"This code lacks side-effects. Is there a bug?\";\n      if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n      } else if (isSimpleOp) {\n        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n            \"' operator is not being used.\";\n      }\n\n      t.getCompiler().report(\n          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n      // TODO(johnlenz): determine if it is necessary to\n      // try to protect side-effect free statements as well.\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..24e93528 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -81,13 +81,13 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n   }\n \n   @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n+\n+public void visit(NodeTraversal t, Node n, Node parent) {\n     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n     // I've been unable to think of any cases where this indicates a bug,\n     // and apparently some people like keeping these semicolons around,\n     // so we'll allow it.\n-    if (n.isEmpty() ||\n-        n.isComma()) {\n+    if (n.isEmpty() || n.isComma()) {\n       return;\n     }\n \n@@ -118,8 +118,10 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n           if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {\n+              if(!NodeUtil.isExpressionResultUsed(an))continue;\n+          }\n+          break;\n         }\n       }\n     } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n@@ -145,7 +147,8 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n         problemNodes.add(n);\n       }\n     }\n-  }\n+}\n+\n \n   /**\n    * Protect side-effect free nodes by making them parameters"}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "          options.dependencyOptions.needsManagement() &&", "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..3f255226 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+          options.dependencyOptions.needsManagement() &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they"}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "40", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\n    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Check if the node is an assignment or call\n      if (n.isAssign() || n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n\n        // Record class defining function calls\n        if (n.isCall() && ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n            refNodes.add(new ClassDefiningFunctionNode(\n                name, n, parent, parent.getParent()));\n          }\n        }\n      }\n    }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a9933..985883d2 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -593,6 +593,7 @@ final class NameAnalyzer implements CompilerPass {\n   private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n \n     @Override\n+\n     public void visit(NodeTraversal t, Node n, Node parent) {\n \n       // Record global variable and function declarations\n@@ -616,10 +617,9 @@ final class NameAnalyzer implements CompilerPass {\n         }\n       }\n \n-      // Record assignments and call sites\n-      if (n.isAssign()) {\n+      // Check if the node is an assignment or call\n+      if (n.isAssign() || n.isCall()) {\n         Node nameNode = n.getFirstChild();\n-\n         NameInformation ns = createNameInformation(t, nameNode, n);\n         if (ns != null) {\n           if (ns.isPrototype) {\n@@ -628,19 +628,19 @@ final class NameAnalyzer implements CompilerPass {\n             recordSet(ns.name, nameNode);\n           }\n         }\n-      } else if (n.isCall()) {\n-        Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n-        if (ns != null && ns.onlyAffectsClassDef) {\n+\n+        // Record class defining function calls\n+        if (n.isCall() && ns != null && ns.onlyAffectsClassDef) {\n           JsName name = getName(ns.name, false);\n           if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n+            refNodes.add(new ClassDefiningFunctionNode(\n+                name, n, parent, parent.getParent()));\n           }\n         }\n       }\n     }\n \n+\n     /**\n      * Records the assignment of a value to a global name.\n      *"}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "attempt": 17, "mode": "SL", "patch": "    return len > 0 && s.charAt(0) == '0' ? false : true;", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex ac6299d1..758c40a6 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) == '0' ? false : true;\n   }\n \n   static double getSimpleNumber(String s) {"}
{"project": "Closure", "bug_id": "53", "eval": "PASS", "attempt": 20, "mode": "SF", "patch": "\nprivate void replaceAssignmentExpression(Var v, Reference ref,\n                                         Map<String, String> varmap) {\n  // Compute all of the assignments necessary\n  List<Node> nodes = Lists.newArrayList();\n  Node val = ref.getAssignedValue();\n  blacklistVarReferencesInTree(val, v.scope);\n  Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n  Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n  for (Node key = val.getFirstChild(); key != null;\n       key = key.getNext()) {\n    String var = key.getString();\n    Node value = key.removeFirstChild();\n    // TODO(user): Copy type information.\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)), value));\n    all.remove(var);\n  }\n\n  // TODO(user): Better source information.\n  for (String var : all) {\n    nodes.add(\n      new Node(Token.ASSIGN,\n               Node.newString(Token.NAME, varmap.get(var)),\n               NodeUtil.newUndefinedNode(null)));\n  }\n\n  Node replacement;\n  // All assignments evaluate to true, so make sure that the\n  // expr statement evaluates to true in case it matters.\n  nodes.add(new Node(Token.TRUE));\n\n  // Join these using COMMA.  A COMMA node must have 2 children, so we\n  // create a tree. In the tree the first child be the COMMA to match\n  // the parser, otherwise tree equality tests fail.\n  nodes = Lists.reverse(nodes);\n  if(nodes.size() < 2) {\n    replacement = nodes.get(0);\n  } else {\n    replacement = new Node(Token.COMMA);\n    Node cur = replacement;\n    int i;\n    for (i = 0; i < nodes.size() - 2; i++) {\n      cur.addChildToFront(nodes.get(i));\n      Node t = new Node(Token.COMMA);\n      cur.addChildToFront(t);\n      cur = t;\n    }\n    cur.addChildToFront(nodes.get(i));\n    cur.addChildToFront(nodes.get(i + 1));\n  }\n\n  Node replace = ref.getParent();\n  replacement.copyInformationFromForTree(replace);\n\n  if (replace.getType() == Token.VAR) {\n    replace.getParent().replaceChild(\n        replace, NodeUtil.newExpr(replacement));\n  } else {\n    replace.getParent().replaceChild(replace, replacement);\n  }\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 9061925d..4586cd8e 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -300,64 +300,70 @@ class InlineObjectLiterals implements CompilerPass {\n      * Note that the resulting expression will always evaluate to\n      * true, as would the x = {...} expression.\n      */\n-    private void replaceAssignmentExpression(Var v, Reference ref,\n-                                             Map<String, String> varmap) {\n-      // Compute all of the assignments necessary\n-      List<Node> nodes = Lists.newArrayList();\n-      Node val = ref.getAssignedValue();\n-      blacklistVarReferencesInTree(val, v.scope);\n-      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n-      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n-      for (Node key = val.getFirstChild(); key != null;\n-           key = key.getNext()) {\n-        String var = key.getString();\n-        Node value = key.removeFirstChild();\n-        // TODO(user): Copy type information.\n-        nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)), value));\n-        all.remove(var);\n-      }\n-\n-      // TODO(user): Better source information.\n-      for (String var : all) {\n-        nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)),\n-                   NodeUtil.newUndefinedNode(null)));\n-      }\n \n-      Node replacement;\n-        // All assignments evaluate to true, so make sure that the\n-        // expr statement evaluates to true in case it matters.\n-        nodes.add(new Node(Token.TRUE));\n-\n-        // Join these using COMMA.  A COMMA node must have 2 children, so we\n-        // create a tree. In the tree the first child be the COMMA to match\n-        // the parser, otherwise tree equality tests fail.\n-        nodes = Lists.reverse(nodes);\n-        replacement = new Node(Token.COMMA);\n-        Node cur = replacement;\n-        int i;\n-        for (i = 0; i < nodes.size() - 2; i++) {\n-          cur.addChildToFront(nodes.get(i));\n-          Node t = new Node(Token.COMMA);\n-          cur.addChildToFront(t);\n-          cur = t;\n-        }\n-        cur.addChildToFront(nodes.get(i));\n-        cur.addChildToFront(nodes.get(i + 1));\n+private void replaceAssignmentExpression(Var v, Reference ref,\n+                                         Map<String, String> varmap) {\n+  // Compute all of the assignments necessary\n+  List<Node> nodes = Lists.newArrayList();\n+  Node val = ref.getAssignedValue();\n+  blacklistVarReferencesInTree(val, v.scope);\n+  Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n+  Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n+  for (Node key = val.getFirstChild(); key != null;\n+       key = key.getNext()) {\n+    String var = key.getString();\n+    Node value = key.removeFirstChild();\n+    // TODO(user): Copy type information.\n+    nodes.add(\n+      new Node(Token.ASSIGN,\n+               Node.newString(Token.NAME, varmap.get(var)), value));\n+    all.remove(var);\n+  }\n \n-      Node replace = ref.getParent();\n-      replacement.copyInformationFromForTree(replace);\n+  // TODO(user): Better source information.\n+  for (String var : all) {\n+    nodes.add(\n+      new Node(Token.ASSIGN,\n+               Node.newString(Token.NAME, varmap.get(var)),\n+               NodeUtil.newUndefinedNode(null)));\n+  }\n \n-      if (replace.getType() == Token.VAR) {\n-        replace.getParent().replaceChild(\n-            replace, NodeUtil.newExpr(replacement));\n-      } else {\n-        replace.getParent().replaceChild(replace, replacement);\n-      }\n+  Node replacement;\n+  // All assignments evaluate to true, so make sure that the\n+  // expr statement evaluates to true in case it matters.\n+  nodes.add(new Node(Token.TRUE));\n+\n+  // Join these using COMMA.  A COMMA node must have 2 children, so we\n+  // create a tree. In the tree the first child be the COMMA to match\n+  // the parser, otherwise tree equality tests fail.\n+  nodes = Lists.reverse(nodes);\n+  if(nodes.size() < 2) {\n+    replacement = nodes.get(0);\n+  } else {\n+    replacement = new Node(Token.COMMA);\n+    Node cur = replacement;\n+    int i;\n+    for (i = 0; i < nodes.size() - 2; i++) {\n+      cur.addChildToFront(nodes.get(i));\n+      Node t = new Node(Token.COMMA);\n+      cur.addChildToFront(t);\n+      cur = t;\n     }\n+    cur.addChildToFront(nodes.get(i));\n+    cur.addChildToFront(nodes.get(i + 1));\n+  }\n+\n+  Node replace = ref.getParent();\n+  replacement.copyInformationFromForTree(replace);\n+\n+  if (replace.getType() == Token.VAR) {\n+    replace.getParent().replaceChild(\n+        replace, NodeUtil.newExpr(replacement));\n+  } else {\n+    replace.getParent().replaceChild(replace, replacement);\n+  }\n+}\n+\n \n     /**\n      * Splits up the object literal into individual variables, and"}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "56", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\n  public String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    int newLinePos = js.indexOf('\\n', pos);\n    if (newLinePos == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then return the contents between pos and the end of file.\n      // 2. otherwise, it means this is a new file not having any new line.\n      if (pos == js.length()) {\n        return null;\n      } else {\n        return js.substring(pos);\n      }\n    } else {\n      return js.substring(pos, newLinePos);\n    }\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/SourceFile.java b/src/com/google/javascript/jscomp/SourceFile.java\nindex fc0cf3fc..b0c2a584 100644\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n@@ -202,6 +202,7 @@ public class SourceFile implements StaticSourceFile, Serializable {\n    *     of the file. Returns {@code null} if it does not exist,\n    *     or if there was an IO exception.\n    */\n+\n   public String getLine(int lineNumber) {\n     String js = \"\";\n     try {\n@@ -235,16 +236,22 @@ public class SourceFile implements StaticSourceFile, Serializable {\n     lastOffset = pos;\n     lastLine = lineNumber;\n \n-    if (js.indexOf('\\n', pos) == -1) {\n+    int newLinePos = js.indexOf('\\n', pos);\n+    if (newLinePos == -1) {\n       // If next new line cannot be found, there are two cases\n-      // 1. pos already reaches the end of file, then null should be returned\n-      // 2. otherwise, return the contents between pos and the end of file.\n+      // 1. pos already reaches the end of file, then return the contents between pos and the end of file.\n+      // 2. otherwise, it means this is a new file not having any new line.\n+      if (pos == js.length()) {\n         return null;\n+      } else {\n+        return js.substring(pos);\n+      }\n     } else {\n-      return js.substring(pos, js.indexOf('\\n', pos));\n+      return js.substring(pos, newLinePos);\n     }\n   }\n \n+\n   /**\n    * Get a region around the indicated line number. The exact definition of a\n    * region is implementation specific, but it must contain the line indicated"}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "if (target != null && target.getType() == Token.STRING) {", "diff": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex c507c924..4047bdbb 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,7 +194,7 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }"}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "61", "eval": "PASS", "attempt": 18, "mode": "SH", "patch": "\nif (nameNode.getType() == Token.NAME && nameNode.getString().equals(\"Math\")\n    || nameNode.getType() == Token.GETPROP\n    && (nameNode.getFirstChild().getType() == Token.NAME\n        && nameNode.getFirstChild().getString().equals(\"Math\")\n        || (nameNode.getLastChild().getString().equals(\"sin\")\n            || nameNode.getLastChild().getString().equals(\"cos\")\n            || nameNode.getLastChild().getString().equals(\"tan\")))) {\n  return false;\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 1844b18a..f0332376 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -956,6 +956,17 @@ public final class NodeUtil {\n \n       // Functions in the \"Math\" namespace have no side effects.\n \n+if (nameNode.getType() == Token.NAME && nameNode.getString().equals(\"Math\")\n+    || nameNode.getType() == Token.GETPROP\n+    && (nameNode.getFirstChild().getType() == Token.NAME\n+        && nameNode.getFirstChild().getString().equals(\"Math\")\n+        || (nameNode.getLastChild().getString().equals(\"sin\")\n+            || nameNode.getLastChild().getString().equals(\"cos\")\n+            || nameNode.getLastChild().getString().equals(\"tan\")))) {\n+  return false;\n+}\n+\n+\n       if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n         if (nameNode.getFirstChild().getType() == Token.REGEXP\n             && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {"}
{"project": "Closure", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "65", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "70", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "73", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "77", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "return evaluatesToLocalValue(value.getLastChild(), locals);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dd78f900..ae04b402 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,7 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+return evaluatesToLocalValue(value.getLastChild(), locals);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:"}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "          int indexOfDot = namespace.lastIndexOf('.');", "diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..1d738b52 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -786,7 +786,7 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n+          int indexOfDot = namespace.lastIndexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n             compiler.getNodeForCodeInsertion(minimumModule)"}
{"project": "Closure", "bug_id": "94", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "97", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n          result = (lvalInt & 0xFFFFFFFFL) >>> rvalInt;\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..e16d6e15 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,7 +695,9 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+\n+          result = (lvalInt & 0xFFFFFFFFL) >>> rvalInt;\n+\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +"}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "101", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\n  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    if (!flags.process_closure_primitives) {\n      // If this is not set, we assume it is \"false\" (i.e., don't process \n      // primitives) unless it has been otherwise set. This means the default\n      // behavior is to not process primitives if the flag is unset.\n      options.closurePass = false;\n    }\n\n    initOptionsFromFlags(options);\n    return options;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CommandLineRunner.java b/src/com/google/javascript/jscomp/CommandLineRunner.java\nindex bdf55921..a6359717 100644\n--- a/src/com/google/javascript/jscomp/CommandLineRunner.java\n+++ b/src/com/google/javascript/jscomp/CommandLineRunner.java\n@@ -416,6 +416,7 @@ public class CommandLineRunner extends\n   }\n \n   @Override\n+\n   protected CompilerOptions createOptions() {\n     CompilerOptions options = new CompilerOptions();\n     options.setCodingConvention(new ClosureCodingConvention());\n@@ -430,14 +431,18 @@ public class CommandLineRunner extends\n     for (FormattingOption formattingOption : flags.formatting) {\n       formattingOption.applyToOptions(options);\n     }\n-    if (flags.process_closure_primitives) {\n-      options.closurePass = true;\n+    if (!flags.process_closure_primitives) {\n+      // If this is not set, we assume it is \"false\" (i.e., don't process \n+      // primitives) unless it has been otherwise set. This means the default\n+      // behavior is to not process primitives if the flag is unset.\n+      options.closurePass = false;\n     }\n \n     initOptionsFromFlags(options);\n     return options;\n   }\n \n+\n   @Override\n   protected Compiler createCompiler() {\n     return new Compiler(getErrorPrintStream());"}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "104", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "119", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "case Token.CATCH:", "diff": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 639318df..27c3ff3b 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -363,6 +363,7 @@ class GlobalNamespace\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n+case Token.CATCH:\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;"}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "122", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprivate boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    Node tempNode = node; // Create a temporary variable to avoid side-effect\n    while (tempNode != null) {\n      if (tempNode.isName()\n          && isNameAssignedTo(tempNode.getString(), replacement)) {\n        return false;\n      }\n      tempNode = tempNode.getFirstChild();\n    }\n\n    return true;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/ExploitAssigns.java b/src/com/google/javascript/jscomp/ExploitAssigns.java\nindex 0f03e355..d4345a25 100644\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n@@ -203,22 +203,27 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n    * changed.\n    * @return Whether the replacement can be made.\n    */\n-  private boolean isSafeReplacement(Node node, Node replacement) {\n+\n+private boolean isSafeReplacement(Node node, Node replacement) {\n     // No checks are needed for simple names.\n     if (node.isName()) {\n       return true;\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n-      return false;\n+    Node tempNode = node; // Create a temporary variable to avoid side-effect\n+    while (tempNode != null) {\n+      if (tempNode.isName()\n+          && isNameAssignedTo(tempNode.getString(), replacement)) {\n+        return false;\n+      }\n+      tempNode = tempNode.getFirstChild();\n     }\n \n     return true;\n   }\n \n+\n   /**\n    * @return Whether name is assigned in the expression rooted at node.\n    */\n@@ -241,4 +246,4 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n \n     return false;\n   }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Closure", "bug_id": "125", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "attempt": 7, "mode": "SH", "patch": "\nif (NodeUtil.hasFinally(n)) {\n  // Don't try to minimize the exits of finally blocks, as this\n  // can cause problems if it changes the completion type of the finally\n  // block. See ECMA 262 Sections 8.9 & 12.14\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..6ccdcdef 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,13 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+\n+if (NodeUtil.hasFinally(n)) {\n+  // Don't try to minimize the exits of finally blocks, as this\n+  // can cause problems if it changes the completion type of the finally\n+  // block. See ECMA 262 Sections 8.9 & 12.14\n+}\n+\n     }\n \n     // Just a 'label'."}
{"project": "Closure", "bug_id": "128", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n  static boolean isSimpleNumber(String s) {\n    if (s.isEmpty()) {\n      return false;\n    }\n    if (s.charAt(0) == '0') {\n      return s.equals(\"0\");\n    }\n    for (int index = 1; index < s.length(); index++) {\n      char c = s.charAt(index);\n      if (c < '0' || c > '9') {\n        return false;\n      }\n    }\n    return true;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 2270c172..b12b2d82 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -780,17 +780,24 @@ class CodeGenerator {\n     } while (current != n);\n   }\n \n+\n   static boolean isSimpleNumber(String s) {\n-    int len = s.length();\n-    for (int index = 0; index < len; index++) {\n+    if (s.isEmpty()) {\n+      return false;\n+    }\n+    if (s.charAt(0) == '0') {\n+      return s.equals(\"0\");\n+    }\n+    for (int index = 1; index < s.length(); index++) {\n       char c = s.charAt(index);\n       if (c < '0' || c > '9') {\n         return false;\n       }\n     }\n-    return len > 0 && s.charAt(0) != '0';\n+    return true;\n   }\n \n+\n   static double getSimpleNumber(String s) {\n     if (isSimpleNumber(s)) {\n       try {"}
{"project": "Closure", "bug_id": "129", "eval": "PASS", "attempt": 12, "mode": "SH", "patch": "\n      if (first == null)\n        return; // Handle null case\n\n      // ignore cast nodes.\n      if (first.isCast())\n        first = first.getFirstChild();\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex d993bee7..9575b819 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -164,6 +164,14 @@ class PrepareAst implements CompilerPass {\n \n       // ignore cast nodes.\n \n+      if (first == null)\n+        return; // Handle null case\n+\n+      // ignore cast nodes.\n+      if (first.isCast())\n+        first = first.getFirstChild();\n+\n+\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n       }"}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic static boolean isJSIdentifier(String s) {\n  return s.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*$\");\n}\n", "diff": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex 144a4adc..6c6863e7 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -187,21 +187,9 @@ public class TokenStream {\n         return id;\n     }\n \n-    public static boolean isJSIdentifier(String s) {\n-      int length = s.length();\n \n-      if (length == 0 ||\n-          !Character.isJavaIdentifierStart(s.charAt(0))) {\n-        return false;\n-      }\n-\n-      for (int i = 1; i < length; i++) {\n-        if (\n-            !Character.isJavaIdentifierPart(s.charAt(i))) {\n-          return false;\n-        }\n-      }\n+public static boolean isJSIdentifier(String s) {\n+  return s.matches(\"^[a-zA-Z_$][a-zA-Z_$0-9]*$\");\n+}\n \n-      return true;\n-    }\n }"}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "152", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      if (t.getScopeDepth() <= 1) {", "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..36f83466 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1993,7 +1993,7 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+      if (t.getScopeDepth() <= 1) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")"}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "3", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "} else if (contains(value, index + 1, 3, \"IER\")) {", "diff": "diff --git a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\nindex e2b8e110..985825cb 100644\n--- a/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n+++ b/src/java/org/apache/commons/codec/language/DoubleMetaphone.java\n@@ -452,7 +452,7 @@ public class DoubleMetaphone implements StringEncoder {\n             if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) {\n                 //-- obvious germanic --//\n                 result.append('K');\n-            } else if (contains(value, index + 1, 4, \"IER\")) {\n+} else if (contains(value, index + 1, 3, \"IER\")) {\n                 result.append('J');\n             } else {\n                 result.append('J', 'K');"}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "5", "eval": "PASS", "attempt": 7, "mode": "SH", "patch": "\nif (buffer == null || buffer.length - pos < 2) {\n    resizeBuffer();\n}\n", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 2618e5d5..56ce5b92 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -583,6 +583,11 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n         // EOF (-1) and first time '=' character is encountered in stream.\n         // This approach makes the '=' padding characters completely optional.\n         if (eof && modulus != 0) {\n+\n+if (buffer == null || buffer.length - pos < 2) {\n+    resizeBuffer();\n+}\n+\n             \n             x = x << 6;\n             switch (modulus) {"}
{"project": "Codec", "bug_id": "6", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        int readLen = 0;\n        while (readLen == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            }\n            readLen = base64.readResults(b, offset, len);\n        }\n        return readLen;\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex 583a5847..b8fe8e7c 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -135,49 +135,39 @@ public class Base64InputStream extends FilterInputStream {\n      * @throws IndexOutOfBoundsException\n      *             if offset, len or buffer size are invalid\n      */\n-    public int read(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return 0;\n-        } else {\n-            /*\n-             Rationale for while-loop on (readLen == 0):\n-             -----\n-             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n-             rare case where it returns 0, we just keep trying.\n \n-             This is essentially an undocumented contract for InputStream\n-             implementors that want their code to work properly with\n-             java.io.InputStreamReader, since the latter hates it when\n-             InputStream.read(byte[]) returns a zero.  Unfortunately our\n-             readResults() call must return 0 if a large amount of the data\n-             being decoded was non-base64, so this while-loop enables proper\n-             interop with InputStreamReader for that scenario.\n-             -----\n-             This is a fix for CODEC-101\n-            */\n-                if (!base64.hasData()) {\n-                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                    int c = in.read(buf);\n-                    // A little optimization to avoid System.arraycopy()\n-                    // when possible.\n-                    if (c > 0 && b.length == len) {\n-                        base64.setInitialBuffer(b, offset, len);\n-                    }\n-                    if (doEncode) {\n-                        base64.encode(buf, 0, c);\n-                    } else {\n-                        base64.decode(buf, 0, c);\n-                    }\n+public int read(byte b[], int offset, int len) throws IOException {\n+    if (b == null) {\n+        throw new NullPointerException();\n+    } else if (offset < 0 || len < 0) {\n+        throw new IndexOutOfBoundsException();\n+    } else if (offset > b.length || offset + len > b.length) {\n+        throw new IndexOutOfBoundsException();\n+    } else if (len == 0) {\n+        return 0;\n+    } else {\n+        int readLen = 0;\n+        while (readLen == 0) {\n+            if (!base64.hasData()) {\n+                byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                int c = in.read(buf);\n+                // A little optimization to avoid System.arraycopy()\n+                // when possible.\n+                if (c > 0 && b.length == len) {\n+                    base64.setInitialBuffer(b, offset, len);\n                 }\n-            return base64.readResults(b, offset, len);\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n+                }\n+            }\n+            readLen = base64.readResults(b, offset, len);\n         }\n+        return readLen;\n     }\n+}\n+\n \n     /**\n      * {@inheritDoc}"}
{"project": "Codec", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : CHUNK_SEPARATOR.length, CHUNK_SEPARATOR);", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 2cd0163b..4fa4fec4 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -824,7 +824,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : CHUNK_SEPARATOR.length, CHUNK_SEPARATOR);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +"}
{"project": "Codec", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 5b14ca0c..9ca695b9 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -336,7 +336,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**"}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return cs1.toString().equals(cs2.toString());", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex bef55f70..ac548e30 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -78,7 +78,7 @@ public class StringUtils {\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+        return cs1.toString().equals(cs2.toString());\n     }\n \n     /**"}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "11", "eval": "PASS", "attempt": 14, "mode": "SF", "patch": "\npublic ArchiveInputStream createArchiveInputStream(final InputStream in)\n        throws ArchiveException {\n    if (in == null) {\n        throw new IllegalArgumentException(\"Stream must not be null.\");\n    }\n\n    if (!in.markSupported()) {\n        throw new IllegalArgumentException(\"Mark is not supported.\");\n    }\n\n    final byte[] signature = new byte[12];\n    in.mark(signature.length);\n    try {\n        int signatureLength = in.read(signature);\n        in.reset();\n        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n            return new ZipArchiveInputStream(in);\n        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n            return new JarArchiveInputStream(in);\n        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n            return new ArArchiveInputStream(in);\n        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n            return new CpioArchiveInputStream(in);\n        }\n\n        // Dump needs a bigger buffer to check the signature;\n        final byte[] dumpsig = new byte[32];\n        in.mark(dumpsig.length);\n        signatureLength = in.read(dumpsig);\n        in.reset();\n        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n            return new DumpArchiveInputStream(in);\n        }\n\n        // Tar needs an even bigger buffer to check the signature; read some bytes to see if it's tar\n        final byte[] tarheader = new byte[512];\n        in.mark(tarheader.length);\n        signatureLength = in.read(tarheader);\n        in.reset();\n        // Check if it's a tar header, but only if it's a full 512 bytes\n        if (signatureLength == 512) {\n            if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                return new TarArchiveInputStream(in);\n            }\n            // COMPRESS-117 - improve auto-recognition\n            try {\n                TarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\n                tais.getNextEntry();\n                return new TarArchiveInputStream(in);\n            } catch (Exception e) { // NOPMD\n                // can generate IllegalArgumentException as well as IOException\n                // autodetection, simply not a TAR\n                // ignored\n            }\n        }\n    } catch (IOException e) {\n        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n    }\n\n    throw new ArchiveException(\"No Archiver found for the stream signature\");\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\nindex a30cd5a8..e82e2b13 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/ArchiveStreamFactory.java\n@@ -194,45 +194,48 @@ public class ArchiveStreamFactory {\n      * @throws ArchiveException if the archiver name is not known\n      * @throws IllegalArgumentException if the stream is null or does not support mark\n      */\n-    public ArchiveInputStream createArchiveInputStream(final InputStream in)\n-            throws ArchiveException {\n-        if (in == null) {\n-            throw new IllegalArgumentException(\"Stream must not be null.\");\n-        }\n-\n-        if (!in.markSupported()) {\n-            throw new IllegalArgumentException(\"Mark is not supported.\");\n-        }\n-\n-        final byte[] signature = new byte[12];\n-        in.mark(signature.length);\n-        try {\n-            int signatureLength = in.read(signature);\n-            in.reset();\n-            if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n-                return new ZipArchiveInputStream(in);\n-            } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n-                return new JarArchiveInputStream(in);\n-            } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n-                return new ArArchiveInputStream(in);\n-            } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n-                return new CpioArchiveInputStream(in);\n-            }\n \n-            // Dump needs a bigger buffer to check the signature;\n-            final byte[] dumpsig = new byte[32];\n-            in.mark(dumpsig.length);\n-            signatureLength = in.read(dumpsig);\n-            in.reset();\n-            if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n-                return new DumpArchiveInputStream(in);\n-            }\n+public ArchiveInputStream createArchiveInputStream(final InputStream in)\n+        throws ArchiveException {\n+    if (in == null) {\n+        throw new IllegalArgumentException(\"Stream must not be null.\");\n+    }\n+\n+    if (!in.markSupported()) {\n+        throw new IllegalArgumentException(\"Mark is not supported.\");\n+    }\n+\n+    final byte[] signature = new byte[12];\n+    in.mark(signature.length);\n+    try {\n+        int signatureLength = in.read(signature);\n+        in.reset();\n+        if (ZipArchiveInputStream.matches(signature, signatureLength)) {\n+            return new ZipArchiveInputStream(in);\n+        } else if (JarArchiveInputStream.matches(signature, signatureLength)) {\n+            return new JarArchiveInputStream(in);\n+        } else if (ArArchiveInputStream.matches(signature, signatureLength)) {\n+            return new ArArchiveInputStream(in);\n+        } else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\n+            return new CpioArchiveInputStream(in);\n+        }\n+\n+        // Dump needs a bigger buffer to check the signature;\n+        final byte[] dumpsig = new byte[32];\n+        in.mark(dumpsig.length);\n+        signatureLength = in.read(dumpsig);\n+        in.reset();\n+        if (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\n+            return new DumpArchiveInputStream(in);\n+        }\n \n-            // Tar needs an even bigger buffer to check the signature; read the first block\n-            final byte[] tarheader = new byte[512];\n-            in.mark(tarheader.length);\n-            signatureLength = in.read(tarheader);\n-            in.reset();\n+        // Tar needs an even bigger buffer to check the signature; read some bytes to see if it's tar\n+        final byte[] tarheader = new byte[512];\n+        in.mark(tarheader.length);\n+        signatureLength = in.read(tarheader);\n+        in.reset();\n+        // Check if it's a tar header, but only if it's a full 512 bytes\n+        if (signatureLength == 512) {\n             if (TarArchiveInputStream.matches(tarheader, signatureLength)) {\n                 return new TarArchiveInputStream(in);\n             }\n@@ -246,10 +249,12 @@ public class ArchiveStreamFactory {\n                 // autodetection, simply not a TAR\n                 // ignored\n             }\n-        } catch (IOException e) {\n-            throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n         }\n-\n-        throw new ArchiveException(\"No Archiver found for the stream signature\");\n+    } catch (IOException e) {\n+        throw new ArchiveException(\"Could not use reset and mark operations.\", e);\n     }\n+\n+    throw new ArchiveException(\"No Archiver found for the stream signature\");\n+}\n+\n }"}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "if (rawCentralDirectoryData.length < expectedLength) {", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\nindex 134871be..4344cef6 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java\n@@ -256,7 +256,7 @@ public class Zip64ExtendedInformationExtraField implements ZipExtraField {\n                 + (hasCompressedSize ? DWORD : 0)\n                 + (hasRelativeHeaderOffset ? DWORD : 0)\n                 + (hasDiskStart ? WORD : 0);\n-            if (rawCentralDirectoryData.length != expectedLength) {\n+if (rawCentralDirectoryData.length < expectedLength) {\n                 throw new ZipException(\"central directory zip64 extended\"\n                                        + \" information extra field's length\"\n                                        + \" doesn't match central directory\""}
{"project": "Compress", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (start == end - 1) { // Adjusted this to check if we're at the last byte\n            if (trailer < '0' || trailer > '7'){\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, trailer));\n            }\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 4cf32d6f..89f4fed7 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -130,11 +130,15 @@ public class TarUtils {\n             end--;\n             trailer = buffer[end - 1];\n         }\n-        if (start == end) {\n-            throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, start, trailer));\n+\n+        if (start == end - 1) { // Adjusted this to check if we're at the last byte\n+            if (trailer < '0' || trailer > '7'){\n+                throw new IllegalArgumentException(\n+                        exceptionMessage(buffer, offset, length, start, trailer));\n+            }\n         }\n \n+\n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n             // CheckStyle:MagicNumber OFF"}
{"project": "Compress", "bug_id": "28", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\npublic int read(byte[] buf, int offset, int numToRead) throws IOException {\n    int totalRead = 0;\n\n    if (hasHitEOF || entryOffset >= entrySize) {\n        if (entryOffset < entrySize) {\n            throw new IOException(\"Truncated tar entry\");\n        } else {\n            return -1;\n        }\n    }\n\n    if (currEntry == null) {\n        throw new IllegalStateException(\"No current tar entry\");\n    }\n\n    numToRead = Math.min(numToRead, available());\n\n    totalRead = is.read(buf, offset, numToRead);\n    if (totalRead == -1 && entryOffset < entrySize) {\n        throw new IOException(\"Truncated tar entry\");\n    }\n    count(totalRead);\n    \n    if (totalRead == -1) {\n        hasHitEOF = true;\n    } else {\n        entryOffset += totalRead;\n    }\n\n    return totalRead;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex fe2c1133..1580764c 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -566,31 +566,40 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n      * @throws IOException on error\n      */\n     @Override\n-    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n-    \tint totalRead = 0;\n \n-        if (hasHitEOF || entryOffset >= entrySize) {\n+public int read(byte[] buf, int offset, int numToRead) throws IOException {\n+    int totalRead = 0;\n+\n+    if (hasHitEOF || entryOffset >= entrySize) {\n+        if (entryOffset < entrySize) {\n+            throw new IOException(\"Truncated tar entry\");\n+        } else {\n             return -1;\n         }\n+    }\n \n-        if (currEntry == null) {\n-            throw new IllegalStateException(\"No current tar entry\");\n-        }\n+    if (currEntry == null) {\n+        throw new IllegalStateException(\"No current tar entry\");\n+    }\n \n-        numToRead = Math.min(numToRead, available());\n-        \n-        totalRead = is.read(buf, offset, numToRead);\n-        count(totalRead);\n-        \n-        if (totalRead == -1) {\n-            hasHitEOF = true;\n-        } else {\n-            entryOffset += totalRead;\n-        }\n+    numToRead = Math.min(numToRead, available());\n \n-        return totalRead;\n+    totalRead = is.read(buf, offset, numToRead);\n+    if (totalRead == -1 && entryOffset < entrySize) {\n+        throw new IOException(\"Truncated tar entry\");\n+    }\n+    count(totalRead);\n+    \n+    if (totalRead == -1) {\n+        hasHitEOF = true;\n+    } else {\n+        entryOffset += totalRead;\n     }\n \n+    return totalRead;\n+}\n+\n+\n     /**\n      * Whether this class is able to read the given entry.\n      *"}
{"project": "Compress", "bug_id": "30", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\nif (len == 0) {\n    return 0;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\nindex e0e3b1ec..a76522f1 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n@@ -166,6 +166,11 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n             throw new IOException(\"stream closed\");\n         }\n \n+if (len == 0) {\n+    return 0;\n+}\n+\n+\n         final int hi = offs + len;\n         int destOffs = offs;\n         int b;"}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "attempt": 6, "mode": "SH", "patch": "\n            if (currentByte < '0' || currentByte > '7' || currentByte == '\\0') {\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 40e7871f..926521b3 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -132,9 +132,12 @@ public class TarUtils {\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n-            if (currentByte == 0) {\n-                break;\n+\n+            if (currentByte < '0' || currentByte > '7' || currentByte == '\\0') {\n+                throw new IllegalArgumentException(\n+                        exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n+\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException("}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprivate void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    for (Entry<String, String> ent : headers.entrySet()) {\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)) {\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)) {\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)) {\n            currEntry.setGroupId(Long.parseLong(val));\n        } else if (\"gname\".equals(key)) {\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)) {\n            currEntry.setUserId(Long.parseLong(val));\n        } else if (\"uname\".equals(key)) {\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)) {\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)) {\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)) {\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)) {\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex c5570071..fa8b93c4 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -478,44 +478,35 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n         return headers;\n     }\n \n-    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n-        /*\n-         * The following headers are defined for Pax.\n-         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n-         * mtime\n-         * comment\n-         * gid, gname\n-         * linkpath\n-         * size\n-         * uid,uname\n-         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n-         */\n-        for (Entry<String, String> ent : headers.entrySet()){\n-            String key = ent.getKey();\n-            String val = ent.getValue();\n-            if (\"path\".equals(key)){\n-                currEntry.setName(val);\n-            } else if (\"linkpath\".equals(key)){\n-                currEntry.setLinkName(val);\n-            } else if (\"gid\".equals(key)){\n-                currEntry.setGroupId(Integer.parseInt(val));\n-            } else if (\"gname\".equals(key)){\n-                currEntry.setGroupName(val);\n-            } else if (\"uid\".equals(key)){\n-                currEntry.setUserId(Integer.parseInt(val));\n-            } else if (\"uname\".equals(key)){\n-                currEntry.setUserName(val);\n-            } else if (\"size\".equals(key)){\n-                currEntry.setSize(Long.parseLong(val));\n-            } else if (\"mtime\".equals(key)){\n-                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n-            } else if (\"SCHILY.devminor\".equals(key)){\n-                currEntry.setDevMinor(Integer.parseInt(val));\n-            } else if (\"SCHILY.devmajor\".equals(key)){\n-                currEntry.setDevMajor(Integer.parseInt(val));\n-            }\n+\n+private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n+    for (Entry<String, String> ent : headers.entrySet()) {\n+        String key = ent.getKey();\n+        String val = ent.getValue();\n+        if (\"path\".equals(key)) {\n+            currEntry.setName(val);\n+        } else if (\"linkpath\".equals(key)) {\n+            currEntry.setLinkName(val);\n+        } else if (\"gid\".equals(key)) {\n+            currEntry.setGroupId(Long.parseLong(val));\n+        } else if (\"gname\".equals(key)) {\n+            currEntry.setGroupName(val);\n+        } else if (\"uid\".equals(key)) {\n+            currEntry.setUserId(Long.parseLong(val));\n+        } else if (\"uname\".equals(key)) {\n+            currEntry.setUserName(val);\n+        } else if (\"size\".equals(key)) {\n+            currEntry.setSize(Long.parseLong(val));\n+        } else if (\"mtime\".equals(key)) {\n+            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n+        } else if (\"SCHILY.devminor\".equals(key)) {\n+            currEntry.setDevMinor(Integer.parseInt(val));\n+        } else if (\"SCHILY.devmajor\".equals(key)) {\n+            currEntry.setDevMajor(Integer.parseInt(val));\n         }\n     }\n+}\n+\n \n     /**\n      * Adds the sparse chunks from the current entry to the sparse chunks,"}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "38", "eval": "PASS", "attempt": 17, "mode": "SL", "patch": "if (file != null && file.getName().endsWith(\"/\")) {", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\nindex 941bbbd3..f9873dc2 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java\n@@ -856,7 +856,7 @@ public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n             return true;\n         }\n \n-        if (getName().endsWith(\"/\")) {\n+if (file != null && file.getName().endsWith(\"/\")) {\n             return true;\n         }\n \n@@ -1250,4 +1250,3 @@ public class TarArchiveEntry implements TarConstants, ArchiveEntry {\n         }\n     }\n }\n-"}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if (checksum == null || in == null) {\n            throw new NullPointerException(\"Either checksum or input stream cannot be null\");\n        }\n\n        this.checksum = checksum;\n        this.in = in;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\nindex 10c7d68d..eafcadff 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n@@ -30,14 +30,17 @@ public class ChecksumCalculatingInputStream extends InputStream {\n     private final InputStream in;\n     private final Checksum checksum;\n \n-    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n-\n \n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        if (checksum == null || in == null) {\n+            throw new NullPointerException(\"Either checksum or input stream cannot be null\");\n+        }\n \n         this.checksum = checksum;\n         this.in = in;\n     }\n \n+\n     /**\n      * Reads a single byte from the stream\n      * @throws IOException if the underlying stream throws or the"}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic static int formatLongOctalOrBinaryBytes(\n    final long value, final byte[] buf, final int offset, final int length) {\n\n    // Check whether we are dealing with UID/GID or SIZE field\n    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n    final boolean negative = value < 0;\n    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n        return formatLongOctalBytes(value, buf, offset, length);\n    }\n\n    if (length < 9) { // Less than 9 bytes means we can store as binary at most\n        formatLongBinary(value, buf, offset, length, negative);\n    } else { // More than 8 bytes means we will always have to use binary\n        formatBigIntegerBinary(value, buf, offset, length, negative);\n    }\n\n    buf[offset] = (byte) (negative ? 0xff : 0x80);\n    return offset + length;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 39ce5c1a..02c0cfce 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -471,26 +471,29 @@ public static int formatLongOctalBytes(final long value, final byte[] buf, final\n      * will not fit in the buffer.\n      * @since 1.4\n      */\n-    public static int formatLongOctalOrBinaryBytes(\n-        final long value, final byte[] buf, final int offset, final int length) {\n \n-        // Check whether we are dealing with UID/GID or SIZE field\n-        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n+public static int formatLongOctalOrBinaryBytes(\n+    final long value, final byte[] buf, final int offset, final int length) {\n \n-        final boolean negative = value < 0;\n-        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n-            return formatLongOctalBytes(value, buf, offset, length);\n-        }\n+    // Check whether we are dealing with UID/GID or SIZE field\n+    final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n \n-        if (length < 9) {\n-            formatLongBinary(value, buf, offset, length, negative);\n-        }\n-        formatBigIntegerBinary(value, buf, offset, length, negative);\n+    final boolean negative = value < 0;\n+    if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n+        return formatLongOctalBytes(value, buf, offset, length);\n+    }\n \n-        buf[offset] = (byte) (negative ? 0xff : 0x80);\n-        return offset + length;\n+    if (length < 9) { // Less than 9 bytes means we can store as binary at most\n+        formatLongBinary(value, buf, offset, length, negative);\n+    } else { // More than 8 bytes means we will always have to use binary\n+        formatBigIntegerBinary(value, buf, offset, length, negative);\n     }\n \n+    buf[offset] = (byte) (negative ? 0xff : 0x80);\n+    return offset + length;\n+}\n+\n+\n     private static void formatLongBinary(final long value, final byte[] buf,\n                                          final int offset, final int length,\n                                          final boolean negative) {"}
{"project": "Compress", "bug_id": "46", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer index = mapping.get(name);\n    if (index == null) {\n        return null;\n    }\n    if (index < 0 || index >= values.length) {\n        throw new IllegalArgumentException(\"Invalid value index: \" + index);\n    }\n    return values[index.intValue()];\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex dc52017..d162420 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -76,14 +76,22 @@ public class CSVRecord implements Serializable, Iterable<String> {\n      *             if the record is inconsistent\n      * @see #isConsistent()\n      */\n-    public String get(final String name) {\n-        if (mapping == null) {\n-            throw new IllegalStateException(\n-                    \"No header mapping was specified, the record values can't be accessed by name\");\n-        }\n-        final Integer index = mapping.get(name);\n-            return index != null ? values[index.intValue()] : null;\n+\n+public String get(final String name) {\n+    if (mapping == null) {\n+        throw new IllegalStateException(\n+                \"No header mapping was specified, the record values can't be accessed by name\");\n+    }\n+    final Integer index = mapping.get(name);\n+    if (index == null) {\n+        return null;\n+    }\n+    if (index < 0 || index >= values.length) {\n+        throw new IllegalArgumentException(\"Invalid value index: \" + index);\n     }\n+    return values[index.intValue()];\n+}\n+\n \n     /**\n      * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to"}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "        return headerMap;", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 9d56f1a..37256c5 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -285,7 +285,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+        return headerMap;\n     }\n \n     /**"}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    if (recordSeparator != null) {\n        out.append(recordSeparator);\n    } else {\n        // If recordSeparator is null, a default value can be specified\n        // For this example, let's use an empty string.\n        out.append(\"\");\n    }\n    newRecord = true;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex 3255360..bf03185 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -320,11 +320,19 @@ public final class CSVPrinter implements Flushable, Closeable {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n-    public void println() throws IOException {\n-        final String recordSeparator = format.getRecordSeparator();\n-            out.append(recordSeparator);\n-        newRecord = true;\n+\n+public void println() throws IOException {\n+    final String recordSeparator = format.getRecordSeparator();\n+    if (recordSeparator != null) {\n+        out.append(recordSeparator);\n+    } else {\n+        // If recordSeparator is null, a default value can be specified\n+        // For this example, let's use an empty string.\n+        out.append(\"\");\n     }\n+    newRecord = true;\n+}\n+\n \n     /**\n      * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine"}
{"project": "Csv", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "final boolean emptyHeader = header == null || header.trim().isEmpty();", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex b6867a4..347766d 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -381,7 +381,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+final boolean emptyHeader = header == null || header.trim().isEmpty();\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));"}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "                if (c <= COMMENT || c == LF || c == CR) {", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35ee86a..0b15811 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1036,7 +1036,7 @@ public final class CSVFormat implements Serializable {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                if (c <= COMMENT || c == LF || c == CR) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now"}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n                if (newRecord && (c < 0x20 || c == 0x7E || c >= 0x22 && c <= 0x2B || c == 0x2D)) {\n                    quote = true;\n                } else if (c <= COMMENT) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35c2ad1..4b31f41 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1186,9 +1186,11 @@ public final class CSVFormat implements Serializable {\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n+\n+                if (newRecord && (c < 0x20 || c == 0x7E || c >= 0x22 && c <= 0x2B || c == 0x2D)) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n+\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too."}
{"project": "Gson", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "12", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n@Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      pathNames[stackSize - 2] = \"null\";\n      pathIndices[stackSize - 2]++; // increment the correct index\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n        pathIndices[stackSize - 1]++; // increment the correct index\n      }\n    }\n    if(stackSize > 1) {\n        pathIndices[stackSize - 2]++; // increment the correct index\n    }\n}\n", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\nindex 2e7644f0..df8448aa 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n@@ -253,16 +253,24 @@ public final class JsonTreeReader extends JsonReader {\n     stackSize = 1;\n   }\n \n-  @Override public void skipValue() throws IOException {\n+\n+@Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n       nextName();\n       pathNames[stackSize - 2] = \"null\";\n+      pathIndices[stackSize - 2]++; // increment the correct index\n     } else {\n       popStack();\n+      if (stackSize > 0) {\n         pathNames[stackSize - 1] = \"null\";\n+        pathIndices[stackSize - 1]++; // increment the correct index\n+      }\n     }\n-      pathIndices[stackSize - 1]++;\n-  }\n+    if(stackSize > 1) {\n+        pathIndices[stackSize - 2]++; // increment the correct index\n+    }\n+}\n+\n \n   @Override public String toString() {\n     return getClass().getSimpleName();"}
{"project": "Gson", "bug_id": "13", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && value != 0) {", "diff": "diff --git a/gson/src/main/java/com/google/gson/stream/JsonReader.java b/gson/src/main/java/com/google/gson/stream/JsonReader.java\nindex 877742bf..278efa15 100644\n--- a/gson/src/main/java/com/google/gson/stream/JsonReader.java\n+++ b/gson/src/main/java/com/google/gson/stream/JsonReader.java\n@@ -728,7 +728,7 @@ public class JsonReader implements Closeable {\n     }\n \n     // We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\n-    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\n+    if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative) && value != 0) {\n       peekedLong = negative ? value : -value;\n       pos += i;\n       return peeked = PEEKED_LONG;"}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "attempt": 14, "mode": "SF", "patch": "\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above intended maximum, slow to increase by 25%\n        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN * 2) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex f97a083f..f2f36858 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -577,16 +577,18 @@ public final class TextBuffer\n      * accommodate for more contiguous content. Usually only\n      * used when parsing tokens like names if even then.\n      */\n+\n     public char[] expandCurrentSegment()\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n         // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN * 2) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n+\n     /**\n      * Method called to expand size of the current segment, to\n      * accommodate for more contiguous content. Usually only"}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "char c = str.charAt(i);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\nindex d353b392..13967afc 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n@@ -190,7 +190,7 @@ public class JsonPointer\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }"}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        if (!_hasSegments)  return contentsAsArray();", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex e6f1cbc5..2f34252a 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -295,6 +295,7 @@ public final class TextBuffer\n         return true;\n     }\n     \n+\n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n@@ -304,7 +305,7 @@ public final class TextBuffer\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments)  return contentsAsArray();\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }"}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "            if (i < maxCode) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex 2c1f5a23..f38e4aae 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -1960,7 +1960,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+            if (i < maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }"}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "attempt": 18, "mode": "SL", "patch": "        return ((previous != null) && previous.equals(ann)) || _annotations.containsKey(ann.annotationType());", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\nindex f9cc5cb19..13689c4bc 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java\n@@ -109,8 +109,6 @@ public final class AnnotationMap implements Annotations\n             _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n         }\n         Annotation previous = _annotations.put(ann.annotationType(), ann);\n-        return (previous != null) && previous.equals(ann);\n+        return ((previous != null) && previous.equals(ann)) || _annotations.containsKey(ann.annotationType());\n     }\n }\n-\n-"}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "PASS", "attempt": 11, "mode": "SF", "patch": "\npublic BaseSettings withDateFormat(DateFormat df) {\n    if (_dateFormat == df) {\n        return this;\n    }\n    TimeZone tz = _timeZone; // Use the existing TimeZone regardless of df\n    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n            _typeResolverBuilder, df, _handlerInstantiator, _locale,\n            tz, _defaultBase64);\n}\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\nindex cd2da6187..80b99c17a 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/cfg/BaseSettings.java\n@@ -227,15 +227,18 @@ public final class BaseSettings\n                 _timeZone, _defaultBase64);\n     }\n     \n-    public BaseSettings withDateFormat(DateFormat df) {\n-        if (_dateFormat == df) {\n-            return this;\n-        }\n-        TimeZone tz = (df == null) ? _timeZone : df.getTimeZone();\n-        return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n-                _typeResolverBuilder, df, _handlerInstantiator, _locale,\n-                tz, _defaultBase64);\n+\n+\n+public BaseSettings withDateFormat(DateFormat df) {\n+    if (_dateFormat == df) {\n+        return this;\n     }\n+    TimeZone tz = _timeZone; // Use the existing TimeZone regardless of df\n+    return new BaseSettings(_classIntrospector, _annotationIntrospector, _visibilityChecker, _propertyNamingStrategy, _typeFactory,\n+            _typeResolverBuilder, df, _handlerInstantiator, _locale,\n+            tz, _defaultBase64);\n+}\n+\n \n     public BaseSettings withHandlerInstantiator(HandlerInstantiator hi) {\n         if (_handlerInstantiator == hi) {"}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex fc7961de5..23d989e83 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -791,7 +791,7 @@ public class BeanDeserializer\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+                if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                     ;\n                 } else {\n                     // Last creator property to set?"}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\nindex 5624624af..510960a29 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n@@ -78,11 +78,11 @@ public class NumberSerializer\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), ", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\nindex 10fddc4d6..132cd4e6c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n@@ -1438,7 +1438,7 @@ public class ObjectReader\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                 true));\n     }\n "}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\nprotected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n        JavaType propType0)\n        throws JsonMappingException\n{\n    // need to ensure method is callable (for non-public)\n    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n    if (ctxt.canOverrideAccessModifiers()) {\n        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n        // never needed and attempts may cause problems on some platforms.\n        // Note: This behavior might change in future. But for now, override access\n        // for most cases, but explicitly prevent overriding when dealing with\n        // `cause` of `Throwable` -- which is the most vulnerable to incorrect\n        // access. Let's do this by not overriding access if mutable property is\n        // accessed via private field.\n        if (!(mutator instanceof AnnotatedField \n                && ((AnnotatedField) mutator).getMember().getDeclaringClass().isAssignableFrom(Throwable.class)\n                && ((AnnotatedField) mutator).getMember().getName().equals(\"cause\"))) {\n            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n        }\n    }\n    // note: this works since we know there's exactly one argument for methods\n    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n            propType0, propDef.getWrapperName(),\n            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n    // did type change?\n    if (type != propType0) {\n        property = property.withType(type);\n    }\n\n    // First: does the Method specify the deserializer to use? If so, let's use it.\n    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n    type = modifyTypeByAnnotation(ctxt, mutator, type);\n    TypeDeserializer typeDeser = type.getTypeHandler();\n    SettableBeanProperty prop;\n    if (mutator instanceof AnnotatedMethod) {\n        prop = new MethodProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n    } else {\n        prop = new FieldProperty(propDef, type, typeDeser,\n                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n    }\n    if (propDeser != null) {\n        prop = prop.withValueDeserializer(propDeser);\n    }\n    // need to retain name of managed forward references:\n    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n    if (ref != null && ref.isManagedReference()) {\n        prop.setManagedReferenceName(ref.getName());\n    }\n    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n    if(objectIdInfo != null){\n        prop.setObjectIdInfo(objectIdInfo);\n    }\n    return prop;\n}\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex df861215c..42b78da00 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -700,56 +700,66 @@ public class BeanDeserializerFactory\n      * @return Property constructed, if any; or null to indicate that\n      *   there should be no property based on given definitions.\n      */\n-    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n-            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n-            JavaType propType0)\n-        throws JsonMappingException\n-    {\n-        // need to ensure method is callable (for non-public)\n-        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n \n-        if (ctxt.canOverrideAccessModifiers()) {\n-            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n-            // never needed and attempts may cause problems on some platforms.\n-            // !!! NOTE: should be handled better for 2.8 and later\n-                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n-        }\n-        // note: this works since we know there's exactly one argument for methods\n-        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n-                propType0, propDef.getWrapperName(),\n-                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n-        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n-        // did type change?\n-        if (type != propType0) {\n-            property = property.withType(type);\n+protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n+        BeanDescription beanDesc, BeanPropertyDefinition propDef,\n+        JavaType propType0)\n+        throws JsonMappingException\n+{\n+    // need to ensure method is callable (for non-public)\n+    AnnotatedMember mutator = propDef.getNonConstructorMutator();\n+\n+    if (ctxt.canOverrideAccessModifiers()) {\n+        // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n+        // never needed and attempts may cause problems on some platforms.\n+        // Note: This behavior might change in future. But for now, override access\n+        // for most cases, but explicitly prevent overriding when dealing with\n+        // `cause` of `Throwable` -- which is the most vulnerable to incorrect\n+        // access. Let's do this by not overriding access if mutable property is\n+        // accessed via private field.\n+        if (!(mutator instanceof AnnotatedField \n+                && ((AnnotatedField) mutator).getMember().getDeclaringClass().isAssignableFrom(Throwable.class)\n+                && ((AnnotatedField) mutator).getMember().getName().equals(\"cause\"))) {\n+            mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n         }\n+    }\n+    // note: this works since we know there's exactly one argument for methods\n+    BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n+            propType0, propDef.getWrapperName(),\n+            beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n+    JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n+    // did type change?\n+    if (type != propType0) {\n+        property = property.withType(type);\n+    }\n \n-        // First: does the Method specify the deserializer to use? If so, let's use it.\n-        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n-        type = modifyTypeByAnnotation(ctxt, mutator, type);\n-        TypeDeserializer typeDeser = type.getTypeHandler();\n-        SettableBeanProperty prop;\n-        if (mutator instanceof AnnotatedMethod) {\n-            prop = new MethodProperty(propDef, type, typeDeser,\n-                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n-        } else {\n-            prop = new FieldProperty(propDef, type, typeDeser,\n-                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n-        }\n-        if (propDeser != null) {\n-            prop = prop.withValueDeserializer(propDeser);\n-        }\n-        // need to retain name of managed forward references:\n-        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n-        if (ref != null && ref.isManagedReference()) {\n-            prop.setManagedReferenceName(ref.getName());\n-        }\n-        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n-        if(objectIdInfo != null){\n-            prop.setObjectIdInfo(objectIdInfo);\n-        }\n-        return prop;\n+    // First: does the Method specify the deserializer to use? If so, let's use it.\n+    JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n+    type = modifyTypeByAnnotation(ctxt, mutator, type);\n+    TypeDeserializer typeDeser = type.getTypeHandler();\n+    SettableBeanProperty prop;\n+    if (mutator instanceof AnnotatedMethod) {\n+        prop = new MethodProperty(propDef, type, typeDeser,\n+                beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n+    } else {\n+        prop = new FieldProperty(propDef, type, typeDeser,\n+                beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n     }\n+    if (propDeser != null) {\n+        prop = prop.withValueDeserializer(propDeser);\n+    }\n+    // need to retain name of managed forward references:\n+    AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n+    if (ref != null && ref.isManagedReference()) {\n+        prop.setManagedReferenceName(ref.getName());\n+    }\n+    ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n+    if(objectIdInfo != null){\n+        prop.setObjectIdInfo(objectIdInfo);\n+    }\n+    return prop;\n+}\n+\n \n     /**\n      * Method that will construct a regular bean property setter using"}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "PASS", "attempt": 10, "mode": "SF", "patch": "\npublic String getDescription() {\n    if (_desc == null) {\n        StringBuilder sb = new StringBuilder();\n\n        if (_from == null) { // can this ever occur?\n            sb.append(\"UNKNOWN\");\n        } else {\n            Class<?> cls = (_from instanceof Class<?>) ? (Class<?>) _from : _from.getClass();\n            // Hmmh. Although Class.getName() is mostly ok, it does look\n            // butt-ugly for arrays.\n            // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n            //  as it drops enclosing class. So let's try bit different approach\n            String pkgName = com.fasterxml.jackson.databind.util.ClassUtil.getPackageName(cls);\n            if (pkgName != null) {\n                sb.append(pkgName);\n                sb.append('.');\n            }\n            String simpleName = cls.getSimpleName();\n            // If the class is an inner class, append the outer class's simple name\n            if (cls.isMemberClass() && !cls.isLocalClass() && !cls.isAnonymousClass()) {\n                String outerSimpleName = outerClassSimpleName(cls);\n                sb.append(outerSimpleName);\n                sb.append(\"$\");\n            }\n            sb.append(simpleName);\n        }\n        sb.append('[');\n        if (_fieldName != null) {\n            sb.append('\"');\n            sb.append(_fieldName);\n            sb.append('\"');\n        } else if (_index >= 0) {\n            sb.append(_index);\n        } else {\n            sb.append('?');\n        }\n        sb.append(']');\n        _desc = sb.toString();\n    }\n    return _desc;\n}\n\n// Helper method to get simple name of the outer class\nprivate String outerClassSimpleName(Class<?> cls) {\n    Class<?> outerClass = cls.getEnclosingClass();\n    if (outerClass != null) {\n        return outerClass.getSimpleName();\n    }\n    return cls.getSimpleName();\n}\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\nindex 482622b82..c40c630b3 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/JsonMappingException.java\n@@ -115,40 +115,58 @@ public class JsonMappingException\n \n         public String getFieldName() { return _fieldName; }\n         public int getIndex() { return _index; }\n-        public String getDescription() {\n-            if (_desc == null) {\n-                StringBuilder sb = new StringBuilder();\n-\n-                if (_from == null) { // can this ever occur?\n-                    sb.append(\"UNKNOWN\");\n-                } else {\n-                    Class<?> cls = (_from instanceof Class<?>) ? (Class<?>)_from : _from.getClass();\n-                    // Hmmh. Although Class.getName() is mostly ok, it does look\n-                    // butt-ugly for arrays.\n-                    // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n-                    //   as it drops enclosing class. So let's try bit different approach\n-                    String pkgName = com.fasterxml.jackson.databind.util.ClassUtil.getPackageName(cls);\n-                    if (pkgName != null) {\n-                        sb.append(pkgName);\n-                        sb.append('.');\n-                    }\n-                    sb.append(cls.getSimpleName());\n-                }\n-                sb.append('[');\n-                if (_fieldName != null) {\n-                    sb.append('\"');\n-                    sb.append(_fieldName);\n-                    sb.append('\"');\n-                } else if (_index >= 0) {\n-                    sb.append(_index);\n-                } else {\n-                    sb.append('?');\n-                }\n-                sb.append(']');\n-                _desc = sb.toString();\n+\n+public String getDescription() {\n+    if (_desc == null) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        if (_from == null) { // can this ever occur?\n+            sb.append(\"UNKNOWN\");\n+        } else {\n+            Class<?> cls = (_from instanceof Class<?>) ? (Class<?>) _from : _from.getClass();\n+            // Hmmh. Although Class.getName() is mostly ok, it does look\n+            // butt-ugly for arrays.\n+            // 06-Oct-2016, tatu: as per [databind#1403], `getSimpleName()` not so good\n+            //  as it drops enclosing class. So let's try bit different approach\n+            String pkgName = com.fasterxml.jackson.databind.util.ClassUtil.getPackageName(cls);\n+            if (pkgName != null) {\n+                sb.append(pkgName);\n+                sb.append('.');\n+            }\n+            String simpleName = cls.getSimpleName();\n+            // If the class is an inner class, append the outer class's simple name\n+            if (cls.isMemberClass() && !cls.isLocalClass() && !cls.isAnonymousClass()) {\n+                String outerSimpleName = outerClassSimpleName(cls);\n+                sb.append(outerSimpleName);\n+                sb.append(\"$\");\n             }\n-            return _desc;\n+            sb.append(simpleName);\n+        }\n+        sb.append('[');\n+        if (_fieldName != null) {\n+            sb.append('\"');\n+            sb.append(_fieldName);\n+            sb.append('\"');\n+        } else if (_index >= 0) {\n+            sb.append(_index);\n+        } else {\n+            sb.append('?');\n         }\n+        sb.append(']');\n+        _desc = sb.toString();\n+    }\n+    return _desc;\n+}\n+\n+// Helper method to get simple name of the outer class\n+private String outerClassSimpleName(Class<?> cls) {\n+    Class<?> outerClass = cls.getEnclosingClass();\n+    if (outerClass != null) {\n+        return outerClass.getSimpleName();\n+    }\n+    return cls.getSimpleName();\n+}\n+\n \n         @Override\n         public String toString() {"}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\npublic KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        // the only non-standard thing is this:\n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        // and then post-processing\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 7d6a7bf5e..7f6c0fc5b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -1382,7 +1382,8 @@ public abstract class BasicDeserializerFactory\n      */\n     \n     @Override\n-    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n+\n+public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n             JavaType type)\n         throws JsonMappingException\n     {\n@@ -1400,9 +1401,10 @@ public abstract class BasicDeserializerFactory\n         // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n+                deser = _createEnumKeyDeserializer(ctxt, type);\n+            } else {\n+                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n             }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n         // and then post-processing\n         if (deser != null) {\n@@ -1415,6 +1417,7 @@ public abstract class BasicDeserializerFactory\n         return deser;\n     }\n \n+\n     private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n             JavaType type)\n         throws JsonMappingException"}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                found = key.equalsIgnoreCase(prop.getName());", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\nindex dc791897b..99e9102a2 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n@@ -437,7 +437,7 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+                found = key.equalsIgnoreCase(prop.getName());\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;"}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\npublic T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n{\n    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n    String text = p.getValueAsString();\n    if (text != null) { // has String representation\n        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n            // 04-Feb-2013, tatu: Usually should become null; but not always\n            return _deserializeFromEmptyString();\n        }\n        Exception cause = null;\n        try {\n            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n            //    indicated error; but that seems wrong. Should be able to return\n            //    `null` as value.\n            T result = _deserialize(text, ctxt);\n            if (result == null) {\n                // If null result means an error, let's pass the exception\n                cause = getDeserializationProblem(_valueClass, text, ctxt);\n            }\n            return result;\n        } catch (IllegalArgumentException iae) {\n            cause = iae;\n        } catch (MalformedURLException me) {\n            cause = me;\n        }\n        String msg = \"not a valid textual representation\";\n        if (cause != null) {\n            String m2 = cause.getMessage();\n            if (m2 != null) {\n                msg = msg + \", problem: \"+m2;\n            }\n        }\n        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n        if (cause != null) {\n            e.initCause(cause);\n        }\n        throw e;\n        // nothing to do here, yet? We'll fail anyway\n    }\n    JsonToken t = p.getCurrentToken();\n    // [databind#381]\n    if (t == JsonToken.START_ARRAY) {\n        return _deserializeFromArray(p, ctxt);\n    }\n    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n        // Trivial cases; null to null, instance of type itself returned as is\n        Object ob = p.getEmbeddedObject();\n        if (ob == null) {\n            return null;\n        }\n        if (_valueClass.isAssignableFrom(ob.getClass())) {\n            return (T) ob;\n        }\n        return _deserializeEmbedded(ob, ctxt);\n    }\n    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n}\n\n// A helper method to determine whether the exception is a problem with deserialization\nprivate Exception getDeserializationProblem(Class<?> type, String text, DeserializationContext ctxt) {\n    try {\n        // Try to deserialize the text into the given type, and return the exception if it doesn't succeed\n        _deserialize(text, ctxt);\n        return null; // Deserialization succeeded, no exception\n    } catch (Exception e) {\n        return e; // Return the exception\n    }\n}\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex 4f4eb672a..2aefea90e 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -102,61 +102,77 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n-    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n-    {\n-        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n-        String text = p.getValueAsString();\n-        if (text != null) { // has String representation\n-            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n-                // 04-Feb-2013, tatu: Usually should become null; but not always\n-                return _deserializeFromEmptyString();\n-            }\n-            Exception cause = null;\n-            try {\n-                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n-                //    indicated error; but that seems wrong. Should be able to return\n-                //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n-                return _deserialize(text, ctxt);\n-                }\n-            } catch (IllegalArgumentException iae) {\n-                cause = iae;\n-            } catch (MalformedURLException me) {\n-                cause = me;\n-            }\n-            String msg = \"not a valid textual representation\";\n-            if (cause != null) {\n-                String m2 = cause.getMessage();\n-                if (m2 != null) {\n-                    msg = msg + \", problem: \"+m2;\n-                }\n+\n+public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n+{\n+    // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n+    String text = p.getValueAsString();\n+    if (text != null) { // has String representation\n+        if (text.length() == 0 || (text = text.trim()).length() == 0) {\n+            // 04-Feb-2013, tatu: Usually should become null; but not always\n+            return _deserializeFromEmptyString();\n+        }\n+        Exception cause = null;\n+        try {\n+            // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n+            //    indicated error; but that seems wrong. Should be able to return\n+            //    `null` as value.\n+            T result = _deserialize(text, ctxt);\n+            if (result == null) {\n+                // If null result means an error, let's pass the exception\n+                cause = getDeserializationProblem(_valueClass, text, ctxt);\n             }\n-            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n-            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n-            if (cause != null) {\n-                e.initCause(cause);\n+            return result;\n+        } catch (IllegalArgumentException iae) {\n+            cause = iae;\n+        } catch (MalformedURLException me) {\n+            cause = me;\n+        }\n+        String msg = \"not a valid textual representation\";\n+        if (cause != null) {\n+            String m2 = cause.getMessage();\n+            if (m2 != null) {\n+                msg = msg + \", problem: \"+m2;\n             }\n-            throw e;\n-            // nothing to do here, yet? We'll fail anyway\n         }\n-        JsonToken t = p.getCurrentToken();\n-        // [databind#381]\n-        if (t == JsonToken.START_ARRAY) {\n-            return _deserializeFromArray(p, ctxt);\n+        // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n+        JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n+        if (cause != null) {\n+            e.initCause(cause);\n         }\n-        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n-            // Trivial cases; null to null, instance of type itself returned as is\n-            Object ob = p.getEmbeddedObject();\n-            if (ob == null) {\n-                return null;\n-            }\n-            if (_valueClass.isAssignableFrom(ob.getClass())) {\n-                return (T) ob;\n-            }\n-            return _deserializeEmbedded(ob, ctxt);\n+        throw e;\n+        // nothing to do here, yet? We'll fail anyway\n+    }\n+    JsonToken t = p.getCurrentToken();\n+    // [databind#381]\n+    if (t == JsonToken.START_ARRAY) {\n+        return _deserializeFromArray(p, ctxt);\n+    }\n+    if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n+        // Trivial cases; null to null, instance of type itself returned as is\n+        Object ob = p.getEmbeddedObject();\n+        if (ob == null) {\n+            return null;\n+        }\n+        if (_valueClass.isAssignableFrom(ob.getClass())) {\n+            return (T) ob;\n         }\n-        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n+        return _deserializeEmbedded(ob, ctxt);\n     }\n+    return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n+}\n+\n+// A helper method to determine whether the exception is a problem with deserialization\n+private Exception getDeserializationProblem(Class<?> type, String text, DeserializationContext ctxt) {\n+    try {\n+        // Try to deserialize the text into the given type, and return the exception if it doesn't succeed\n+        _deserialize(text, ctxt);\n+        return null; // Deserialization succeeded, no exception\n+    } catch (Exception e) {\n+        return e; // Return the exception\n+    }\n+}\n+\n         \n     protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n "}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "3", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            // Return the attribute value instead of null\n            return _currText;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\nindex 7b163ed..f4e29c9 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n@@ -598,6 +598,7 @@ public class FromXmlParser\n      * String collections.\n      */\n     @Override\n+\n     public String nextTextValue() throws IOException\n     {\n         _binaryValue = null;\n@@ -668,7 +669,8 @@ public class FromXmlParser\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n             _currText = _xmlTokens.getText();\n             _currToken = JsonToken.VALUE_STRING;\n-            break;\n+            // Return the attribute value instead of null\n+            return _currText;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n@@ -693,6 +695,7 @@ public class FromXmlParser\n     }\n \n \n+\n     private void _updateState(JsonToken t)\n     {\n         switch (t) {"}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\nif (docData.startsWith(\"\\ufeff\")) {\n    docData = docData.substring(1);\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex e5b044d..968f87b 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -96,6 +96,11 @@ public class DataUtil {\n             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n             // into head mode\n \n+if (docData.startsWith(\"\\ufeff\")) {\n+    docData = docData.substring(1);\n+}\n+\n+\n             doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }"}
{"project": "Jsoup", "bug_id": "24", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                // no advance", "diff": "diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex e530264..27bdedd 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -555,7 +555,7 @@ enum TokeniserState {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+                // no advance\n                 return;\n             }\n "}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"textarea\", \"title\"};", "diff": "diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex 40b7557..0f41f60 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -215,7 +215,7 @@ public class Tag {\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"textarea\", \"title\"};\n \n     static {\n         // creates"}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "attempt": 19, "mode": "SL", "patch": "if (offset < length - seq.length() + 1) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex dc1b114..8c96658 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -88,7 +88,7 @@ class CharacterReader {\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+if (offset < length - seq.length() + 1) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;"}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "doc = parser.parseInput(docData.replaceFirst(\"[\\uFEFF]\", \"\"), baseUri);", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex d43bfe4..b1ea510 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -116,6 +116,7 @@ public class DataUtil {\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n             charsetName = defaultCharset;\n+doc = parser.parseInput(docData.replaceFirst(\"[\\uFEFF]\", \"\"), baseUri);\n         }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);"}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "        Validate.notNull(name);", "diff": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex 4b4a5e9..c5ab1db 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -19,7 +19,7 @@ public class DocumentType extends Node {\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+        Validate.notNull(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);"}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return this.hashCode() == ((Element) o).hashCode();", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex cd2e86a..82e3374 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1172,7 +1172,7 @@ public class Element extends Node {\n \n         Element element = (Element) o;\n \n-        return this == o;\n+        return this.hashCode() == ((Element) o).hashCode();\n     }\n \n     @Override"}
{"project": "Jsoup", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 4a58fdf..4ac8870 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -391,7 +391,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name) && !last)) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {"}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                        if (escapeMode == EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(c);", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 6ccb84e..c9e595a 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -115,7 +115,7 @@ public class Entities {\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                        if (escapeMode == EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(c);\n                         break;\n                     case '<':\n                         if (!inAttribute)"}
{"project": "Jsoup", "bug_id": "47", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "                        if ((out.escapeMode() == EscapeMode.xhtml) || (!inAttribute))", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 08cf311..7d55eed 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -119,7 +119,7 @@ public class Entities {\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+                        if ((out.escapeMode() == EscapeMode.xhtml) || (!inAttribute))\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);"}
{"project": "Jsoup", "bug_id": "48", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\nvoid processResponseHeaders(Map<String, List<String>> resHeaders) {\n    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n        String name = entry.getKey();\n        if (name == null)\n            continue; // http/1.1 line\n\n        List<String> values = entry.getValue();\n        if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n            for (String value : values) {\n                if (value == null)\n                    continue;\n                TokenQueue cd = new TokenQueue(value);\n                String cookieName = cd.chompTo(\"=\").trim();\n                String cookieVal = cd.consumeTo(\";\").trim();\n                if (cookieName.length() > 0)\n                    cookie(cookieName, cookieVal);\n            }\n        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n            if (!values.isEmpty())\n                header(name, String.join(\", \", values)); // Changed this line\n        }\n    }\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex f8fd9dd..1300331 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -750,31 +750,31 @@ public class HttpConnection implements Connection {\n             return headers;\n         }\n \n-        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n-            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n-                String name = entry.getKey();\n-                if (name == null)\n-                    continue; // http/1.1 line\n-\n-                List<String> values = entry.getValue();\n-                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n-                    for (String value : values) {\n-                        if (value == null)\n-                            continue;\n-                        TokenQueue cd = new TokenQueue(value);\n-                        String cookieName = cd.chompTo(\"=\").trim();\n-                        String cookieVal = cd.consumeTo(\";\").trim();\n-                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n-                        // name not blank, value not null\n-                        if (cookieName.length() > 0)\n-                            cookie(cookieName, cookieVal);\n-                    }\n-                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n-                        header(name, values.get(0));\n-                }\n+\n+void processResponseHeaders(Map<String, List<String>> resHeaders) {\n+    for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n+        String name = entry.getKey();\n+        if (name == null)\n+            continue; // http/1.1 line\n+\n+        List<String> values = entry.getValue();\n+        if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n+            for (String value : values) {\n+                if (value == null)\n+                    continue;\n+                TokenQueue cd = new TokenQueue(value);\n+                String cookieName = cd.chompTo(\"=\").trim();\n+                String cookieVal = cd.consumeTo(\";\").trim();\n+                if (cookieName.length() > 0)\n+                    cookie(cookieName, cookieVal);\n             }\n+        } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n+            if (!values.isEmpty())\n+                header(name, String.join(\", \", values)); // Changed this line\n         }\n+    }\n+}\n+\n \n         private static String setOutputContentType(final Connection.Request req) {\n             // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary"}
{"project": "Jsoup", "bug_id": "49", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\nprotected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    int originalLength = childNodes.size();\n    for (int i = children.length - 1; i >= 0; i--) {\n        Node in = children[i];\n        reparentChild(in);\n    }\n    for (int i = children.length - 1; i >= 0; i--) {\n        Node in = children[i];\n        childNodes.add(index, in);\n    }\n    reindexChildren(index);\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex 01a4cd1..bc19aca 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -435,16 +435,22 @@ public abstract class Node implements Cloneable {\n         }\n     }\n \n-    protected void addChildren(int index, Node... children) {\n-        Validate.noNullElements(children);\n-        ensureChildNodes();\n-        for (int i = children.length - 1; i >= 0; i--) {\n-            Node in = children[i];\n-            reparentChild(in);\n-            childNodes.add(index, in);\n-        }\n-        reindexChildren(index);\n+\n+protected void addChildren(int index, Node... children) {\n+    Validate.noNullElements(children);\n+    ensureChildNodes();\n+    int originalLength = childNodes.size();\n+    for (int i = children.length - 1; i >= 0; i--) {\n+        Node in = children[i];\n+        reparentChild(in);\n     }\n+    for (int i = children.length - 1; i >= 0; i--) {\n+        Node in = children[i];\n+        childNodes.add(index, in);\n+    }\n+    reindexChildren(index);\n+}\n+\n \n     protected void ensureChildNodes() {\n         if (childNodes == EMPTY_NODES) {"}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "                it.remove();", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 49ff25d..8fdb654 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -122,7 +122,7 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n             String attrKey = it.next();\n             if (attrKey.equalsIgnoreCase(key))\n-                attributes.remove(attrKey);\n+                it.remove();\n         }\n     }\n "}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "attempt": 14, "mode": "SF", "patch": "\nfinal void newAttribute() {\n    if (attributes == null)\n        attributes = new Attributes();\n\n    if (pendingAttributeName != null) {\n        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n        pendingAttributeName = pendingAttributeName.trim();\n        \n        if (pendingAttributeName.isEmpty()) {\n            // Handle empty attribute name\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n            return;\n        }\n\n        Attribute attribute;\n        if (hasPendingAttributeValue)\n            attribute = new Attribute(pendingAttributeName,\n                pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n        else if (hasEmptyAttributeValue)\n            attribute = new Attribute(pendingAttributeName, \"\");\n        else\n            attribute = new BooleanAttribute(pendingAttributeName);\n        attributes.put(attribute);\n    }\n    pendingAttributeName = null;\n    hasEmptyAttributeValue = false;\n    hasPendingAttributeValue = false;\n    reset(pendingAttributeValue);\n    pendingAttributeValueS = null;\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex 7dcfa2b..f459f9f 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -97,29 +97,42 @@ abstract class Token {\n             return this;\n         }\n \n-        final void newAttribute() {\n-            if (attributes == null)\n-                attributes = new Attributes();\n \n-            if (pendingAttributeName != null) {\n-                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n-                pendingAttributeName = pendingAttributeName.trim();\n-                    Attribute attribute;\n-                    if (hasPendingAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName,\n-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n-                    else if (hasEmptyAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName, \"\");\n-                    else\n-                        attribute = new BooleanAttribute(pendingAttributeName);\n-                    attributes.put(attribute);\n-            }\n+final void newAttribute() {\n+    if (attributes == null)\n+        attributes = new Attributes();\n+\n+    if (pendingAttributeName != null) {\n+        // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n+        pendingAttributeName = pendingAttributeName.trim();\n+        \n+        if (pendingAttributeName.isEmpty()) {\n+            // Handle empty attribute name\n             pendingAttributeName = null;\n             hasEmptyAttributeValue = false;\n             hasPendingAttributeValue = false;\n             reset(pendingAttributeValue);\n             pendingAttributeValueS = null;\n-        }\n+            return;\n+        }\n+\n+        Attribute attribute;\n+        if (hasPendingAttributeValue)\n+            attribute = new Attribute(pendingAttributeName,\n+                pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+        else if (hasEmptyAttributeValue)\n+            attribute = new Attribute(pendingAttributeName, \"\");\n+        else\n+            attribute = new BooleanAttribute(pendingAttributeName);\n+        attributes.put(attribute);\n+    }\n+    pendingAttributeName = null;\n+    hasEmptyAttributeValue = false;\n+    hasPendingAttributeValue = false;\n+    reset(pendingAttributeValue);\n+    pendingAttributeValueS = null;\n+}\n+\n \n         final void finaliseTag() {\n             // finalises for emit"}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "68", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\nstatic boolean preserveWhitespace(Node node) {\n    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n    if (node != null && node instanceof Element) {\n        Element el = (Element) node;\n        if (el.tag.preserveWhitespace()) {\n            return true; // if this element preserves whitespace, return true immediately\n        } else if (el.parent() != null) { // check parent for whitespace preservation\n            return preserveWhitespace(el.parent()); // recursively check parent's whitespace preservation\n        }\n    }\n    return false; // if neither this element nor its parent preserves whitespace, return false\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex faca4c8..cf85497 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1084,17 +1084,20 @@ public class Element extends Node {\n             accum.append(\" \");\n     }\n \n-    static boolean preserveWhitespace(Node node) {\n-        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n-        if (node != null && node instanceof Element) {\n-            Element el = (Element) node;\n-                if (el.tag.preserveWhitespace())\n-                    return true;\n-                else\n-                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n+\n+static boolean preserveWhitespace(Node node) {\n+    // looks only at this element and five levels up, to prevent recursion & needless stack searches\n+    if (node != null && node instanceof Element) {\n+        Element el = (Element) node;\n+        if (el.tag.preserveWhitespace()) {\n+            return true; // if this element preserves whitespace, return true immediately\n+        } else if (el.parent() != null) { // check parent for whitespace preservation\n+            return preserveWhitespace(el.parent()); // recursively check parent's whitespace preservation\n         }\n-        return false;\n     }\n+    return false; // if neither this element nor its parent preserves whitespace, return false\n+}\n+\n \n     /**\n      * Set the text of this element. Any existing contents (text or elements) will be cleared"}
{"project": "Jsoup", "bug_id": "72", "eval": "PASS", "attempt": 7, "mode": "SH", "patch": "\n// limit (no cache):\nif (count <= 0) {\n    return \"\";\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex 9ed4163..e9a7b06 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -425,6 +425,12 @@ public final class CharacterReader {\n         if (count > maxStringCacheLen)\n             return new String(charBuf, start, count);\n \n+// limit (no cache):\n+if (count <= 0) {\n+    return \"\";\n+}\n+\n+\n         // calculate hash:\n         int hash = 0;\n         int offset = start;"}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "77", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "80", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\nvoid insert(Token.Comment commentToken) {\n    Comment comment = new Comment(commentToken.getData());\n    Node insert = comment;\n    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n        String data = comment.getData();\n        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n            Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n            if (doc.childNodes().size() > 0) { // Check if the document has child nodes before accessing them\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            }\n        }\n    }\n    insertNode(insert);\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 75374e4..055d397 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -80,21 +80,25 @@ public class XmlTreeBuilder extends TreeBuilder {\n         return el;\n     }\n \n-    void insert(Token.Comment commentToken) {\n-        Comment comment = new Comment(commentToken.getData());\n-        Node insert = comment;\n-        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n-            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n-            String data = comment.getData();\n-            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n-                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n-                    Element el = doc.child(0);\n-                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n-                    insert.attributes().addAll(el.attributes());\n+\n+void insert(Token.Comment commentToken) {\n+    Comment comment = new Comment(commentToken.getData());\n+    Node insert = comment;\n+    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n+        // so we do a bit of a hack and parse the data as an element to pull the attributes out\n+        String data = comment.getData();\n+        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n+            Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n+            if (doc.childNodes().size() > 0) { // Check if the document has child nodes before accessing them\n+                Element el = doc.child(0);\n+                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n+                insert.attributes().addAll(el.attributes());\n             }\n         }\n-        insertNode(insert);\n     }\n+    insertNode(insert);\n+}\n+\n \n     void insert(Token.Character token) {\n         final String data = token.getData();"}
{"project": "Jsoup", "bug_id": "82", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\nstatic Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n    if (input == null) // empty body\n        return new Document(baseUri);\n    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\n    Document doc = null;\n    boolean fullyRead = false;\n\n    // read the start of the stream and look for a BOM or meta charset\n    input.mark(bufferSize);\n    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n    fullyRead = input.read() == -1;\n    input.reset();\n\n    // look for BOM - overrides any other header or input\n    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n    if (bomCharset != null)\n        charsetName = bomCharset.charset;\n\n    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n        doc = parser.parseInput(docData, baseUri);\n\n        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n        for (Element meta : metaElements) {\n            if (meta.hasAttr(\"http-equiv\"))\n                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n            if (foundCharset == null && meta.hasAttr(\"charset\"))\n                foundCharset = meta.attr(\"charset\");\n            if (foundCharset != null)\n                break;\n        }\n\n        // look for <?xml encoding='ISO-8859-1'?>\n        if (foundCharset == null && doc.childNodeSize() > 0) {\n            Node first = doc.childNode(0);\n            XmlDeclaration decl = null;\n            if (first instanceof XmlDeclaration)\n                decl = (XmlDeclaration) first;\n            else if (first instanceof Comment) {\n                Comment comment = (Comment) first;\n                if (comment.isXmlDeclaration())\n                    decl = comment.asXmlDeclaration();\n            }\n            if (decl != null) {\n                if (decl.name().equalsIgnoreCase(\"xml\"))\n                    foundCharset = decl.attr(\"encoding\");\n            }\n        }\n        foundCharset = validateCharset(foundCharset);\n        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n            charsetName = foundCharset;\n            doc = null;\n        } else if (!fullyRead) {\n            doc = null;\n        }\n    } else { // specified by content type header (or by user on file load)\n        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n    }\n    if (doc == null) {\n        if (charsetName == null)\n            charsetName = defaultCharset;\n        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n            reader.skip(1);\n        try {\n            doc = parser.parseInput(reader, baseUri);\n        } catch (UncheckedIOException e) {\n            // io exception when parsing (not seen before because reading the stream as we go)\n            throw e.ioException();\n        }\n        Charset charset = Charset.forName(charsetName);\n        doc.outputSettings().charset(charset);\n        if (!charset.canEncode()) {\n            charsetName = \"UTF-8\"; // switch to an encodable charset\n            doc.outputSettings().charset(Charset.forName(charsetName));\n            doc.select(\"meta[charset]\").first().attr(\"charset\", charsetName);\n        }\n    }\n    input.close();\n    return doc;\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex dc12cb3..9f4819a 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -92,87 +92,93 @@ public final class DataUtil {\n         }\n     }\n \n-    static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n-        if (input == null) // empty body\n-            return new Document(baseUri);\n-        input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n \n-        Document doc = null;\n-        boolean fullyRead = false;\n+static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\n+    if (input == null) // empty body\n+        return new Document(baseUri);\n+    input = ConstrainableInputStream.wrap(input, bufferSize, 0);\n \n-        // read the start of the stream and look for a BOM or meta charset\n-        input.mark(bufferSize);\n-        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n-        fullyRead = input.read() == -1;\n-        input.reset();\n+    Document doc = null;\n+    boolean fullyRead = false;\n \n-        // look for BOM - overrides any other header or input\n-        BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n-        if (bomCharset != null)\n-            charsetName = bomCharset.charset;\n+    // read the start of the stream and look for a BOM or meta charset\n+    input.mark(bufferSize);\n+    ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.\n+    fullyRead = input.read() == -1;\n+    input.reset();\n \n-        if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n-            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n-            doc = parser.parseInput(docData, baseUri);\n+    // look for BOM - overrides any other header or input\n+    BomCharset bomCharset = detectCharsetFromBom(firstBytes);\n+    if (bomCharset != null)\n+        charsetName = bomCharset.charset;\n \n-            // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n-            Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n-            String foundCharset = null; // if not found, will keep utf-8 as best attempt\n-            for (Element meta : metaElements) {\n-                if (meta.hasAttr(\"http-equiv\"))\n-                    foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n-                if (foundCharset == null && meta.hasAttr(\"charset\"))\n-                    foundCharset = meta.attr(\"charset\");\n-                if (foundCharset != null)\n-                    break;\n-            }\n+    if (charsetName == null) { // determine from meta. safe first parse as UTF-8\n+        String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\n+        doc = parser.parseInput(docData, baseUri);\n+\n+        // look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\n+        Elements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\n+        String foundCharset = null; // if not found, will keep utf-8 as best attempt\n+        for (Element meta : metaElements) {\n+            if (meta.hasAttr(\"http-equiv\"))\n+                foundCharset = getCharsetFromContentType(meta.attr(\"content\"));\n+            if (foundCharset == null && meta.hasAttr(\"charset\"))\n+                foundCharset = meta.attr(\"charset\");\n+            if (foundCharset != null)\n+                break;\n+        }\n \n-            // look for <?xml encoding='ISO-8859-1'?>\n-            if (foundCharset == null && doc.childNodeSize() > 0) {\n-                Node first = doc.childNode(0);\n-                XmlDeclaration decl = null;\n-                if (first instanceof XmlDeclaration)\n-                    decl = (XmlDeclaration) first;\n-                else if (first instanceof Comment) {\n-                    Comment comment = (Comment) first;\n-                    if (comment.isXmlDeclaration())\n-                        decl = comment.asXmlDeclaration();\n-                }\n-                if (decl != null) {\n-                    if (decl.name().equalsIgnoreCase(\"xml\"))\n-                        foundCharset = decl.attr(\"encoding\");\n-                }\n+        // look for <?xml encoding='ISO-8859-1'?>\n+        if (foundCharset == null && doc.childNodeSize() > 0) {\n+            Node first = doc.childNode(0);\n+            XmlDeclaration decl = null;\n+            if (first instanceof XmlDeclaration)\n+                decl = (XmlDeclaration) first;\n+            else if (first instanceof Comment) {\n+                Comment comment = (Comment) first;\n+                if (comment.isXmlDeclaration())\n+                    decl = comment.asXmlDeclaration();\n             }\n-            foundCharset = validateCharset(foundCharset);\n-            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n-                foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n-                charsetName = foundCharset;\n-                doc = null;\n-            } else if (!fullyRead) {\n-                doc = null;\n+            if (decl != null) {\n+                if (decl.name().equalsIgnoreCase(\"xml\"))\n+                    foundCharset = decl.attr(\"encoding\");\n             }\n-        } else { // specified by content type header (or by user on file load)\n-            Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n         }\n-        if (doc == null) {\n-            if (charsetName == null)\n-                charsetName = defaultCharset;\n-            BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n-            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n-                reader.skip(1);\n-            try {\n-                doc = parser.parseInput(reader, baseUri);\n-            } catch (UncheckedIOException e) {\n-                // io exception when parsing (not seen before because reading the stream as we go)\n-                throw e.ioException();\n-            }\n-            Charset charset = Charset.forName(charsetName);\n-            doc.outputSettings().charset(charset);\n-                // some charsets can read but not encode; switch to an encodable charset and update the meta el\n+        foundCharset = validateCharset(foundCharset);\n+        if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\n+            foundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\n+            charsetName = foundCharset;\n+            doc = null;\n+        } else if (!fullyRead) {\n+            doc = null;\n+        }\n+    } else { // specified by content type header (or by user on file load)\n+        Validate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n+    }\n+    if (doc == null) {\n+        if (charsetName == null)\n+            charsetName = defaultCharset;\n+        BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\n+        if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here\n+            reader.skip(1);\n+        try {\n+            doc = parser.parseInput(reader, baseUri);\n+        } catch (UncheckedIOException e) {\n+            // io exception when parsing (not seen before because reading the stream as we go)\n+            throw e.ioException();\n+        }\n+        Charset charset = Charset.forName(charsetName);\n+        doc.outputSettings().charset(charset);\n+        if (!charset.canEncode()) {\n+            charsetName = \"UTF-8\"; // switch to an encodable charset\n+            doc.outputSettings().charset(Charset.forName(charsetName));\n+            doc.select(\"meta[charset]\").first().attr(\"charset\", charsetName);\n         }\n-        input.close();\n-        return doc;\n     }\n+    input.close();\n+    return doc;\n+}\n+\n \n     /**\n      * Read the input stream into a byte buffer. To deal with slow input streams, you may interrupt the thread this"}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic Attribute(String key, String val, Attributes parent) {\n    Validate.notNull(key);\n    this.key = key.trim();\n    Validate.notNull(this.key); // validate non-null after trimming\n    Validate.notEmpty(this.key); // validate non-empty after trimming\n    this.val = val;\n    this.parent = parent;\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 612fdeb..a0c91fa 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -39,13 +39,16 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      * @param val attribute value\n      * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n      * @see #createFromEncoded*/\n-    public Attribute(String key, String val, Attributes parent) {\n-        Validate.notNull(key);\n-        this.key = key.trim();\n-        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n-        this.val = val;\n-        this.parent = parent;\n-    }\n+\n+public Attribute(String key, String val, Attributes parent) {\n+    Validate.notNull(key);\n+    this.key = key.trim();\n+    Validate.notNull(this.key); // validate non-null after trimming\n+    Validate.notEmpty(this.key); // validate non-empty after trimming\n+    this.val = val;\n+    this.parent = parent;\n+}\n+\n \n     /**\n      Get the attribute key."}
{"project": "Jsoup", "bug_id": "86", "eval": "PASS", "attempt": 15, "mode": "SL", "patch": "if (doc.children().size() > 0) {", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Comment.java b/src/main/java/org/jsoup/nodes/Comment.java\nindex d0669fe..a003a16 100644\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n@@ -75,7 +75,7 @@ public class Comment extends LeafNode {\n         String data = getData();\n         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n         XmlDeclaration decl = null;\n-        if (doc.childNodeSize() > 0) {\n+if (doc.children().size() > 0) {\n             Element el = doc.child(0);\n             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n             decl.attributes().addAll(el.attributes());"}
{"project": "Jsoup", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\npublic String setValue(String val) {\n    String oldVal = this.val;\n    if (parent != null) {\n        int i = parent.indexOfKey(this.key);\n        if (i != Attributes.NotFound) {\n            parent.vals[i] = val;\n        }\n    }\n    this.val = val;\n    return Attributes.checkNotNull(oldVal);\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 4ff695d..674175a 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -84,16 +84,19 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      Set the attribute value.\n      @param val the new attribute value; must not be null\n      */\n-    public String setValue(String val) {\n-        String oldVal = parent.get(this.key);\n-        if (parent != null) {\n-            int i = parent.indexOfKey(this.key);\n-            if (i != Attributes.NotFound)\n-                parent.vals[i] = val;\n+\n+public String setValue(String val) {\n+    String oldVal = this.val;\n+    if (parent != null) {\n+        int i = parent.indexOfKey(this.key);\n+        if (i != Attributes.NotFound) {\n+            parent.vals[i] = val;\n         }\n-        this.val = val;\n-        return Attributes.checkNotNull(oldVal);\n     }\n+    this.val = val;\n+    return Attributes.checkNotNull(oldVal);\n+}\n+\n \n     /**\n      Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}."}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n                while (i < end) {\n                    i++;\n                    if (i >= input.length) {\n                        return false;\n                    }\n                    o = input[i];\n                    if ((o & 0xC0) != 0x80) {\n                        return false;\n                    }\n                }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex a941e48..57e9193 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -422,6 +422,18 @@ public class HttpConnection implements Connection {\n                 }\n \n \n+                while (i < end) {\n+                    i++;\n+                    if (i >= input.length) {\n+                        return false;\n+                    }\n+                    o = input[i];\n+                    if ((o & 0xC0) != 0x80) {\n+                        return false;\n+                    }\n+                }\n+\n+\n                 while (i < end) {\n                     i++;\n                     o = input[i];"}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "8", "eval": "PASS", "attempt": 10, "mode": "SF", "patch": "\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        // NaN (Not a Number) values must be treated carefully in comparisons\n        if (Double.isNaN(ld) && Double.isNaN(rd)) {\n            return false;\n        } else if (Double.isNaN(ld) || Double.isNaN(rd)) {\n            return false;\n        } else {\n            return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex c6e0041..f3f9695 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -53,6 +53,7 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n \n     protected abstract boolean evaluateCompare(int compare);\n \n+\n     private boolean compute(Object left, Object right) {\n         left = reduce(left);\n         right = reduce(right);\n@@ -74,9 +75,18 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n         }\n         double ld = InfoSetUtil.doubleValue(left);\n         double rd = InfoSetUtil.doubleValue(right);\n-        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n+\n+        // NaN (Not a Number) values must be treated carefully in comparisons\n+        if (Double.isNaN(ld) && Double.isNaN(rd)) {\n+            return false;\n+        } else if (Double.isNaN(ld) || Double.isNaN(rd)) {\n+            return false;\n+        } else {\n+            return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n+        }\n     }\n \n+\n     private Object reduce(Object o) {\n         if (o instanceof SelfContext) {\n             o = ((EvalContext) o).getSingleNodePointer();"}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "12", "eval": "PASS", "attempt": 17, "mode": "SH", "patch": "\n                if (wildcard && !equalStrings(namespaceURI, nodeNS)) {\n                    return false;\n                } else {\n                    return true;\n                }\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex de50adf..5dcc95c 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -105,7 +105,13 @@ public class DOMNodePointer extends NodePointer {\n                 || testName.getName()\n                         .equals(DOMNodePointer.getLocalName(node))) {\n                 String nodeNS = DOMNodePointer.getNamespaceURI(node);\n-                return equalStrings(namespaceURI, nodeNS);\n+\n+                if (wildcard && !equalStrings(namespaceURI, nodeNS)) {\n+                    return false;\n+                } else {\n+                    return true;\n+                }\n+\n             }\n             return false;\n         }"}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    Element element = (Element) node;\n\n    String uri = element.getNamespaceURI();\n    if (uri == null) {\n        String prefix = getPrefix(node);\n        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n\n        Node aNode = null;\n        while (aNode == null || aNode != node) {\n            if (aNode != null && aNode.getNodeType() == Node.ELEMENT_NODE) {\n                Attr attr = ((Element) aNode).getAttributeNode(qname);\n                if (attr != null) {\n                    return attr.getValue();\n                }\n            }\n            aNode = aNode == null ? node : aNode.getParentNode();\n        }\n        return null;\n    }\n    return uri;\n}\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex f8e3b1a..f9e9a37 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -669,32 +669,34 @@ public class DOMNodePointer extends NodePointer {\n      * @param node Node to check\n      * @return String ns uri\n      */\n-    public static String getNamespaceURI(Node node) {\n-        if (node instanceof Document) {\n-            node = ((Document) node).getDocumentElement();\n-        }\n \n-        Element element = (Element) node;\n+public static String getNamespaceURI(Node node) {\n+    if (node instanceof Document) {\n+        node = ((Document) node).getDocumentElement();\n+    }\n \n-        String uri = element.getNamespaceURI();\n-        if (uri == null) {\n-            String prefix = getPrefix(node);\n-            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n-    \n-            Node aNode = node;\n-            while (aNode != null) {\n-                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n-                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n-                    if (attr != null) {\n-                        return attr.getValue();\n-                    }\n+    Element element = (Element) node;\n+\n+    String uri = element.getNamespaceURI();\n+    if (uri == null) {\n+        String prefix = getPrefix(node);\n+        String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n+\n+        Node aNode = null;\n+        while (aNode == null || aNode != node) {\n+            if (aNode != null && aNode.getNodeType() == Node.ELEMENT_NODE) {\n+                Attr attr = ((Element) aNode).getAttributeNode(qname);\n+                if (attr != null) {\n+                    return attr.getValue();\n                 }\n-                aNode = aNode.getParentNode();\n             }\n-            return null;\n+            aNode = aNode == null ? node : aNode.getParentNode();\n         }\n-        return uri;\n+        return null;\n     }\n+    return uri;\n+}\n+\n \n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {"}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    return cs1.toString().equals(cs2.toString());\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 535a3f24..88cc7e9b 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -778,15 +778,17 @@ public class StringUtils {\n      * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n      */\n-    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n-        if (cs1 == cs2) {\n-            return true;\n-        }\n-        if (cs1 == null || cs2 == null) {\n-            return false;\n-        }\n-            return cs1.equals(cs2);\n+\n+public static boolean equals(CharSequence cs1, CharSequence cs2) {\n+    if (cs1 == cs2) {\n+        return true;\n+    }\n+    if (cs1 == null || cs2 == null) {\n+        return false;\n     }\n+    return cs1.toString().equals(cs2.toString());\n+}\n+\n \n     /**\n      * <p>Compares two CharSequences, returning {@code true} if they represent"}
{"project": "Lang", "bug_id": "16", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 882358f2..5b7891a0 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -455,7 +455,7 @@ public class NumberUtils {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\") || str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);"}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 9a24c00f..52a44363 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&"}
{"project": "Lang", "bug_id": "22", "eval": "PASS", "attempt": 7, "mode": "SF", "patch": "\nprivate static int greatestCommonDivisor(int u, int v) {\n    // From Commons Math:\n    // if either operand is abs 1, return 1:\n    if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n        return 1;\n    }\n    // keep u and v negative, as negative integers range down to\n    // -2^31, while positive numbers can only be as large as 2^31-1\n    // (i.e. we can't necessarily negate a negative number without\n    // overflow)\n    if (u > 0) { u = -u; } // make u negative\n    if (v > 0) { v = -v; } // make v negative\n    // B1. [Find power of 2]\n    int k = 0;\n    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n        u /= 2; v /= 2; k++;\n    }\n    if (k == 31) {\n        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n    }\n    // B2. Initialize: u and v have been divided by 2^k and at least\n    //     one is odd.\n    int t = ((u & 1) == 1) ? v : -(u / 2);\n    // t negative: u was odd, v may be even (t replaces v)\n    // t positive: u was even, v is odd (t replaces u)\n    do {\n        /* assert u<0 && v<0; */\n        // B4/B3: cast out twos from t.\n        while ((t & 1) == 0) { // while t is even..\n            t /= 2; // cast out twos\n        }\n        // B5 [reset max(u,v)]\n        if (t > 0) {\n            u = -t;\n        } else {\n            v = t;\n        }\n        // B6/B3. at this point both u and v should be odd.\n        t = (v - u) / 2;\n        // |u| larger: t positive (replace v)\n        // |v| larger: t negative (replace u)\n    } while (t != 0 && u != Integer.MIN_VALUE && v != Integer.MIN_VALUE);\n    return -u * (1 << k);\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156a..ab28f8fb 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -578,50 +578,52 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n      * @param v  a non-zero number\n      * @return the greatest common divisor, never zero\n      */\n-    private static int greatestCommonDivisor(int u, int v) {\n-        // From Commons Math:\n-        //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n-            return 1;\n-        }\n-        // keep u and v negative, as negative integers range down to\n-        // -2^31, while positive numbers can only be as large as 2^31-1\n-        // (i.e. we can't necessarily negate a negative number without\n-        // overflow)\n-        if (u>0) { u=-u; } // make u negative\n-        if (v>0) { v=-v; } // make v negative\n-        // B1. [Find power of 2]\n-        int k=0;\n-        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n-            u/=2; v/=2; k++; // cast out twos.\n-        }\n-        if (k==31) {\n-            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n-        }\n-        // B2. Initialize: u and v have been divided by 2^k and at least\n-        //     one is odd.\n-        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n-        // t negative: u was odd, v may be even (t replaces v)\n-        // t positive: u was even, v is odd (t replaces u)\n-        do {\n-            /* assert u<0 && v<0; */\n-            // B4/B3: cast out twos from t.\n-            while ((t&1)==0) { // while t is even..\n-                t/=2; // cast out twos\n-            }\n-            // B5 [reset max(u,v)]\n-            if (t>0) {\n-                u = -t;\n-            } else {\n-                v = t;\n-            }\n-            // B6/B3. at this point both u and v should be odd.\n-            t = (v - u)/2;\n-            // |u| larger: t positive (replace u)\n-            // |v| larger: t negative (replace v)\n-        } while (t!=0);\n-        return -u*(1<<k); // gcd is u*2^k\n-    }\n+\n+private static int greatestCommonDivisor(int u, int v) {\n+    // From Commons Math:\n+    // if either operand is abs 1, return 1:\n+    if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n+        return 1;\n+    }\n+    // keep u and v negative, as negative integers range down to\n+    // -2^31, while positive numbers can only be as large as 2^31-1\n+    // (i.e. we can't necessarily negate a negative number without\n+    // overflow)\n+    if (u > 0) { u = -u; } // make u negative\n+    if (v > 0) { v = -v; } // make v negative\n+    // B1. [Find power of 2]\n+    int k = 0;\n+    while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n+        u /= 2; v /= 2; k++;\n+    }\n+    if (k == 31) {\n+        throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+    }\n+    // B2. Initialize: u and v have been divided by 2^k and at least\n+    //     one is odd.\n+    int t = ((u & 1) == 1) ? v : -(u / 2);\n+    // t negative: u was odd, v may be even (t replaces v)\n+    // t positive: u was even, v is odd (t replaces u)\n+    do {\n+        /* assert u<0 && v<0; */\n+        // B4/B3: cast out twos from t.\n+        while ((t & 1) == 0) { // while t is even..\n+            t /= 2; // cast out twos\n+        }\n+        // B5 [reset max(u,v)]\n+        if (t > 0) {\n+            u = -t;\n+        } else {\n+            v = t;\n+        }\n+        // B6/B3. at this point both u and v should be odd.\n+        t = (v - u) / 2;\n+        // |u| larger: t positive (replace v)\n+        // |v| larger: t negative (replace u)\n+    } while (t != 0 && u != Integer.MIN_VALUE && v != Integer.MIN_VALUE);\n+    return -u * (1 << k);\n+}\n+\n \n     // Arithmetic\n     //-------------------------------------------------------------------"}
{"project": "Lang", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "28", "eval": "PASS", "attempt": 19, "mode": "SF", "patch": "\npublic int translate(CharSequence input, int index, Writer out) throws IOException {\n    // TODO: Protect from ArrayIndexOutOfBounds\n\n    if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n        int start = index + 2;\n        boolean isHex = false;\n\n        char firstChar = input.charAt(start);\n        if(firstChar == 'x' || firstChar == 'X') {\n            start++;\n            isHex = true;\n        }\n\n        int end = start;\n        while(input.charAt(end) != ';') {\n            end++;\n        }\n\n        int entityValue;\n        try {\n            if(isHex) {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n            } else {\n                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n            }\n        } catch(NumberFormatException nfe) {\n            return 0;\n        }\n\n        // Convert the entity value to a code point\n        int unicodeCodePoint = entityValue;\n\n        // Ensure that the code point is a valid Unicode code point\n        if (unicodeCodePoint <= 0xFFFF) {\n            out.write((char) unicodeCodePoint);\n        } else {\n            // Handle code points outside of the basic multilingual plane (BMP)\n            out.write((char) (0xD800 + (unicodeCodePoint - 0x10000) / 0x400));\n            out.write((char) (0xDC00 + (unicodeCodePoint - 0x10000) % 0x400));\n        }\n\n        return 2 + (end - start) + (isHex ? 1 : 0) + (unicodeCodePoint > 0xFFFF ? 4 : 1);\n    }\n    return 0;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\nindex c3cb8695..59262d18 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/NumericEntityUnescaper.java\n@@ -32,37 +32,51 @@ public class NumericEntityUnescaper extends CharSequenceTranslator {\n      * {@inheritDoc}\n      */\n     @Override\n-    public int translate(CharSequence input, int index, Writer out) throws IOException {\n-        // TODO: Protect from ArrayIndexOutOfBounds\n-        if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n-            int start = index + 2;\n-            boolean isHex = false;\n \n-            char firstChar = input.charAt(start);\n-            if(firstChar == 'x' || firstChar == 'X') {\n-                start++;\n-                isHex = true;\n-            }\n+public int translate(CharSequence input, int index, Writer out) throws IOException {\n+    // TODO: Protect from ArrayIndexOutOfBounds\n \n-            int end = start;\n-            while(input.charAt(end) != ';') {\n-                end++;\n-            }\n+    if(input.charAt(index) == '&' && input.charAt(index + 1) == '#') {\n+        int start = index + 2;\n+        boolean isHex = false;\n+\n+        char firstChar = input.charAt(start);\n+        if(firstChar == 'x' || firstChar == 'X') {\n+            start++;\n+            isHex = true;\n+        }\n+\n+        int end = start;\n+        while(input.charAt(end) != ';') {\n+            end++;\n+        }\n \n-            int entityValue;\n-            try {\n-                if(isHex) {\n-                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n-                } else {\n-                    entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n-                }\n-            } catch(NumberFormatException nfe) {\n-                return 0;\n+        int entityValue;\n+        try {\n+            if(isHex) {\n+                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 16);\n+            } else {\n+                entityValue = Integer.parseInt(input.subSequence(start, end).toString(), 10);\n             }\n+        } catch(NumberFormatException nfe) {\n+            return 0;\n+        }\n+\n+        // Convert the entity value to a code point\n+        int unicodeCodePoint = entityValue;\n \n-                out.write(entityValue);\n-            return 2 + (end - start) + (isHex ? 1 : 0) + 1;\n+        // Ensure that the code point is a valid Unicode code point\n+        if (unicodeCodePoint <= 0xFFFF) {\n+            out.write((char) unicodeCodePoint);\n+        } else {\n+            // Handle code points outside of the basic multilingual plane (BMP)\n+            out.write((char) (0xD800 + (unicodeCodePoint - 0x10000) / 0x400));\n+            out.write((char) (0xDC00 + (unicodeCodePoint - 0x10000) % 0x400));\n         }\n-        return 0;\n+\n+        return 2 + (end - start) + (isHex ? 1 : 0) + (unicodeCodePoint > 0xFFFF ? 4 : 1);\n     }\n+    return 0;\n+}\n+\n }"}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            classes[i] = array[i] != null ? array[i].getClass() : null;", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9a..a6767c9e 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,7 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = array[i] != null ? array[i].getClass() : null;\n         }\n         return classes;\n     }"}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "attempt": 11, "mode": "SF", "patch": "\npublic static <T> T[] addAll(T[] array1, T... array2) {\n    if (array1 == null) {\n        return clone(array2);\n    } else if (array2 == null) {\n        return clone(array1);\n    }\n    final Class<?> type1 = array1.getClass().getComponentType();\n    // Check if the types are compatible\n    if (!type1.isAssignableFrom(array2.getClass().getComponentType())) {\n        throw new IllegalArgumentException(\"Incompatible types for adding\");\n    }\n    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n    return joinedArray;\n}\n", "diff": "diff --git a/src/java/org/apache/commons/lang3/ArrayUtils.java b/src/java/org/apache/commons/lang3/ArrayUtils.java\nindex 889497e9..b6b6238d 100644\n--- a/src/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2950,19 +2950,24 @@ public class ArrayUtils {\n      * @since 2.1\n      */\n     @SuppressWarnings(\"unchecked\")\n-    public static <T> T[] addAll(T[] array1, T... array2) {\n-        if (array1 == null) {\n-            return clone(array2);\n-        } else if (array2 == null) {\n-            return clone(array1);\n-        }\n-        final Class<?> type1 = array1.getClass().getComponentType();\n-        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n-        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-            // Check if problem is incompatible types\n-        return joinedArray;\n-    }\n+\n+public static <T> T[] addAll(T[] array1, T... array2) {\n+    if (array1 == null) {\n+        return clone(array2);\n+    } else if (array2 == null) {\n+        return clone(array1);\n+    }\n+    final Class<?> type1 = array1.getClass().getComponentType();\n+    // Check if the types are compatible\n+    if (!type1.isAssignableFrom(array2.getClass().getComponentType())) {\n+        throw new IllegalArgumentException(\"Incompatible types for adding\");\n+    }\n+    T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n+    System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n+    System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+    return joinedArray;\n+}\n+\n \n     /**\n      * <p>Adds all the elements of the given arrays into a new array.</p>"}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "40", "eval": "PASS", "attempt": 14, "mode": "SH", "patch": "\n   int strLen = str.length();\n   int searchStrLen = searchStr.length();\n   for (int i = 0; i <= strLen - searchStrLen; i++) {\n       if (str.substring(i, i + searchStrLen).equalsIgnoreCase(searchStr)) {\n           return true;\n       }\n   }\n   return false;\n", "diff": "diff --git a/src/java/org/apache/commons/lang/StringUtils.java b/src/java/org/apache/commons/lang/StringUtils.java\nindex 72b4a491..d20a3fbd 100644\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -1045,7 +1045,16 @@ public class StringUtils {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+\n+   int strLen = str.length();\n+   int searchStrLen = searchStr.length();\n+   for (int i = 0; i <= strLen - searchStrLen; i++) {\n+       if (str.substring(i, i + searchStrLen).equalsIgnoreCase(searchStr)) {\n+           return true;\n+       }\n+   }\n+   return false;\n+\n     }\n \n     // IndexOfAny chars"}
{"project": "Lang", "bug_id": "42", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic void escape(Writer writer, String str) throws IOException {\n    int len = str.length();\n    for (int i = 0; i < len; i++) {\n        char c = str.charAt(i);\n        String entityName = this.entityName(c);\n        if (entityName == null) {\n            // Java uses code points, not code units. So, we need to check for surrogate pairs\n            int codePoint = c;\n            if (Character.isSurrogate(c)) {\n                if (i + 1 < len) {\n                    codePoint = Character.toCodePoint(c, str.charAt(i + 1));\n                    i++; // Move to the next character as we've already used it\n                }\n            }\n            if (codePoint > 0x7F) {\n                writer.write(\"&#\");\n                writer.write(Integer.toString(codePoint, 10));\n                writer.write(';');\n            } else {\n                writer.write(c);\n            }\n        } else {\n            writer.write('&');\n            writer.write(entityName);\n            writer.write(';');\n        }\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/lang/Entities.java b/src/java/org/apache/commons/lang/Entities.java\nindex 900e1a89..f216af13 100644\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -822,26 +822,36 @@ class Entities {\n      * @see #escape(String)\n      * @see Writer\n      */\n-    public void escape(Writer writer, String str) throws IOException {\n-        int len = str.length();\n-        for (int i = 0; i < len; i++) {\n-            char c = str.charAt(i);\n-            String entityName = this.entityName(c);\n-            if (entityName == null) {\n-                if (c > 0x7F) {\n-                    writer.write(\"&#\");\n-                    writer.write(Integer.toString(c, 10));\n-                    writer.write(';');\n-                } else {\n-                    writer.write(c);\n+\n+public void escape(Writer writer, String str) throws IOException {\n+    int len = str.length();\n+    for (int i = 0; i < len; i++) {\n+        char c = str.charAt(i);\n+        String entityName = this.entityName(c);\n+        if (entityName == null) {\n+            // Java uses code points, not code units. So, we need to check for surrogate pairs\n+            int codePoint = c;\n+            if (Character.isSurrogate(c)) {\n+                if (i + 1 < len) {\n+                    codePoint = Character.toCodePoint(c, str.charAt(i + 1));\n+                    i++; // Move to the next character as we've already used it\n                 }\n-            } else {\n-                writer.write('&');\n-                writer.write(entityName);\n+            }\n+            if (codePoint > 0x7F) {\n+                writer.write(\"&#\");\n+                writer.write(Integer.toString(codePoint, 10));\n                 writer.write(';');\n+            } else {\n+                writer.write(c);\n             }\n+        } else {\n+            writer.write('&');\n+            writer.write(entityName);\n+            writer.write(';');\n         }\n     }\n+}\n+\n \n     /**\n      * <p>"}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "44", "eval": "PASS", "attempt": 15, "mode": "SH", "patch": "\nif (val == null) {\n    return null;\n}\nif (val.length() == 0) {\n    throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n}\nif (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n    switch(val.charAt(0)) {\n        case 'e': case 'E':\n            return null;\n        default:\n            throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05efe..b6731842 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,22 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+\n+if (val == null) {\n+    return null;\n+}\n+if (val.length() == 0) {\n+    throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+}\n+if (val.length() == 1 && !Character.isDigit(val.charAt(0))) {\n+    switch(val.charAt(0)) {\n+        case 'e': case 'E':\n+            return null;\n+        default:\n+            throw new NumberFormatException(val + \" is not a valid number.\");\n+    }\n+}\n+\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear "}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n// if the lower value is greater than the length of the string,\n// set to the length of the string\nif (lower > str.length()) {\n    lower = str.length();\n}\n", "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883e..252909b8 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -613,6 +613,13 @@ public class WordUtils {\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n+\n+// if the lower value is greater than the length of the string,\n+// set to the length of the string\n+if (lower > str.length()) {\n+    lower = str.length();\n+}\n+\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {"}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "52", "eval": "PASS", "attempt": 8, "mode": "SH", "patch": "\ncase '/':\n    out.write('\\\\');\n    out.write('/');\n    break;\n", "diff": "diff --git a/src/java/org/apache/commons/lang/StringEscapeUtils.java b/src/java/org/apache/commons/lang/StringEscapeUtils.java\nindex 4fda091d..818afd2e 100644\n--- a/src/java/org/apache/commons/lang/StringEscapeUtils.java\n+++ b/src/java/org/apache/commons/lang/StringEscapeUtils.java\n@@ -233,6 +233,12 @@ public class StringEscapeUtils {\n                         out.write('\\\\');\n                         out.write('\\\\');\n                         break;\n+\n+case '/':\n+    out.write('\\\\');\n+    out.write('/');\n+    break;\n+\n                     default :\n                         out.write(ch);\n                         break;"}
{"project": "Lang", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic void stop() {\n    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n        throw new IllegalStateException(\"Stopwatch is not running.\");\n    }\n    if (this.runningState == STATE_RUNNING) {\n        stopTime = System.currentTimeMillis();\n    }\n    this.runningState = STATE_STOPPED;\n}\n", "diff": "diff --git a/src/java/org/apache/commons/lang/time/StopWatch.java b/src/java/org/apache/commons/lang/time/StopWatch.java\nindex 8f394217..2f0dce4f 100644\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -111,13 +111,17 @@ public class StopWatch {\n      *\n      * @throws IllegalStateException if the StopWatch is not running.\n      */\n-    public void stop() {\n-        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n-            throw new IllegalStateException(\"Stopwatch is not running. \");\n-        }\n-            stopTime = System.currentTimeMillis();\n-        this.runningState = STATE_STOPPED;\n+\n+public void stop() {\n+    if (this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n+        throw new IllegalStateException(\"Stopwatch is not running.\");\n     }\n+    if (this.runningState == STATE_RUNNING) {\n+        stopTime = System.currentTimeMillis();\n+    }\n+    this.runningState = STATE_STOPPED;\n+}\n+\n \n     /**\n      * <p>Resets the stopwatch. Stops it if need be. </p>"}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);", "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e8..66fd39d8 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------"}
{"project": "Lang", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "59", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "2", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "        return (double) ((double) getSampleSize() * (double) getNumberOfSuccesses()) / (double) getPopulationSize();", "diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\nindex 27691272f..5a00784b9 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java\n@@ -265,7 +265,7 @@ public class HypergeometricDistribution extends AbstractIntegerDistribution {\n      * size {@code n}, the mean is {@code n * m / N}.\n      */\n     public double getNumericalMean() {\n-        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n+        return (double) ((double) getSampleSize() * (double) getNumberOfSuccesses()) / (double) getPopulationSize();\n     }\n \n     /**"}
{"project": "Math", "bug_id": "3", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        // Revert to scalar multiplication for single-element arrays.\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n\n            // Split the numbers into low and high parts.\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n\n        final double prodHighCur = prodHigh[0];\n        if (len == 1) {\n            return prodHighCur;\n        }\n\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..2f194fb12 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,6 +811,7 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n+\n     public static double linearCombination(final double[] a, final double[] b)\n         throws DimensionMismatchException {\n         final int len = a.length;\n@@ -818,7 +819,12 @@ public class MathArrays {\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n-            // Revert to scalar multiplication.\n+        // Revert to scalar multiplication for single-element arrays.\n+        if (len == 1) {\n+            return a[0] * b[0];\n+        }\n+\n+            // Split the numbers into low and high parts.\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n@@ -843,6 +849,10 @@ public class MathArrays {\n \n \n         final double prodHighCur = prodHigh[0];\n+        if (len == 1) {\n+            return prodHighCur;\n+        }\n+\n         double prodHighNext = prodHigh[1];\n         double sHighPrev = prodHighCur + prodHighNext;\n         double sPrime = sHighPrev - prodHighNext;\n@@ -871,6 +881,7 @@ public class MathArrays {\n         return result;\n     }\n \n+\n     /**\n      * Compute a linear combination accurately.\n      * <p>"}
{"project": "Math", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "return Complex.INF;", "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f24e..b9bce29c1 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+return Complex.INF;\n         }\n \n         if (isInfinite) {"}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "28", "eval": "PASS", "attempt": 11, "mode": "SF", "patch": "\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions.clear(); // Clear previous positions\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        // Do not return null, instead return the first row for which entry != 0\n        // This should prevent the cycle in the Simplex solver\n        Integer result = null;\n        for (Integer row : minRatioPositions) {\n            final double entry = tableau.getEntry(row, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                result = row;\n                break;\n            }\n        }\n\n        if (result == null) {\n            return null;\n        } else {\n            return result;\n        }\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex a84438d9b..b4692968b 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -87,6 +87,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n      * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n      * @return row with the minimum ratio\n      */\n+\n     private Integer getPivotRow(SimplexTableau tableau, final int col) {\n         // create a list of all the rows that tie for the lowest score in the minimum ratio test\n         List<Integer> minRatioPositions = new ArrayList<Integer>();\n@@ -104,55 +105,31 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n                     minRatioPositions.add(i);\n                 } else if (cmp < 0) {\n                     minRatio = ratio;\n-                    minRatioPositions = new ArrayList<Integer>();\n+                    minRatioPositions.clear(); // Clear previous positions\n                     minRatioPositions.add(i);\n                 }\n             }\n         }\n \n-        if (minRatioPositions.size() == 0) {\n-            return null;\n-        } else if (minRatioPositions.size() > 1) {\n-            // there's a degeneracy as indicated by a tie in the minimum ratio test\n-\n-            // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n-                    }\n-                }\n+        // Do not return null, instead return the first row for which entry != 0\n+        // This should prevent the cycle in the Simplex solver\n+        Integer result = null;\n+        for (Integer row : minRatioPositions) {\n+            final double entry = tableau.getEntry(row, col);\n+            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+                result = row;\n+                break;\n+            }\n+        }\n \n-            // 2. apply Bland's rule to prevent cycling:\n-            //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n-                Integer minRow = null;\n-                int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n-                    }\n-                }\n-                return minRow;\n+        if (result == null) {\n+            return null;\n+        } else {\n+            return result;\n         }\n-        return minRatioPositions.get(0);\n     }\n \n+\n     /**\n      * Runs one iteration of the Simplex method on the given model.\n      * @param tableau simple tableau for the problem"}
{"project": "Math", "bug_id": "30", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        final double n1n2prod = (double)n1 * n2;", "diff": "diff --git a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\nindex ce694ce8f..7ac66f58a 100644\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = (double)n1 * n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;"}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "32", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {", "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex c6e7cf18c..6bc289ff0 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);"}
{"project": "Math", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "34", "eval": "PASS", "attempt": 16, "mode": "SL", "patch": "return java.util.Collections.unmodifiableList(chromosomes).iterator();", "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 1eb005316..f48f8cfcd 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+return java.util.Collections.unmodifiableList(chromosomes).iterator();\n     }\n }"}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "41", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "                for (int i = begin; i < begin + length && i < weights.length; i++) {", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..1e999454e 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length && i < weights.length; i++) {\n                     sumWts += weights[i];\n                 }\n "}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "50", "eval": "PASS", "attempt": 4, "mode": "SH", "patch": "\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..5562ea5ce 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,12 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        x0 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));\n                         f0 = computeObjectiveValue(x0);\n                     }\n+\n                     break;\n                 default:\n                     // Should never happen."}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "53", "eval": "PASS", "attempt": 19, "mode": "SH", "patch": "\nif (rhs.isNaN() || this.isNaN()) {\n    return createComplex(Double.NaN, Double.NaN);\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..53be2ccf5 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,11 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+\n+if (rhs.isNaN() || this.isNaN()) {\n+    return createComplex(Double.NaN, Double.NaN);\n+}\n+\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }"}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "56", "eval": "PASS", "attempt": 9, "mode": "SH", "patch": "\n        int idx = index - count;\n        count += idx;\n        indices[last] = idx;\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\nindex 56c9ffebc..bc1fb78ac 100644\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n@@ -234,14 +234,12 @@ public class MultidimensionalCounter implements Iterable<Integer> {\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n+\n+        int idx = index - count;\n+        count += idx;\n         indices[last] = idx;\n \n+\n         return indices;\n     }\n "}
{"project": "Math", "bug_id": "57", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "double sum = 0.0;", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..9b39fd288 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+double sum = 0.0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);"}
{"project": "Math", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "59", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "return Float.isNaN(a) ? Float.NaN : (a >= b) ? a : b;", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..3a3d47413 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+return Float.isNaN(a) ? Float.NaN : (a >= b) ? a : b;\n     }\n \n     /** Compute the maximum of two values"}
{"project": "Math", "bug_id": "60", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic double cumulativeProbability(double x) throws MathException {\n    final double dev = x - mean;\n    \n    if (x < (mean - 20 * standardDeviation)) {\n        return 0;\n    } else if (x > (mean + 20 * standardDeviation)) {\n        return 1;\n    } else {\n        return 0.5 * (1.0 + Erf.erf((dev) /\n                (standardDeviation * FastMath.sqrt(2.0))));\n    }\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 0e124d852..1f275225f 100644\n--- a/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/main/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -121,21 +121,20 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      * @return CDF evaluated at {@code x}.\n      * @throws MathException if the algorithm fails to converge\n      */\n-    public double cumulativeProbability(double x) throws MathException {\n-        final double dev = x - mean;\n-        try {\n+\n+public double cumulativeProbability(double x) throws MathException {\n+    final double dev = x - mean;\n+    \n+    if (x < (mean - 20 * standardDeviation)) {\n+        return 0;\n+    } else if (x > (mean + 20 * standardDeviation)) {\n+        return 1;\n+    } else {\n         return 0.5 * (1.0 + Erf.erf((dev) /\n-                    (standardDeviation * FastMath.sqrt(2.0))));\n-        } catch (MaxIterationsExceededException ex) {\n-            if (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\n-                return 0;\n-            } else if (x > (mean + 20 * standardDeviation)) {\n-                return 1;\n-            } else {\n-                throw ex;\n-            }\n-        }\n+                (standardDeviation * FastMath.sqrt(2.0))));\n     }\n+}\n+\n \n     /**\n      * Return the absolute accuracy setting of the solver used to estimate"}
{"project": "Math", "bug_id": "63", "eval": "PASS", "attempt": 18, "mode": "SL", "patch": "        return Double.isNaN(x) ^ Double.isNaN(y) || x == y;", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 136184990..c375b01af 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -414,7 +414,7 @@ public final class MathUtils {\n      * @return {@code true} if the values are equal.\n      */\n     public static boolean equals(double x, double y) {\n-        return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n+        return Double.isNaN(x) ^ Double.isNaN(y) || x == y;\n     }\n \n     /**"}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "70", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "72", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\npublic double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, max, yMax, initial, yInitial);\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, min, max, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax <= 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // full Brent algorithm starting with provided initial guess\n        return solve(f, min, max);\n\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..38ae6a838 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,7 +95,8 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n+\n+public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n@@ -112,36 +113,37 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n+        // reduce interval if min and initial bracket the root\n+        if (yInitial * yMin < 0) {\n+            return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        }\n+\n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+            return solve(f, initial, min, max, yMax, initial, yInitial);\n         }\n \n-        if (yMin * yMax > 0) {\n+        if (yMin * yMax <= 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n         // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        return solve(f, min, max);\n+\n+}\n \n-    }\n \n     /**\n      * Find a zero in the given interval."}
{"project": "Math", "bug_id": "73", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\nif (yInitial * yMin >= 0) {\n    throw new IllegalArgumentException(\"Endpoints do not bracket the root\");\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..b296f6b95 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -134,6 +134,11 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n \n+if (yInitial * yMin >= 0) {\n+    throw new IllegalArgumentException(\"Endpoints do not bracket the root\");\n+}\n+\n+\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n "}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "79", "eval": "PASS", "attempt": 13, "mode": "SF", "patch": "\npublic static double distance(int[] p1, int[] p2) {\n    if (p1 == null || p2 == null) {\n        throw new IllegalArgumentException(\"Both point arrays must not be null\");\n    }\n    \n    if (p1.length != p2.length) {\n        throw new IllegalArgumentException(\"Both point arrays must be of the same length\");\n    }\n    \n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = Math.pow(p1[i] - p2[i], 2);\n        sum += dp;\n    }\n    return Math.sqrt(sum);\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MathUtils.java b/src/main/java/org/apache/commons/math/util/MathUtils.java\nindex 46368dc9f..08808e323 100644\n--- a/src/main/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/main/java/org/apache/commons/math/util/MathUtils.java\n@@ -1620,14 +1620,24 @@ public final class MathUtils {\n      * @param p2 the second point\n      * @return the L<sub>2</sub> distance between the two points\n      */\n-    public static double distance(int[] p1, int[] p2) {\n-      int sum = 0;\n-      for (int i = 0; i < p1.length; i++) {\n-          final int dp = p1[i] - p2[i];\n-          sum += dp * dp;\n-      }\n-      return Math.sqrt(sum);\n+\n+public static double distance(int[] p1, int[] p2) {\n+    if (p1 == null || p2 == null) {\n+        throw new IllegalArgumentException(\"Both point arrays must not be null\");\n     }\n+    \n+    if (p1.length != p2.length) {\n+        throw new IllegalArgumentException(\"Both point arrays must be of the same length\");\n+    }\n+    \n+    double sum = 0;\n+    for (int i = 0; i < p1.length; i++) {\n+        final double dp = Math.pow(p1[i] - p2[i], 2);\n+        sum += dp;\n+    }\n+    return Math.sqrt(sum);\n+}\n+\n \n     /**\n      * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points."}
{"project": "Math", "bug_id": "80", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            int j = 4 * (n - 1);", "diff": "diff --git a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\nindex 3fc328d8b..9d1b797be 100644\n--- a/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n+++ b/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java\n@@ -1132,7 +1132,7 @@ public class EigenDecompositionImpl implements EigenDecomposition {\n     private boolean flipIfWarranted(final int n, final int step) {\n         if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n             // flip array\n-            int j = 4 * n - 1;\n+            int j = 4 * (n - 1);\n             for (int i = 0; i < j; i += 4) {\n                 for (int k = 0; k < 4; k += step) {\n                     final double tmp = work[i + k];"}
{"project": "Math", "bug_id": "82", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "if (MathUtils.compareTo(entry, 0, epsilon) > 0) { // Change >= to > or add an else condition", "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b40..e1980b515 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+if (MathUtils.compareTo(entry, 0, epsilon) > 0) { // Change >= to > or add an else condition\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;"}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "85", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "if ((fa < 0.0 && fb < 0.0) || (fa > 0.0 && fb > 0.0)) { ", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf53..f1ced4a6c 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+if ((fa < 0.0 && fb < 0.0) || (fa > 0.0 && fb > 0.0)) { \n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +"}
{"project": "Math", "bug_id": "86", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n\n            if (ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\nindex acd9222f6..377d2dd3d 100644\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -90,6 +90,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n+\n     public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                      final double relativeSymmetryThreshold,\n                                      final double absolutePositivityThreshold)\n@@ -135,6 +136,9 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n             // check diagonal element\n \n+            if (ltI[i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n \n@@ -150,6 +154,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n     }\n \n+\n     /** {@inheritDoc} */\n     public RealMatrix getL() {\n         if (cachedL == null) {"}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "89", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\npublic void addValue(Object v) {\n    if (v instanceof Comparable) {\n        addValue((Comparable<?>) v);\n    } else {\n        // Handle non-comparable objects or throw an exception\n        // For this example, we'll throw an exception\n        throw new IllegalArgumentException(\"The object is not comparable\");\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca31a..45fa4f917 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -106,9 +106,17 @@ public class Frequency implements Serializable {\n      * @deprecated use {@link #addValue(Comparable)} instead\n      */\n     @Deprecated\n-    public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+\n+public void addValue(Object v) {\n+    if (v instanceof Comparable) {\n+        addValue((Comparable<?>) v);\n+    } else {\n+        // Handle non-comparable objects or throw an exception\n+        // For this example, we'll throw an exception\n+        throw new IllegalArgumentException(\"The object is not comparable\");\n     }\n+}\n+\n     \n     /**\n      * Adds 1 to the frequency count for v."}
{"project": "Math", "bug_id": "91", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "94", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "if (u == 0 || v == 0) {", "diff": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex c5342aeb3..f2275a389 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+if (u == 0 || v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to"}
{"project": "Math", "bug_id": "95", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\n    protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n        // use mean\n        if (d <= 2.0) {\n            // For small degrees of freedom, use a different formula\n            ret = 0.5;\n        } else {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97aef..95144b6cd 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -140,13 +140,20 @@ public class FDistributionImpl\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+\n     protected double getInitialDomain(double p) {\n         double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n+        // use mean\n+        if (d <= 2.0) {\n+            // For small degrees of freedom, use a different formula\n+            ret = 0.5;\n+        } else {\n             ret = d / (d - 2.0);\n+        }\n         return ret;\n     }\n+\n     \n     /**\n      * Modify the numerator degrees of freedom."}
{"project": "Math", "bug_id": "96", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "ret = this.real == rhs.getReal() && this.imaginary == rhs.getImaginary();", "diff": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 3571567f8..3733d2f97 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+ret = this.real == rhs.getReal() && this.imaginary == rhs.getImaginary();\n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception"}
{"project": "Math", "bug_id": "97", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n        \n    clearResult();\n    verifyInterval(min, max);\n    \n    double ret = Double.NaN;\n    \n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    \n    // Check if yMin equals 0, in which case it's a root\n    if (Math.abs(yMin) < 1e-10) {\n        return min; // yMin equals 0, return min as a root\n    }\n    \n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign >= 0) {\n        // Check if yMax equals 0, in which case it's a root\n        if (Math.abs(yMax) < 1e-10) {\n            return max; // yMax equals 0, return max as a root\n        } else {\n            // check if either value is close to a zero\n            throw new IllegalArgumentException\n            (\"Function values at endpoints do not have different signs.\" +\n                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n    }\n\n    return ret;\n}\n", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..2fd74edc6 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,45 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        \n-        double ret = Double.NaN;\n-        \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n+\n+public double solve(double min, double max) throws MaxIterationsExceededException, \n+    FunctionEvaluationException {\n         \n-        // Verify bracketing\n-        double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+    clearResult();\n+    verifyInterval(min, max);\n+    \n+    double ret = Double.NaN;\n+    \n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+    \n+    // Check if yMin equals 0, in which case it's a root\n+    if (Math.abs(yMin) < 1e-10) {\n+        return min; // yMin equals 0, return min as a root\n+    }\n+    \n+    // Verify bracketing\n+    double sign = yMin * yMax;\n+    if (sign >= 0) {\n+        // Check if yMax equals 0, in which case it's a root\n+        if (Math.abs(yMax) < 1e-10) {\n+            return max; // yMax equals 0, return max as a root\n         } else {\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n-            // either min or max is a root\n+            // check if either value is close to a zero\n+            throw new IllegalArgumentException\n+            (\"Function values at endpoints do not have different signs.\" +\n+                    \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n+                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n         }\n-\n-        return ret;\n+    } else {\n+        // solve using only the first endpoint as initial guess\n+        ret = solve(min, yMin, max, yMax, min, yMin);\n+        // either min or max is a root\n     }\n+\n+    return ret;\n+}\n+\n         \n     /**\n      * Find a zero starting search according to the three provided points."}
{"project": "Math", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "103", "eval": "PASS", "attempt": 12, "mode": "SF", "patch": "\npublic double cumulativeProbability(double x) throws MathException {\n    if (x < mean - 5 * standardDeviation) {\n        // Use approximation for lower tail\n        return Math.exp(-((x - mean) * (x - mean) / (2 * standardDeviation * standardDeviation)));\n    } else if (x > mean + 5 * standardDeviation) {\n        // Use approximation for upper tail\n        return 1 - Math.exp(-((x - mean) * (x - mean) / (2 * standardDeviation * standardDeviation)));\n    } else {\n        // Use standard implementation\n        return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\nindex 02810e142..78c7e853d 100644\n--- a/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/NormalDistributionImpl.java\n@@ -105,10 +105,20 @@ public class NormalDistributionImpl extends AbstractContinuousDistribution\n      * x is more than 20 standard deviations from the mean, in which case the\n      * convergence exception is caught and 0 or 1 is returned.\n      */\n-    public double cumulativeProbability(double x) throws MathException {\n-            return 0.5 * (1.0 + Erf.erf((x - mean) /\n-                    (standardDeviation * Math.sqrt(2.0))));\n+\n+public double cumulativeProbability(double x) throws MathException {\n+    if (x < mean - 5 * standardDeviation) {\n+        // Use approximation for lower tail\n+        return Math.exp(-((x - mean) * (x - mean) / (2 * standardDeviation * standardDeviation)));\n+    } else if (x > mean + 5 * standardDeviation) {\n+        // Use approximation for upper tail\n+        return 1 - Math.exp(-((x - mean) * (x - mean) / (2 * standardDeviation * standardDeviation)));\n+    } else {\n+        // Use standard implementation\n+        return 0.5 * (1.0 + Erf.erf((x - mean) / (standardDeviation * Math.sqrt(2.0))));\n     }\n+}\n+\n     \n     /**\n      * For this distribution, X, this method returns the critical point x, such"}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "105", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "return Math.max(0, sumYY - sumXY * sumXY / sumXX);", "diff": "diff --git a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\nindex dcf512b72..4410c2655 100644\n--- a/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n+++ b/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java\n@@ -261,7 +261,7 @@ public class SimpleRegression implements Serializable {\n      * @return sum of squared errors associated with the regression model\n      */\n     public double getSumSquaredErrors() {\n-        return sumYY - sumXY * sumXY / sumXX;\n+return Math.max(0, sumYY - sumXY * sumXY / sumXX);\n     }\n \n     /**"}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        primitiveValues.put(double.class, 0D);", "diff": "diff --git a/src/org/mockito/internal/util/Primitives.java b/src/org/mockito/internal/util/Primitives.java\nindex b44b8253d..48ab82398 100644\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public class Primitives {\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+        primitiveValues.put(double.class, 0D);\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "33", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic boolean hasSameMethod(Invocation candidate) {        \n    //not using method.equals() for 1 good reason:\n    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n    \n    /* Avoid unnecessary cloning */\n    boolean hasSameSignature = m1.getName().equals(m2.getName()) && \n                               hasSameParameterTypes(m1, m2);\n    \n    return hasSameSignature;\n}\n\nprivate boolean hasSameParameterTypes(Method m1, Method m2) {\n    Class<?>[] paramTypes1 = m1.getParameterTypes();\n    Class<?>[] paramTypes2 = m2.getParameterTypes();\n    \n    if (paramTypes1.length != paramTypes2.length) {\n        return false;\n    }\n    \n    for (int i = 0; i < paramTypes1.length; i++) {\n        if (paramTypes1[i] != paramTypes2[i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n", "diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex 203413fc9..019decfc0 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -89,16 +89,38 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n         return !overloadedButSameArgs;\n     }\n \n-    public boolean hasSameMethod(Invocation candidate) {        \n-        //not using method.equals() for 1 good reason:\n-        //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n-        Method m1 = invocation.getMethod();\n-        Method m2 = candidate.getMethod();\n-        \n-        \t/* Avoid unnecessary cloning */\n-        return m1.equals(m2);\n+\n+public boolean hasSameMethod(Invocation candidate) {        \n+    //not using method.equals() for 1 good reason:\n+    //sometimes java generates forwarding methods when generics are in play see JavaGenericsForwardingMethodsTest\n+    Method m1 = invocation.getMethod();\n+    Method m2 = candidate.getMethod();\n+    \n+    /* Avoid unnecessary cloning */\n+    boolean hasSameSignature = m1.getName().equals(m2.getName()) && \n+                               hasSameParameterTypes(m1, m2);\n+    \n+    return hasSameSignature;\n+}\n+\n+private boolean hasSameParameterTypes(Method m1, Method m2) {\n+    Class<?>[] paramTypes1 = m1.getParameterTypes();\n+    Class<?>[] paramTypes2 = m2.getParameterTypes();\n+    \n+    if (paramTypes1.length != paramTypes2.length) {\n+        return false;\n     }\n     \n+    for (int i = 0; i < paramTypes1.length; i++) {\n+        if (paramTypes1[i] != paramTypes2[i]) {\n+            return false;\n+        }\n+    }\n+    \n+    return true;\n+}\n+\n+    \n     public Location getLocation() {\n         return invocation.getLocation();\n     }\n@@ -126,4 +148,4 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n \n         return out;\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "if (m instanceof CapturesArguments && k < i.getArguments().length) {", "diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex c72b119dd..367df6386 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -103,10 +103,10 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+if (m instanceof CapturesArguments && k < i.getArguments().length) {\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return arg == null ? StringDescription.toString(m).equals(null) : StringDescription.toString(m).equals(arg.toString());", "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc539..7d6294195 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -44,7 +44,8 @@ public class ArgumentMatchingTool {\n         }\n     }\n \n+\n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        return arg == null ? StringDescription.toString(m).equals(null) : StringDescription.toString(m).equals(arg.toString());\n     }\n }"}
{"project": "Time", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "19", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "} else if (offsetLocal >= 0) {", "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad05..dc2b2b04 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -897,7 +897,7 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n+} else if (offsetLocal >= 0) {\n             long prev = previousTransition(instantAdjusted);\n             if (prev < instantAdjusted) {\n                 int offsetPrev = getOffset(prev);"}
{"project": "Time", "bug_id": "20", "eval": "PASS", "attempt": 19, "mode": "SF", "patch": "\npublic int parseInto(DateTimeParserBucket bucket, String text, int position) {\n    String str = text.substring(position);\n    for (String id : ALL_IDS) {\n        if (str.startsWith(id) && str.length() == id.length()) {\n            bucket.setZone(DateTimeZone.forID(id));\n            return position + id.length();\n        }\n    }\n    return ~position;\n}\n", "diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\nindex 558a5864..a468d23a 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatterBuilder.java\n@@ -2537,17 +2537,19 @@ public class DateTimeFormatterBuilder {\n             return MAX_LENGTH;\n         }\n \n-        public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n-            String str = text.substring(position);\n-            for (String id : ALL_IDS) {\n-                if (str.startsWith(id)) {\n-                    bucket.setZone(DateTimeZone.forID(id));\n-                    return position + id.length();\n-                }\n-            }\n-            return ~position;\n+\n+public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+    String str = text.substring(position);\n+    for (String id : ALL_IDS) {\n+        if (str.startsWith(id) && str.length() == id.length()) {\n+            bucket.setZone(DateTimeZone.forID(id));\n+            return position + id.length();\n         }\n     }\n+    return ~position;\n+}\n+\n+    }\n \n     //-----------------------------------------------------------------------\n     static class Composite"}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
