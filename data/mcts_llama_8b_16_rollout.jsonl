{"project": "Chart", "bug_id": "1", "eval": "PASS", "patch": "if (this.plot == null) {", "rollout": 1}
{"project": "Chart", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "patch": "public Range getDataRange(ValueAxis axis) {\n    Range result = null;\n    List mappedDatasets = new ArrayList();\n    List includedAnnotations = new ArrayList();\n    boolean isDomainAxis = true;\n\n    // is it a domain axis?\n    int domainIndex = getDomainAxisIndex(axis);\n    if (domainIndex >= 0) {\n        isDomainAxis = true;\n        if (getDatasetsMappedToDomainAxis(new Integer(domainIndex)) != null) {\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(new Integer(domainIndex)));\n        }\n        if (domainIndex == 0) {\n            // grab the plot's annotations\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // or is it a range axis?\n    int rangeIndex = getRangeAxisIndex(axis);\n    if (rangeIndex >= 0) {\n        isDomainAxis = false;\n        if (getDatasetsMappedToRangeAxis(new Integer(rangeIndex)) != null) {\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(new Integer(rangeIndex)));\n        }\n        if (rangeIndex == 0) {\n            Iterator iterator = this.annotations.iterator();\n            while (iterator.hasNext()) {\n                XYAnnotation annotation = (XYAnnotation) iterator.next();\n                if (annotation instanceof XYAnnotationBoundsInfo) {\n                    includedAnnotations.add(annotation);\n                }\n            }\n        }\n    }\n\n    // iterate through the datasets that map to the axis and get the union\n    // of the ranges.\n    Iterator iterator = mappedDatasets.iterator();\n    while (iterator.hasNext()) {\n        XYDataset d = (XYDataset) iterator.next();\n        XYItemRenderer r = getRendererForDataset(d);\n        if (r != null) {\n            if (isDomainAxis) {\n                result = Range.combine(result, r.findDomainBounds(d));\n            } else {\n                result = Range.combine(result, r.findRangeBounds(d));\n            }\n            // Also check if the renderer has annotations\n            Collection c = r.getAnnotations();\n            if(c != null) {\n                Iterator i = c.iterator();\n                while (i.hasNext()) {\n                    XYAnnotation a = (XYAnnotation) i.next();\n                    if (a instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(a);\n                    }\n                }\n            }\n        } else {\n            if (isDomainAxis) {\n                if (d != null) { // Add a null check here\n                    result = Range.combine(result, DatasetUtilities.findDomainBounds(d));\n                }\n            } else {\n                if (d != null) { // Add a null check here\n                    result = Range.combine(result, DatasetUtilities.findRangeBounds(d));\n                }\n            }\n        }\n    }\n\n    Iterator it = includedAnnotations.iterator();\n    while (it.hasNext()) {\n        XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n        if (xyabi.getIncludeInDataBounds()) {\n            if (isDomainAxis) {\n                result = Range.combine(result, xyabi.getXRange());\n            } else {\n                result = Range.combine(result, xyabi.getYRange());\n            }\n        }\n    }\n\n    return result;\n}", "rollout": 14}
{"project": "Chart", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "patch": "private void updateBounds(TimePeriod period, int index) {\n    \n    long start = period.getStart().getTime();\n    long end = period.getEnd().getTime();\n    long middle = start + (end - start) / 2 + (end - start) % 2;\n\n    if (this.minStartIndex >= 0) {\n        long minStart = getDataItem(this.minStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start < minStart) {\n            this.minStartIndex = index;           \n        }\n    }\n    else {\n        this.minStartIndex = index;\n    }\n    \n    if (this.maxStartIndex >= 0) {\n        long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n            .getStart().getTime();\n        if (start > maxStart) {\n            this.maxStartIndex = index;           \n        }\n    }\n    else {\n        this.maxStartIndex = index;\n    }\n    \n    if (this.minMiddleIndex >= 0) {\n        long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long minMiddle = s + (e - s) / 2;\n        if (middle < minMiddle) {\n            this.minMiddleIndex = index;           \n        }\n    }\n    else {\n        this.minMiddleIndex = index;\n    }\n    \n    if (this.maxMiddleIndex >= 0) {\n        long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n            .getTime();\n        long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n            .getTime();\n        long maxMiddle = s + (e - s) / 2;\n        if (middle > maxMiddle) {\n            this.maxMiddleIndex = index;           \n        }\n    }\n    else {\n        this.maxMiddleIndex = index;\n    }\n    \n    if (this.minEndIndex >= 0) {\n        long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end < minEnd) {\n            this.minEndIndex = index;           \n        }\n    }\n    else {\n        this.minEndIndex = index;\n    }\n   \n    if (this.maxEndIndex >= 0) {\n        long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n            .getTime();\n        if (end > maxEnd) {\n            this.maxEndIndex = index;           \n        }\n    }\n    else {\n        this.maxEndIndex = index;\n    }\n}", "rollout": 2}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "patch": "this(time, zone, Locale.getDefault());", "rollout": 5}
{"project": "Chart", "bug_id": "9", "eval": "PASS", "patch": "if (startIndex > endIndex) {", "rollout": 8}
{"project": "Chart", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "patch": "PathIterator iterator2 = p2.getPathIterator(null);", "rollout": 1}
{"project": "Chart", "bug_id": "12", "eval": "PASS", "patch": "this.setDataset(dataset);", "rollout": 5}
{"project": "Chart", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "rollout": 1}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Chart", "bug_id": "26", "eval": "PASS", "patch": "protected AxisState drawLabel(String label, Graphics2D g2, \n                Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n                AxisState state, PlotRenderingInfo plotState) {\n\n    // it is unlikely that 'state' will be null, but check anyway...\n    if (state == null) {\n        throw new IllegalArgumentException(\"Null 'state' argument.\");\n    }\n    \n    if ((label == null) || (label.equals(\"\"))) {\n        return state;\n    }\n\n    Font font = getLabelFont();\n    RectangleInsets insets = getLabelInsets();\n    g2.setFont(font);\n    g2.setPaint(getLabelPaint());\n    FontMetrics fm = g2.getFontMetrics();\n    Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n    Shape hotspot = null;\n    \n    if (edge == RectangleEdge.TOP) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() - insets.getBottom() \n                - h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.BOTTOM) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle(), labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) dataArea.getCenterX();\n        float labely = (float) (state.getCursor() + insets.getTop() \n                + h / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                + insets.getBottom());\n    }\n    else if (edge == RectangleEdge.LEFT) {\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() - insets.getRight() \n                - w / 2.0);\n        float labely = (float) dataArea.getCenterY();\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n    }\n    else if (edge == RectangleEdge.RIGHT) {\n\n        AffineTransform t = AffineTransform.getRotateInstance(\n                getLabelAngle() + Math.PI / 2.0, \n                labelBounds.getCenterX(), labelBounds.getCenterY());\n        Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n        labelBounds = rotatedLabelBounds.getBounds2D();\n        float w = (float) labelBounds.getWidth();\n        float h = (float) labelBounds.getHeight();\n        float labelx = (float) (state.getCursor() \n                        + insets.getLeft() + w / 2.0);\n        float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                / 2.0);\n        TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                TextAnchor.CENTER);\n        hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                labely - h / 2.0f, w, h);\n        state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                + insets.getRight());\n\n    }\n    \n    if (plotState != null && hotspot != null) {\n        ChartRenderingInfo owner = plotState.getOwner();\n        if (owner != null) {\n            EntityCollection entities = owner.getEntityCollection();\n            if (entities != null) {\n                entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL));\n            }\n        }\n    }\n    \n    return state;\n\n}", "rollout": 1}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "3", "eval": "PASS", "patch": "return Double.valueOf(str);", "rollout": 4}
{"project": "Cli", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "patch": "if (str == null) {\n    return null; // or throw new NullPointerException(\"Input string is null\");\n}", "rollout": 10}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "patch": "            pos = findWrapPos(text, width - nextLineTabStop, nextLineTabStop);", "rollout": 2}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "patch": "protected void checkRequiredOptions()\n    throws MissingOptionException\n{\n    // if there are required options that have not been\n    // processed\n    if (getRequiredOptions().size() > 0)\n    {\n        Iterator iter = getRequiredOptions().iterator();\n        StringBuffer buff = new StringBuffer(\"Missing required option\");\n        buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n        buff.append(\": \");\n\n        // loop through the required options\n        String sep = \"\";\n        while (iter.hasNext())\n        {\n            buff.append(sep);\n            buff.append(iter.next());\n            sep = \", \";\n        }\n\n        throw new MissingOptionException(buff.toString());\n    }\n}", "rollout": 2}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "patch": "if (option.hasArg() && option.getArgName().length() > 0)", "rollout": 1}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "17", "eval": "PASS", "patch": "i++;", "rollout": 5}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "24", "eval": "PASS", "patch": "            if (nextLineTabStop >= width)\n            {\n                nextLineTabStop = width - 1;\n            }", "rollout": 1}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "32", "eval": "PASS", "patch": "while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n        && (c != '\\n') && (c != '\\r'))\n{\n    --pos;\n}\nif (pos < startPos) {\n    pos = startPos + width;\n    if (pos == text.length()) {\n        return -1;\n    }\n} else {\n    pos++;\n}", "rollout": 2}
{"project": "Cli", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "patch": "private String getOptionName(String token)\n{\n    // get the option name (without leading \"-\" and trailing \"=value\")\n    int i = token.indexOf('=');\n    if (i > 0) {\n        return token.substring(1, i);\n    } else {\n        return token.substring(1);\n    }\n}\n\nprivate boolean isShortOption(String token)\n{\n    // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n    return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(getOptionName(token));\n}", "rollout": 1}
{"project": "Cli", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "patch": "throw new ParseException(\"Unsupported type: \" + clazz.getName());", "rollout": 1}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "patch": "private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    if (implicitProto == null) {\n        return; // This interface extends non-existent object\n    }\n    Set<String> currentPropertyNames = implicitProto.getOwnPropertyNames();\n    for (String name : currentPropertyNames) {\n      ObjectType oType = properties.get(name);\n      if (oType != null) {\n        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n            oType.getPropertyType(name))) {\n          compiler.report(\n              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                  functionName, name, oType.toString(),\n                  interfaceType.toString()));\n        }\n      }\n      currentProperties.put(name, interfaceType);\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n      checkInterfaceConflictProperties(t, n, functionName, properties,\n          currentProperties, iType);\n    }\n  }", "rollout": 1}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "patch": "return mayBeStringHelper(n);", "rollout": 1}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "13", "eval": "PASS", "patch": "private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n        // If shouldVisit returns false, we still need to\n        // traverse the node to ensure that its children are\n        // updated in the traversal state.\n        traverseChildren(node);\n        return;\n    }\n\n    int visits = 0;\n    do {\n        Node c = node.getFirstChild();\n        while(c != null) {\n            traverse(c);\n            Node next = c.getNext();\n            c = next;\n        }\n\n        visit(node);\n        visits++;\n\n        Preconditions.checkState(visits < 10000, \"too many iterations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n}\n\nprivate void traverseChildren(Node node) {\n    // Traverse the children of the node to ensure they are updated\n    // in the traversal state.\n    Node child = node.getFirstChild();\n    while (child != null) {\n        traverse(child);\n        Node next = child.getNext();\n        child = next;\n    }\n}", "rollout": 2}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "patch": "if (options.dependencyOptions.needsManagement()", "rollout": 4}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:  // Skip toStringTree() call for Token.THIS nodes\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \");\n    }\n}", "rollout": 1}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "patch": "options.dependencyOptions.needsManagement() &&", "rollout": 3}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "38", "eval": "PASS", "patch": "if ((long) x <= 0 && prev == '-') {", "rollout": 5}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "57", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "62", "eval": "PASS", "patch": "|| charno == sourceExcerpt.length()) {", "rollout": 7}
{"project": "Closure", "bug_id": "65", "eval": "PASS", "patch": "case '\\0': sb.append(\"\\\\000\"); break;", "rollout": 6}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "patch": "if (c >= 0x20 && c <= 0x7e) {", "rollout": 4}
{"project": "Closure", "bug_id": "77", "eval": "PASS", "patch": "case '\\0': sb.append(\"\\\\0\"); break;", "rollout": 1}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "92", "eval": "PASS", "patch": "int indexOfDot = namespace.lastIndexOf('.');", "rollout": 4}
{"project": "Closure", "bug_id": "94", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "101", "eval": "PASS", "patch": "  protected CompilerOptions createOptions() {\n    CompilerOptions options = new CompilerOptions();\n    options.setCodingConvention(new ClosureCodingConvention());\n    CompilationLevel level = flags.compilation_level;\n    level.setOptionsForCompilationLevel(options);\n    if (flags.debug) {\n      level.setDebugOptionsForCompilationLevel(options);\n    }\n\n    WarningLevel wLevel = flags.warning_level;\n    wLevel.setOptionsForWarningLevel(options);\n    for (FormattingOption formattingOption : flags.formatting) {\n      formattingOption.applyToOptions(options);\n    }\n    /**\n     * After adding check, now set options.closurePass based on flags.process_closure_primitives\n     */\n    options.closurePass = flags.process_closure_primitives;\n\n    initOptionsFromFlags(options);\n    return options;\n  }", "rollout": 9}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "107", "eval": "PASS", "patch": "options.messageBundle = null;", "rollout": 7}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "119", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "122", "eval": "PASS", "patch": "if ((comment.getValue().toLowerCase().indexOf(\"@\") != -1 && (comment.getValue().toLowerCase().indexOf(\"/* @\") == -1 || comment.getValue().toLowerCase().indexOf(\"/ * @\") == -1)) || \n    (comment.getValue().indexOf(\"\\n\") != -1 && (comment.getValue().toLowerCase().indexOf(\"@\")) != -1)) {", "rollout": 1}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "124", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "125", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "patch": "// Check if the finally block contains an exit point before recursing\nif (n.isTry() && NodeUtil.hasFinally(n)) {\n  Node finallyBlock = n.getLastChild();\n  if (!matchingExitNode(finallyBlock, exitType, labelName)) {\n    Node finallyCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(finallyCatchNodes)) {\n      Preconditions.checkState(finallyCatchNodes.hasOneChild());\n      Node catchNode = finallyCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n  }\n}", "rollout": 8}
{"project": "Closure", "bug_id": "128", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "129", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "131", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "152", "eval": "PASS", "patch": "JSType originalTypeOfThis = typeOfThis;\nif (!(originalTypeOfThis instanceof ObjectType)) {\n    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n}", "rollout": 14}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "161", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "patch": "if (t.inGlobalScope()) {", "rollout": 14}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "5", "eval": "PASS", "patch": "if (buffer == null || buffer.length - pos < decodeSize) {\n    resizeBuffer();\n}", "rollout": 10}
{"project": "Codec", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "7", "eval": "PASS", "patch": "        return StringUtils.newStringUtf8(encodeBase64(binaryData));", "rollout": 7}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "patch": "int len = binaryData.length;", "rollout": 10}
{"project": "Codec", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "patch": "return bytes == null ? null : new String(bytes, 0, bytes.length);", "rollout": 16}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "patch": "return cs1.toString().equals(cs2.toString());", "rollout": 5}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "15", "eval": "PASS", "patch": "public boolean equals(Object obj) {\n    if (this == obj) {\n        return true;\n    }\n    if (obj == null || getClass() != obj.getClass()) {\n        return false;\n    }\n    ZipArchiveEntry other = (ZipArchiveEntry) obj;\n    String myName = getName();\n    String otherName = other.getName();\n    if (myName == null) {\n        if (otherName != null) {\n            return false;\n        }\n    } else if (!myName.equals(otherName)) {\n        return false;\n    }\n    String myComment = getComment();\n    String otherComment = other.getComment();\n    if ((myComment == null && otherComment != null && !otherComment.equals(\"\")) ||\n        (myComment != null && otherComment == null) ||\n        (myComment != null && otherComment != null && !myComment.equals(otherComment))) {\n        return false;\n    }\n    return getTime() == other.getTime()\n        && getInternalAttributes() == other.getInternalAttributes()\n        && getPlatform() == other.getPlatform()\n        && getExternalAttributes() == other.getExternalAttributes()\n        && getMethod() == other.getMethod()\n        && getSize() == other.getSize()\n        && getCrc() == other.getCrc()\n        && getCompressedSize() == other.getCompressedSize()\n        && Arrays.equals(getCentralDirectoryExtra(),\n                         other.getCentralDirectoryExtra())\n        && Arrays.equals(getLocalFileDataExtra(),\n                         other.getLocalFileDataExtra())\n        && gpb.equals(other.gpb);\n}", "rollout": 11}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "19", "eval": "PASS", "patch": "if (rawCentralDirectoryData.length < expectedLength) {", "rollout": 2}
{"project": "Compress", "bug_id": "21", "eval": "PASS", "patch": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n    int cache = 0;\n    int shift = 7;\n    for (int i = 0; i < length; i++) {\n        if (bits.get(i)) {\n            cache |= 1 << shift;\n        }\n        shift--;\n        if (shift == -1 || i == length - 1) {\n            header.write(cache);\n            cache = 0;\n            shift = 7;\n        }\n    }\n}", "rollout": 7}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "patch": "dictSize |= (coder.properties[i + 1] & 0xffl) << (8 * i)", "rollout": 7}
{"project": "Compress", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "patch": "// ignore length 1 buffer with trailing NUL or space\n", "rollout": 2}
{"project": "Compress", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "30", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "patch": "if (currentByte == '0' && start == offset && (length == 1 || buffer[start + 1] < '0' || buffer[start + 1] > '7')) {\n    throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, currentByte));\n}", "rollout": 9}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "patch": "private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n    for (Entry<String, String> ent : headers.entrySet()){\n        String key = ent.getKey();\n        String val = ent.getValue();\n        if (\"path\".equals(key)){\n            currEntry.setName(val);\n        } else if (\"linkpath\".equals(key)){\n            currEntry.setLinkName(val);\n        } else if (\"gid\".equals(key)){\n            currEntry.setGroupId(Long.parseLong(val));\n        } else if (\"gname\".equals(key)){\n            currEntry.setGroupName(val);\n        } else if (\"uid\".equals(key)){\n            currEntry.setUserId(Long.parseLong(val));\n        } else if (\"uname\".equals(key)){\n            currEntry.setUserName(val);\n        } else if (\"size\".equals(key)){\n            currEntry.setSize(Long.parseLong(val));\n        } else if (\"mtime\".equals(key)){\n            currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n        } else if (\"SCHILY.devminor\".equals(key)){\n            currEntry.setDevMinor(Integer.parseInt(val));\n        } else if (\"SCHILY.devmajor\".equals(key)){\n            currEntry.setDevMajor(Integer.parseInt(val));\n        }\n    }\n}", "rollout": 1}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "patch": "public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n    if (checksum == null || in == null) {\n        throw new NullPointerException(\"Checksum or InputStream cannot be null\");\n    }\n    this.checksum = checksum;\n    this.in = in;\n}", "rollout": 1}
{"project": "Compress", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Compress", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "patch": "public String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Object indexValue = mapping.get(name);\n    if (indexValue == null) {\n        return null;  // invalid field name, return null\n    }\n    if (!(indexValue instanceof Integer)) {\n        throw new IllegalArgumentException(\"Invalid value for field '\" + name + \"': \" + indexValue);\n    }\n    final int index = ((Integer) indexValue).intValue();\n    if (index < 0 || index >= values.length) {\n        throw new IllegalArgumentException(\"Index out of bounds for field '\" + name + \"'\");\n    }\n    return values[index];\n}", "rollout": 7}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "patch": "public void println() throws IOException {\n    final String recordSeparator = format.getRecordSeparator();\n    if (recordSeparator != null) {\n        out.append(recordSeparator);\n    }\n    newRecord = true;\n}", "rollout": 2}
{"project": "Csv", "bug_id": "6", "eval": "PASS", "patch": "public Iterator<String> iterator() {\n    return toList().iterator();\n}\n\n/**\n * Puts all values of this record into the given Map.\n *\n * @param map The Map to populate.\n * @return the given map.\n */\n<M extends Map<String, String>> M putIn(final M map) {\n    for (final Entry<String, Integer> entry : mapping.entrySet()) {\n        final int col = entry.getValue().intValue();\n        if (col < values.length && col >= 0) {\n            map.put(entry.getKey(), values[col]);\n        }\n    }\n    return map;\n}", "rollout": 2}
{"project": "Csv", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "patch": "if (len <= 0) {", "rollout": 6}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "patch": "                if (newRecord && Character.isISOControl(c)) {\n                    quote = true;\n                } else if (c <= COMMENT) {", "rollout": 1}
{"project": "Gson", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "patch": "public char[] expandCurrentSegment()\n{\n    final char[] curr = _currentSegment;\n    // Let's grow by 50% by default\n    final int len = curr.length;\n    // but above intended maximum, slow to increase by 1 character\n    int newLen = (len == MAX_SEGMENT_LEN) ? Math.min(MAX_SEGMENT_LEN + 1, len + (len >> 1)) : (int) (1.5 * len);\n    return (_currentSegment = Arrays.copyOf(curr, newLen));\n}", "rollout": 2}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "patch": "int c = str.charAt(i);", "rollout": 2}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "patch": "if (_currentSegment != null && !_hasSegments)  return _currentSegment;", "rollout": 1}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "patch": "if (i < maxCode) {", "rollout": 2}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "PASS", "patch": "protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n        Class<?> mixInCls, AnnotatedMethodMap mixIns)\n{\n    List<Class<?>> parents = new ArrayList<Class<?>>();\n    parents.add(mixInCls);\n    ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n    while (!parents.isEmpty()) {\n        Class<?> parent = parents.remove(parents.size() - 1);\n        for (Method m : parent.getDeclaredMethods()) {\n            if (!_isIncludableMemberMethod(m)) {\n                continue;\n            }\n            AnnotatedMethod am = methods.find(m);\n            /* Do we already have a method to augment (from sub-class\n             * that will mask this mixin)? If so, add if visible\n             * without masking (no such annotation)\n             */\n            if (am != null) {\n                _addMixUnders(m, am);\n                /* Otherwise will have precedence, but must wait\n                 * until we find the real method (mixIn methods are\n                 * just placeholder, can't be called)\n                 */\n            } else {\n                // Well, or, as per [Issue#515], multi-level merge within mixins...\n                mixIns.add(_constructMethod(m));\n            }\n        }\n    }\n}", "rollout": 7}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "PASS", "patch": "return true;", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "patch": "if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "patch": "visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "PASS", "patch": "protected BeanPropertyWriter buildWriter(SerializerProvider prov,\n        BeanPropertyDefinition propDef, JavaType declaredType, JsonSerializer<?> ser,\n        TypeSerializer typeSer, TypeSerializer contentTypeSer,\n        AnnotatedMember am, boolean defaultUseStaticTyping)\n        throws JsonMappingException\n{\n    // do we have annotation that forces type to use (to declared type or its super type)?\n    JavaType serializationType = findSerializationType(am, defaultUseStaticTyping, declaredType);\n\n    // Container types can have separate type serializers for content (value / element) type\n    if (contentTypeSer != null) {\n        /* 04-Feb-2010, tatu: Let's force static typing for collection, if there is\n         *    type information for contents. Should work well (for JAXB case); can be\n         *    revisited if this causes problems.\n         */\n        if (serializationType == null) {\n//                serializationType = TypeFactory.type(am.getGenericType(), _beanDesc.getType());\n            serializationType = declaredType;\n        }\n        JavaType ct = serializationType.getContentType();\n        // Not exactly sure why, but this used to occur; better check explicitly:\n        if (ct == null) {\n            throw new IllegalStateException(\"Problem trying to create BeanPropertyWriter for property '\"\n                    +propDef.getName()+\"' (of type \"+_beanDesc.getType()+\"); serialization type \"+serializationType+\" has no content\");\n        }\n        serializationType = serializationType.withContentTypeHandler(contentTypeSer);\n        ct = serializationType.getContentType();\n    }\n    \n    Object valueToSuppress = null;\n    boolean suppressNulls = false;\n\n    JsonInclude.Value inclV = _defaultInclusion.withOverrides(propDef.findInclusion());\n    JsonInclude.Include inclusion = inclV.getValueInclusion();\n    if (inclusion == JsonInclude.Include.USE_DEFAULTS) { // should not occur but...\n        inclusion = JsonInclude.Include.ALWAYS;\n    }\n\n    // 12-Jul-2016, tatu: [databind#1256] Need to make sure we consider type refinement\n    JavaType actualType = (serializationType == null) ? declaredType : serializationType;\n    \n    switch (inclusion) {\n    case NON_DEFAULT:\n        // 11-Nov-2015, tatu: This is tricky because semantics differ between cases,\n        //    so that if enclosing class has this, we may need to values of property,\n        //    whereas for global defaults OR per-property overrides, we have more\n        //    static definition. Sigh.\n        // First: case of class specifying it; try to find POJO property defaults\n        if (_defaultInclusion.getValueInclusion() == JsonInclude.Include.NON_DEFAULT) {\n            valueToSuppress = getPropertyDefaultValue(propDef.getName(), am, actualType);\n        } else {\n            valueToSuppress = getDefaultValue(actualType);\n        }\n        if (valueToSuppress == null) {\n            suppressNulls = true;\n        } else {\n            if (valueToSuppress.getClass().isArray()) {\n                valueToSuppress = ArrayBuilders.getArrayComparator(valueToSuppress);\n            }\n        }\n\n        break;\n    case NON_ABSENT: // new with 2.6, to support Guava/JDK8 Optionals\n        // always suppress nulls\n        suppressNulls = true;\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY; // Add this line\n        // and for referential types, also \"empty\", which in their case means \"absent\"\n        if (declaredType.isReferenceType()) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    case NON_EMPTY:\n        // always suppress nulls\n        suppressNulls = true;\n        // but possibly also 'empty' values:\n        valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        break;\n    case NON_NULL:\n        suppressNulls = true;\n        // fall through\n    case ALWAYS: // default\n    default:\n        // we may still want to suppress empty collections, as per [JACKSON-254]:\n        if (declaredType.isContainerType()\n                && !_config.isEnabled(SerializationFeature.WRITE_EMPTY_JSON_ARRAYS)) {\n            valueToSuppress = BeanPropertyWriter.MARKER_FOR_EMPTY;\n        }\n        break;\n    }\n    BeanPropertyWriter bpw = new BeanPropertyWriter(propDef,\n            am, _beanDesc.getClassAnnotations(), declaredType,\n            ser, typeSer, serializationType, suppressNulls, valueToSuppress);\n\n    // How about custom null serializer?\n    Object serDef = _annotationIntrospector.findNullSerializer(am);\n    if (serDef != null) {\n        bpw.assignNullSerializer(prov.serializerInstance(am, serDef));\n    }\n    // And then, handling of unwrapping\n    NameTransformer unwrapper = _annotationIntrospector.findUnwrappingNameTransformer(am);\n    if (unwrapper != null) {\n        bpw = bpw.unwrappingWriter(unwrapper);\n    }\n    return bpw;\n}", "rollout": 2}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "patch": "found = key.equalsIgnoreCase(prop.getName());", "rollout": 1}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "patch": "paramName = candidate.paramName(0);", "rollout": 3}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "PASS", "patch": "if (property != null && property.getName() == null) {\n    // Note: if property is null, no need to check for config overrides\n    return this;\n}", "rollout": 12}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "3", "eval": "PASS", "patch": "public String nextTextValue() throws IOException\n{\n    _binaryValue = null;\n    if (_nextToken != null) {\n        JsonToken t = _nextToken;\n        _currToken = t;\n        _nextToken = null;\n\n        // expected case; yes, got a String\n        if (t == JsonToken.VALUE_STRING) {\n            return _currText;\n        }\n        _updateState(t);\n        return null;\n    }\n\n    int token = _xmlTokens.next();\n\n    // mostly copied from 'nextToken()'\n    while (token == XmlTokenStream.XML_START_ELEMENT) {\n        if (_mayBeLeaf) {\n            _nextToken = JsonToken.FIELD_NAME;\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n            return null;\n        }\n        if (_parsingContext.inArray()) {\n            token = _xmlTokens.next();\n            _mayBeLeaf = true;\n            continue;\n        }\n        String name = _xmlTokens.getLocalName();\n        _parsingContext.setCurrentName(name);\n        if (_namesToWrap != null && _namesToWrap.contains(name)) {\n            _xmlTokens.repeatStartElement();\n        }\n        _mayBeLeaf = true;\n        _currToken = JsonToken.FIELD_NAME;\n        return null;\n    }\n\n    // Ok; beyond start element, what do we get?\n    switch (token) {\n    case XmlTokenStream.XML_END_ELEMENT:\n        if (_mayBeLeaf) {\n            // NOTE: this is different from nextToken() -- produce \"\", NOT null\n            _mayBeLeaf = false;\n            _currToken = JsonToken.VALUE_STRING;\n            return (_currText = \"\");\n        }\n        _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n        _parsingContext = _parsingContext.getParent();\n        _namesToWrap = _parsingContext.getNamesToWrap();\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_NAME:\n        // If there was a chance of leaf node, no more...\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            _nextToken = JsonToken.FIELD_NAME;\n            _currText = _xmlTokens.getText();\n            _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n            _currToken = JsonToken.START_OBJECT;\n        } else {\n            _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n            _currToken = JsonToken.FIELD_NAME;\n        }\n        break;\n    case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n        _currText = _xmlTokens.getText();\n        _currToken = JsonToken.VALUE_STRING;\n        return _currText; // return the text value\n    case XmlTokenStream.XML_TEXT:\n        _currText = _xmlTokens.getText();\n        if (_mayBeLeaf) {\n            _mayBeLeaf = false;\n            // Also: must skip following END_ELEMENT\n            _xmlTokens.skipEndElement();\n\n            // NOTE: this is different from nextToken() -- NO work-around\n            // for otherwise empty List/array\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        }\n        // If not a leaf, need to transform into property...\n        _parsingContext.setCurrentName(_cfgNameForTextElement);\n        _nextToken = JsonToken.VALUE_STRING;\n        _currToken = JsonToken.FIELD_NAME;\n        break;\n    case XmlTokenStream.XML_END:\n        _currToken = null;\n    }\n    return null;\n}", "rollout": 3}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "patch": "private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};", "rollout": 1}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "patch": "if (offset + seq.length() <= length) {", "rollout": 13}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "patch": "doc = parser.parseInput(docData, baseUri);", "rollout": 5}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "patch": "if (!name.isEmpty())", "rollout": 7}
{"project": "Jsoup", "bug_id": "41", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "43", "eval": "PASS", "patch": "            if (element == search)", "rollout": 1}
{"project": "Jsoup", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "patch": "accum.append(\"&nbsp;;\");", "rollout": 4}
{"project": "Jsoup", "bug_id": "47", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "49", "eval": "PASS", "patch": "protected void addChildren(int index, Node... children) {\n    Validate.noNullElements(children);\n    ensureChildNodes();\n    for (int i = children.length - 1; i >= 0; i--) {\n        Node in = children[i];\n        reparentChild(in);\n        childNodes.add(index, in);\n        reindexChildren(index); // Call reindexChildren with the updated index of the child node that was moved\n    }\n}", "rollout": 8}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "patch": "it.remove();", "rollout": 7}
{"project": "Jsoup", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "68", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "72", "eval": "PASS", "patch": "// limit (no cache):\nif (start < 0 || start > charBuf.length - count || count < 0)\n    return \"\";", "rollout": 11}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "77", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "80", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "85", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "88", "eval": "PASS", "patch": "return val == null ? \"\" : val;", "rollout": 1}
{"project": "Jsoup", "bug_id": "89", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "patch": "if ((o & 0xE0) == 0xC0) {\n    end = i + 2;\n} else if ((o & 0xF0) == 0xE0) {\n    end = i + 3; // fix: set end to i + 3 for 3-byte sequences\n} else if ((o & 0xF8) == 0xF0) {\n    end = i + 4;\n} else {\n    return false;\n}\n\nwhile (i < end) {\n    i++;\n    if (i >= input.length) { // added input.length check\n        return false;\n    }\n    o = input[i];\n    if ((o & 0xC0) != 0x80) {\n        return false;\n    }\n}", "rollout": 5}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "patch": "public static String getNamespaceURI(Node node) {\n    if (node instanceof Document) {\n        node = ((Document) node).getDocumentElement();\n    }\n\n    Element element = (Element) node;\n\n    String uri = element.getNamespaceURI();\n    if (uri != null) {\n        return uri;\n    }\n\n    // Check if the node has a default namespace\n    String nodeName = element.getNodeName();\n    if (nodeName.startsWith(\":\")) {\n        return \"\";\n    }\n\n    // Look for the xmlns attribute in the element and its ancestral elements\n    Node aNode = node;\n    while (aNode != null) {\n        if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n            Attr attr = ((Element) aNode).getAttributeNodeNS(null, \"xmlns\");\n            if (attr != null) {\n               return attr.getValue();\n            }\n        }\n        aNode = aNode.getParentNode();\n    }\n    return null;\n}", "rollout": 12}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "patch": "public static boolean equals(CharSequence cs1, CharSequence cs2) {\n    if (cs1 == null) {\n        return cs2 == null;\n    }\n    if (cs2 == null) {\n        return false;\n    }\n    int len1 = cs1.length();\n    int len2 = cs2.length();\n    if (len1 != len2)\n        return false;\n    \n    for (int i = 0; i < len1; i++) {\n        if (cs1.charAt(i) != cs2.charAt(i))\n            return false;\n    }\n    \n    return true;\n}", "rollout": 3}
{"project": "Lang", "bug_id": "16", "eval": "PASS", "patch": "if (str.toLowerCase().startsWith(\"0x\") || str.toLowerCase().startsWith(\"-0x\")) {", "rollout": 8}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "rollout": 2}
{"project": "Lang", "bug_id": "22", "eval": "PASS", "patch": "private static int greatestCommonDivisor(int u, int v) {\n    if (u == 0 || v == 0) {\n        throw new ArithmeticException(\"greatestCommonDivisor: zero operand\");\n    }\n    if (u < 0) { u = -u; }\n    if (v < 0) { v = -v; }\n    while (v != 0) {\n        int temp = v;\n        v = u % v;\n        u = temp;\n    }\n    return u;\n}", "rollout": 10}
{"project": "Lang", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "27", "eval": "PASS", "patch": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        // this is protection for poorness in java.lang.BigDecimal.\n        // it accepts this as a legal value, but it does not appear \n        // to be in specification of class. OS X Java parses it to \n        // a wrong value.\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return createInteger(str);\n    }   \n    char lastChar = str.charAt(str.length() - 1);\n    String mant;\n    String dec;\n    String exp;\n    int decPos = str.indexOf('.');\n    int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n    if (decPos > -1) {\n\n        if (expPos > -1) {\n            if (expPos < decPos) {\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n            dec = str.substring(decPos + 1, expPos);\n        } else {\n            dec = str.substring(decPos + 1);\n        }\n        mant = str.substring(0, decPos);\n    } else {\n        if (expPos != -1) {\n            if (expPos < str.length()) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = \"\";\n            }\n        } else {\n            mant = str;\n        }\n        dec = null;\n    }\n    if (!Character.isDigit(lastChar) && lastChar != '.') {\n        if (expPos > -1 && (expPos < decPos || (decPos == -1 && expPos < str.length())) ) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        //Requesting a specific type..\n        String numeric = str.substring(0, str.length() - 1);\n        boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n        switch (lastChar) {\n            case 'l' :\n            case 'L' :\n                if (dec == null\n                    && exp == null\n                    && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) {\n                    try {\n                        return createLong(numeric);\n                    } catch (NumberFormatException nfe) {\n                        //Too big for a long\n                    }\n                    return createBigInteger(numeric);\n\n                }\n                throw new NumberFormatException(str + \" is not a valid number.\");\n            case 'f' :\n            case 'F' :\n                try {\n                    Float f = NumberUtils.createFloat(numeric);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        //If it's too big for a float or the float value = 0 and the string\n                        //has non-zeros in it, then float does not have the precision we want\n                        return f;\n                    }\n\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            case 'd' :\n            case 'D' :\n                try {\n                    Double d = NumberUtils.createDouble(numeric);\n                    if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createBigDecimal(numeric);\n                } catch (NumberFormatException e) {\n                    // ignore the bad number\n                }\n                //$FALL-THROUGH$\n            default :\n                throw new NumberFormatException(str + \" is not a valid number.\");\n\n        }\n    } else {\n        //User doesn't have a preference on the return type, so let's start\n        //small and go from there...\n        if (expPos > -1 && (expPos < decPos || (decPos == -1 && expPos < str.length())) ) {\n            exp = str.substring(expPos + 1);\n        } else {\n            exp = null;\n        }\n        if (dec == null && exp == null) {\n            //Must be an int,long,bigint\n            try {\n                return createInteger(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                return createLong(str);\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            return createBigInteger(str);\n\n        } else {\n            //Must be a float,double,BigDec\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            try {\n                Float f = createFloat(str);\n                if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                    return f;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n            try {\n                Double d = createDouble(str);\n                if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                    return d;\n                }\n            } catch (NumberFormatException nfe) {\n                // ignore the bad number\n            }\n\n            return createBigDecimal(str);\n\n        }\n    }\n}", "rollout": 1}
{"project": "Lang", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "patch": "classes[i] = array[i] != null ? array[i].getClass() : null;", "rollout": 7}
{"project": "Lang", "bug_id": "37", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "40", "eval": "PASS", "patch": "if (searchStr.length() == 0) {\n    return true;\n}\nif (str.toLowerCase().indexOf(searchStr.toLowerCase()) != -1) {\n    return true;\n}\nif (str.equalsIgnoreCase(searchStr)) {\n    return true;\n}\nreturn false;", "rollout": 5}
{"project": "Lang", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "patch": "// if the lower value is greater than the length of the string, \n// set to the length of the string\nif (lower > str.length()) {\n    lower = str.length();\n}", "rollout": 3}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "patch": "return false;", "rollout": 4}
{"project": "Lang", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "53", "eval": "PASS", "patch": "private static void modify(Calendar val, int field, boolean round) {\n    if (val.get(Calendar.YEAR) > 280000000) {\n        throw new ArithmeticException(\"Calendar value too large for accurate calculations\");\n    }\n    \n    if (field == Calendar.MILLISECOND) {\n        return;\n    }\n\n    // ----------------- Fix for LANG-59 ---------------------- START ---------------\n    // see http://issues.apache.org/jira/browse/LANG-59\n    //\n    // Manually truncate milliseconds, seconds and minutes, rather than using\n    // Calendar methods.\n\n    Date date = val.getTime();\n    long time = date.getTime();\n    boolean done = false;\n\n    // truncate milliseconds\n    int millisecs = val.get(Calendar.MILLISECOND);\n    if (!round || millisecs < 500) {\n        time = time - millisecs;\n    }\n    if (field == Calendar.SECOND) {\n        done = true;\n    }\n\n    // truncate seconds\n    int seconds = val.get(Calendar.SECOND);\n    if (!done && (!round || seconds < 30)) {\n        time = time - (seconds * 1000L);\n    }\n    if (field == Calendar.MINUTE) {\n        done = true;\n    }\n\n    // truncate minutes\n    int minutes = val.get(Calendar.MINUTE);\n    if (!done && (!round || minutes < 30)) {\n        time = time - (minutes * 60000L);\n    }\n\n    // reset time\n    if (date.getTime() != time) {\n        date.setTime(time);\n        val.setTime(date);\n    }\n    // ----------------- Fix for LANG-59 ----------------------- END ----------------\n\n    boolean roundUp = false;\n    for (int i = 0; i < fields.length; i++) {\n        for (int j = 0; j < fields[i].length; j++) {\n            if (fields[i][j] == field) {\n                //This is our field... we stop looping\n                if (round && roundUp) {\n                    if (field == DateUtils.SEMI_MONTH) {\n                        //This is a special case that's hard to generalize\n                        //If the date is 1, we round up to 16, otherwise\n                        //  we subtract 15 days and add 1 month\n                        if (val.get(Calendar.DATE) == 1) {\n                            val.add(Calendar.DATE, 15);\n                        } else {\n                            val.add(Calendar.DATE, -15);\n                            val.add(Calendar.MONTH, 1);\n                        }\n                    } else {\n                        //We need at add one to this field since the\n                        //  last number causes us to round up\n                        val.add(fields[i][0], 1);\n                    }\n                }\n                return;\n            }\n        }\n        //We have various fields that are not easy roundings\n        int offset = 0;\n        boolean offsetSet = false;\n        //These are special types of fields that require different rounding rules\n        switch (field) {\n            case DateUtils.SEMI_MONTH:\n                if (fields[i][0] == Calendar.DATE) {\n                    //If we're going to drop the DATE field's value,\n                    //  we want to do this our own way.\n                    //We need to subtrace 1 since the date has a minimum of 1\n                    offset = val.get(Calendar.DATE) - 1;\n                    //If we're above 15 days adjustment, that means we're in the\n                    //  bottom half of the month and should stay accordingly.\n                    if (offset >= 15) {\n                        offset -= 15;\n                    }\n                    //Record whether we're in the top or bottom half of that range\n                    roundUp = offset > 7;\n                    offsetSet = true;\n                }\n                break;\n            case Calendar.AM_PM:\n                if (fields[i][0] == Calendar.HOUR_OF_DAY) {\n                    //If we're going to drop the HOUR field's value,\n                    //  we want to do this our own way.\n                    offset = val.get(Calendar.HOUR_OF_DAY);\n                    if (offset >= 12) {\n                        offset -= 12;\n                    }\n                    roundUp = offset > 6;\n                    offsetSet = true;\n                }\n                break;\n        }\n        if (!offsetSet) {\n            int min = val.getActualMinimum(fields[i][0]);\n            int max = val.getActualMaximum(fields[i][0]);\n            //Calculate the offset from the minimum allowed value\n            offset = val.get(fields[i][0]) - min;\n            //Set roundUp if this is more than half way between the minimum and maximum\n            roundUp = offset > ((max - min) / 2);\n        }\n        //We need to remove this field\n        if (offset != 0) {\n            val.set(fields[i][0], val.get(fields[i][0]) - offset);\n        }\n    }\n    throw new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}", "rollout": 10}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "patch": "    return cAvailableLocaleSet == null || cAvailableLocaleSet.contains(locale);", "rollout": 1}
{"project": "Lang", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "59", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "2", "eval": "PASS", "patch": "return ((double) getSampleSize() * getNumberOfSuccesses()) / getPopulationSize();", "rollout": 14}
{"project": "Math", "bug_id": "3", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "5", "eval": "PASS", "patch": "return Complex.INF;", "rollout": 10}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "27", "eval": "PASS", "patch": "return (getNumerator() * 100.0) / getDenominator();", "rollout": 2}
{"project": "Math", "bug_id": "28", "eval": "PASS", "patch": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n    // create a list of all the rows that tie for the lowest score in the minimum ratio test\n    List<Integer> minRatioPositions = new ArrayList<Integer>();\n    double minRatio = Double.MAX_VALUE;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n\n        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n            final double ratio = rhs / entry;\n            // check if the entry is strictly equal to the current min ratio\n            // do not use a ulp/epsilon check\n            final int cmp = Double.compare(ratio, minRatio);\n            if (cmp == 0) {\n                minRatioPositions.add(i);\n            } else if (cmp < 0) {\n                minRatio = ratio;\n                minRatioPositions = new ArrayList<Integer>();\n                minRatioPositions.add(i);\n            }\n        }\n    }\n\n    if (minRatioPositions.size() == 0) {\n        return null;\n    } else if (minRatioPositions.size() > 1) {\n        // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n        // 1. check if there's an artificial variable that can be forced out of the basis\n        for (Integer row : minRatioPositions) {\n            for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                int column = i + tableau.getArtificialVariableOffset();\n                final double entry = tableau.getEntry(row, column);\n                if (Precision.equals(entry, 1.0d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                    return row;\n                }\n            }\n        }\n\n        // 2. simply choose the row with the smallest index among the tied rows\n        Integer minRow = minRatioPositions.get(0);\n        for (int i = 1; i < minRatioPositions.size(); i++) {\n            if (minRatioPositions.get(i) < minRow) {\n                minRow = minRatioPositions.get(i);\n            }\n        }\n        return minRow;\n    }\n    return minRatioPositions.get(0);\n}", "rollout": 2}
{"project": "Math", "bug_id": "30", "eval": "PASS", "patch": "final long n1n2prod = (long)n1 * (long)n2;", "rollout": 1}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "32", "eval": "PASS", "patch": "if (tree.getAttribute() instanceof Boolean) {", "rollout": 1}
{"project": "Math", "bug_id": "33", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "34", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "41", "eval": "PASS", "patch": "for (int i = begin; i < begin + length; i++) {", "rollout": 12}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "50", "eval": "PASS", "patch": "                    if (x == x1) {\n                        x0 = x1 - FastMath.max(rtol * FastMath.abs(x1), atol);\n                        f0 = computeObjectiveValue(x0);\n                    }", "rollout": 3}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "53", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "56", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "57", "eval": "PASS", "patch": "double sum = 0.0;", "rollout": 2}
{"project": "Math", "bug_id": "58", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "59", "eval": "PASS", "patch": "return (Float.isNaN(a) || Float.isNaN(b)) ? Float.max(a, b) : (a <= b ? b : a);", "rollout": 3}
{"project": "Math", "bug_id": "60", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "63", "eval": "PASS", "patch": "return Double.isNaN(x) ^ Double.isNaN(y) || x == y;", "rollout": 1}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "70", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "72", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "73", "eval": "PASS", "patch": "// Check if the interval does not bracket the root\nif ((yMin = f.value(min)) * f.value(max) >= 0) { \n    throw new IllegalArgumentException(\"The interval does not appear to bracket the root.\");\n}", "rollout": 12}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "75", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "79", "eval": "PASS", "patch": "public static double squaredDistance(int[] p1, int[] p2) {\n    if (p1 == null || p2 == null) {\n        throw new IllegalArgumentException(\"Both p1 and p2 must not be null.\");\n    }\n    if (p1.length != p2.length) {\n        throw new IllegalArgumentException(\"Both p1 and p2 must have the same dimension.\");\n    }\n    double sum = 0;\n    for (int i = 0; i < p1.length; i++) {\n        final double dp = (double) p1[i] - p2[i];\n        sum += dp * dp;\n    }\n    return sum;\n}\n\npublic static double distance(int[] p1, int[] p2) {\n    return Math.sqrt(squaredDistance(p1, p2));\n}", "rollout": 13}
{"project": "Math", "bug_id": "80", "eval": "PASS", "patch": "int j = 4 * (n - 1);", "rollout": 1}
{"project": "Math", "bug_id": "82", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "85", "eval": "PASS", "patch": "if ((Math.abs(a - b) < 1.0e-12) && (fa != fb || numIterations == 0)) {", "rollout": 12}
{"project": "Math", "bug_id": "86", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "88", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "89", "eval": "PASS", "patch": "public void addValue(Object v) {\n    if (!(v instanceof Comparable)) {\n        throw new IllegalArgumentException(\"The object \" + v.toString() + \" is not comparable.\");\n    }\n    addValue((Comparable<?>) v);            \n}", "rollout": 1}
{"project": "Math", "bug_id": "91", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "94", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "95", "eval": "PASS", "patch": "protected double getInitialDomain(double p) {\n    double ret;\n    double d = getDenominatorDegreesOfFreedom();\n    if (d == 2.0) {\n        // when d is exactly 2.0, use a default value\n        ret = 1.0 / 3.0;  // This is a common initial domain for F-distribution CDF\n    } else if (d >= 10.0) {\n        // Large d, use a common initial domain\n        ret = 1.0 / 3.0;\n    } else {\n        // d is small, use a default value for simplicity\n        ret = 1.0 / 3.0;\n    }\n    return ret;\n}", "rollout": 5}
{"project": "Math", "bug_id": "96", "eval": "PASS", "patch": "ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary());", "rollout": 1}
{"project": "Math", "bug_id": "97", "eval": "PASS", "patch": "public double solve(double min, double max) throws MaxIterationsExceededException, \n    FunctionEvaluationException {\n        \n        clearResult();\n        verifyInterval(min, max);\n        \n        double ret = Double.NaN;\n        \n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        \n        // Check if either endpoint is a root\n        double epsilon = 1e-12;\n        if (Math.abs(yMin) < epsilon && Math.abs(yMax) < epsilon) {\n            // Check which endpoint is the root\n            if (f.value(min + 1e-6) != 0) {\n                ret = min;\n            } else {\n                ret = max;\n            }\n            return ret;\n        }\n        \n        // Verify bracketing\n        if (Math.abs(yMin) > 1e-12 && Math.abs(yMax) > 1e-12) {\n            double sign = yMin * yMax;\n            if (sign >= 0) {\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        }\n        \n        // solve using only the first endpoint as initial guess\n        ret = solve(min, yMin, max, yMax, min, yMin);\n        // either min or max is a root\n        return ret;\n    }", "rollout": 6}
{"project": "Math", "bug_id": "101", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "103", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Math", "bug_id": "106", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "1", "eval": "PASS", "patch": "int varargIndex = invocation.getRawArguments().length - 1;", "rollout": 4}
{"project": "Mockito", "bug_id": "5", "eval": "PASS", "patch": "catch (AssertionError e) {", "rollout": 3}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "12", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "patch": "        primitiveValues.put(double.class, Double.valueOf(0.0D));", "rollout": 1}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "29", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Mockito", "bug_id": "33", "eval": "PASS", "patch": "public boolean hasSameMethod(Invocation candidate) {        \n    Method m1 = invocation.getMethod();\n    Method m2 = candidate.getMethod();\n    \n    /* Compare method signatures, including parameter types */\n    return compareMethodSignatures(m1, m2);\n}\n\nprivate boolean compareMethodSignatures(Method m1, Method m2) {\n    if (!m1.getName().equals(m2.getName())) {\n        return false;\n    }\n    Class<?>[] p1 = m1.getParameterTypes();\n    Class<?>[] p2 = m2.getParameterTypes();\n    if (p1.length != p2.length) {\n        return false;\n    }\n    for (int i = 0; i < p1.length; i++) {\n        if (!p1[i].equals(p2[i])) {\n            return false;\n        }\n    }\n    return true;\n}", "rollout": 2}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "patch": "if (k < i.getArguments().length && (m instanceof CapturesArguments)) {", "rollout": 2}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "patch": "return StringDescription.toString(m).equals(arg == null ? null : arg.toString());", "rollout": 1}
{"project": "Time", "bug_id": "4", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "17", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "18", "eval": "PASS", "patch": "//if (!iGregorianChronology.isValidYearMonthDay(year, monthOfYear, dayOfMonth)) {\n//    throw new IllegalArgumentException(\"Invalid date: \" + year + \"-\" + monthOfYear + \"-\" + dayOfMonth);\n//}", "rollout": 14}
{"project": "Time", "bug_id": "19", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "20", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "23", "eval": "PASS", "patch": "private static synchronized String getConvertedId(String id) {\n    // Initialize the map only if it's null\n    if (cZoneIdConversion == null) {\n        // Initialize the map with the correct timezone mappings\n        cZoneIdConversion = new HashMap<String, String>();\n        cZoneIdConversion.put(\"GMT\", \"UTC\");\n        cZoneIdConversion.put(\"WET\", \"WET\");\n        cZoneIdConversion.put(\"CET\", \"CET\");\n        cZoneIdConversion.put(\"MET\", \"CET\");\n        cZoneIdConversion.put(\"ECT\", \"CET\");\n        cZoneIdConversion.put(\"EET\", \"EET\");\n        cZoneIdConversion.put(\"MIT\", \"Pacific/Apia\");\n        cZoneIdConversion.put(\"HST\", \"Pacific/Honolulu\");\n        cZoneIdConversion.put(\"AST\", \"America/Anchorage\");\n        cZoneIdConversion.put(\"PST\", \"America/Los_Angeles\");\n        cZoneIdConversion.put(\"MST\", \"America/Denver\");\n        cZoneIdConversion.put(\"PNT\", \"America/Phoenix\");\n        cZoneIdConversion.put(\"CST\", \"America/Chicago\");\n        cZoneIdConversion.put(\"EST\", \"America/New_York\");\n        cZoneIdConversion.put(\"IET\", \"America/Indiana/Indianapolis\");\n        cZoneIdConversion.put(\"PRT\", \"America/Puerto_Rico\");\n        cZoneIdConversion.put(\"CNT\", \"America/St_Johns\");\n        cZoneIdConversion.put(\"AGT\", \"America/Argentina/Buenos_Aires\");\n        cZoneIdConversion.put(\"BET\", \"America/Sao_Paulo\");\n        cZoneIdConversion.put(\"ART\", \"Africa/Cairo\");\n        cZoneIdConversion.put(\"CAT\", \"Africa/Harare\");\n        cZoneIdConversion.put(\"EAT\", \"Africa/Addis_Ababa\");\n        cZoneIdConversion.put(\"NET\", \"Asia/Yerevan\");\n        cZoneIdConversion.put(\"PLT\", \"Asia/Karachi\");\n        cZoneIdConversion.put(\"IST\", \"Asia/Kolkata\");\n        cZoneIdConversion.put(\"BST\", \"Asia/Dhaka\");\n        cZoneIdConversion.put(\"VST\", \"Asia/Ho_Chi_Minh\");\n        cZoneIdConversion.put(\"CTT\", \"Asia/Shanghai\");\n        cZoneIdConversion.put(\"JST\", \"Asia/Tokyo\");\n        cZoneIdConversion.put(\"ACT\", \"Australia/Darwin\");\n        cZoneIdConversion.put(\"AET\", \"Australia/Sydney\");\n        cZoneIdConversion.put(\"SST\", \"Pacific/Guadalcanal\");\n        cZoneIdConversion.put(\"NST\", \"Pacific/Auckland\");\n    }\n    return cZoneIdConversion.get(id);\n}", "rollout": 3}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "patch": "", "rollout": 16}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "patch": "", "rollout": 16}
