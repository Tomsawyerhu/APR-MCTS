{"project": "Chart", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "4", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }\n", "diff": "diff --git a/source/org/jfree/chart/plot/XYPlot.java b/source/org/jfree/chart/plot/XYPlot.java\nindex ec26162..2b4db44 100644\n--- a/source/org/jfree/chart/plot/XYPlot.java\n+++ b/source/org/jfree/chart/plot/XYPlot.java\n@@ -4422,101 +4422,94 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,\n      *\n      * @return The range.\n      */\n-    public Range getDataRange(ValueAxis axis) {\n-\n-        Range result = null;\n-        List mappedDatasets = new ArrayList();\n-        List includedAnnotations = new ArrayList();\n-        boolean isDomainAxis = true;\n-\n-        // is it a domain axis?\n-        int domainIndex = getDomainAxisIndex(axis);\n-        if (domainIndex >= 0) {\n-            isDomainAxis = true;\n-            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n-                    new Integer(domainIndex)));\n-            if (domainIndex == 0) {\n-                // grab the plot's annotations\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // or is it a range axis?\n-        int rangeIndex = getRangeAxisIndex(axis);\n-        if (rangeIndex >= 0) {\n-            isDomainAxis = false;\n-            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n-                    new Integer(rangeIndex)));\n-            if (rangeIndex == 0) {\n-                Iterator iterator = this.annotations.iterator();\n-                while (iterator.hasNext()) {\n-                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n-                    if (annotation instanceof XYAnnotationBoundsInfo) {\n-                        includedAnnotations.add(annotation);\n-                    }\n-                }\n-            }\n-        }\n-\n-        // iterate through the datasets that map to the axis and get the union\n-        // of the ranges.\n-        Iterator iterator = mappedDatasets.iterator();\n-        while (iterator.hasNext()) {\n-            XYDataset d = (XYDataset) iterator.next();\n-            if (d != null) {\n-                XYItemRenderer r = getRendererForDataset(d);\n-                if (isDomainAxis) {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findDomainBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findDomainBounds(d));\n-                    }\n-                }\n-                else {\n-                    if (r != null) {\n-                        result = Range.combine(result, r.findRangeBounds(d));\n-                    }\n-                    else {\n-                        result = Range.combine(result,\n-                                DatasetUtilities.findRangeBounds(d));\n-                    }\n-                }\n-                \n-                    Collection c = r.getAnnotations();\n-                    Iterator i = c.iterator();\n-                    while (i.hasNext()) {\n-                        XYAnnotation a = (XYAnnotation) i.next();\n-                        if (a instanceof XYAnnotationBoundsInfo) {\n-                            includedAnnotations.add(a);\n-                        }\n-                    }\n-            }\n-        }\n-\n-        Iterator it = includedAnnotations.iterator();\n-        while (it.hasNext()) {\n-            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n-            if (xyabi.getIncludeInDataBounds()) {\n-                if (isDomainAxis) {\n-                    result = Range.combine(result, xyabi.getXRange());\n-                }\n-                else {\n-                    result = Range.combine(result, xyabi.getYRange());\n-                }\n-            }\n-        }\n-\n-        return result;\n-\n-    }\n+\n+    public Range getDataRange(ValueAxis axis) {\n+\n+        Range result = null;\n+        List mappedDatasets = new ArrayList();\n+        List includedAnnotations = new ArrayList();\n+        boolean isDomainAxis = true;\n+\n+        // is it a domain axis?\n+        int domainIndex = getDomainAxisIndex(axis);\n+        if (domainIndex >= 0) {\n+            isDomainAxis = true;\n+            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n+                    new Integer(domainIndex)));\n+            if (domainIndex == 0) {\n+                // grab the plot's annotations\n+                Iterator iterator = this.annotations.iterator();\n+                while (iterator.hasNext()) {\n+                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                    if (annotation instanceof XYAnnotationBoundsInfo) {\n+                        includedAnnotations.add(annotation);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // or is it a range axis?\n+        int rangeIndex = getRangeAxisIndex(axis);\n+        if (rangeIndex >= 0) {\n+            isDomainAxis = false;\n+            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n+                    new Integer(rangeIndex)));\n+            if (rangeIndex == 0) {\n+                Iterator iterator = this.annotations.iterator();\n+                while (iterator.hasNext()) {\n+                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n+                    if (annotation instanceof XYAnnotationBoundsInfo) {\n+                        includedAnnotations.add(annotation);\n+                    }\n+                }\n+            }\n+        }\n+\n+        // iterate through the datasets that map to the axis and get the union\n+        // of the ranges.\n+        Iterator iterator = mappedDatasets.iterator();\n+        while (iterator.hasNext()) {\n+            XYDataset d = (XYDataset) iterator.next();\n+            if (d != null) {\n+                XYItemRenderer r = getRendererForDataset(d);\n+                if (isDomainAxis) {\n+                    if (r != null) {\n+                        result = Range.combine(result, r.findDomainBounds(d));\n+                    }\n+                    else {\n+                        result = Range.combine(result,\n+                                DatasetUtilities.findDomainBounds(d));\n+                    }\n+                }\n+                else {\n+                    if (r != null) {\n+                        result = Range.combine(result, r.findRangeBounds(d));\n+                    }\n+                    else {\n+                        result = Range.combine(result,\n+                                DatasetUtilities.findRangeBounds(d));\n+                    }\n+                }\n+            }\n+        }\n+\n+        Iterator it = includedAnnotations.iterator();\n+        while (it.hasNext()) {\n+            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n+            if (xyabi.getIncludeInDataBounds()) {\n+                if (isDomainAxis) {\n+                    result = Range.combine(result, xyabi.getXRange());\n+                }\n+                else {\n+                    result = Range.combine(result, xyabi.getYRange());\n+                }\n+            }\n+        }\n+\n+        return result;\n+\n+    }\n+\n \n     /**\n      * Receives notification of a change to the plot's dataset."}
{"project": "Chart", "bug_id": "5", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public XYDataItem addOrUpdate(Number x, Number y) {\n        if (x == null) {\n            throw new IllegalArgumentException(\"Null 'x' argument.\");\n        }\n\n        // if we get to here, we know that duplicate X values are not permitted\n        XYDataItem overwritten = null;\n        int index = indexOf(x);\n        if (index >= 0 && !this.allowDuplicateXValues) {\n            XYDataItem existing = (XYDataItem) this.data.get(index);\n            try {\n                overwritten = (XYDataItem) existing.clone();\n            }\n            catch (CloneNotSupportedException e) {\n                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n            }\n            existing.setY(y);\n        }\n        else {\n            // if the series is sorted, the negative index is a result from\n            // Collections.binarySearch() and tells us where to insert the\n            // new item...otherwise it will be just -1 and we should just\n            // append the value to the list...\n            int insertIndex = -1;\n            if (this.autoSort && index < 0) {\n                insertIndex = -index - 1;\n            }\n            else {\n                insertIndex = this.data.size();\n            }\n            this.data.add(insertIndex, new XYDataItem(x, y));\n\n            // check if this addition will exceed the maximum item count...\n            if (getItemCount() > this.maximumItemCount) {\n                this.data.remove(0);\n            }\n        }\n        fireSeriesChanged();\n        return overwritten;\n    }\n", "diff": "diff --git a/source/org/jfree/data/xy/XYSeries.java b/source/org/jfree/data/xy/XYSeries.java\nindex 0b37e6e..0fde5f8 100644\n--- a/source/org/jfree/data/xy/XYSeries.java\n+++ b/source/org/jfree/data/xy/XYSeries.java\n@@ -537,43 +537,48 @@ public class XYSeries extends Series implements Cloneable, Serializable {\n      * @return A copy of the overwritten data item, or <code>null</code> if no\n      *         item was overwritten.\n      */\n-    public XYDataItem addOrUpdate(Number x, Number y) {\n-        if (x == null) {\n-            throw new IllegalArgumentException(\"Null 'x' argument.\");\n-        }\n-\n-        // if we get to here, we know that duplicate X values are not permitted\n-        XYDataItem overwritten = null;\n-        int index = indexOf(x);\n-        if (index >= 0 && !this.allowDuplicateXValues) {\n-            XYDataItem existing = (XYDataItem) this.data.get(index);\n-            try {\n-                overwritten = (XYDataItem) existing.clone();\n-            }\n-            catch (CloneNotSupportedException e) {\n-                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n-            }\n-            existing.setY(y);\n-        }\n-        else {\n-            // if the series is sorted, the negative index is a result from\n-            // Collections.binarySearch() and tells us where to insert the\n-            // new item...otherwise it will be just -1 and we should just\n-            // append the value to the list...\n-            if (this.autoSort) {\n-                this.data.add(-index - 1, new XYDataItem(x, y));\n-            }\n-            else {\n-                this.data.add(new XYDataItem(x, y));\n-            }\n-            // check if this addition will exceed the maximum item count...\n-            if (getItemCount() > this.maximumItemCount) {\n-                this.data.remove(0);\n-            }\n-        }\n-        fireSeriesChanged();\n-        return overwritten;\n-    }\n+\n+    public XYDataItem addOrUpdate(Number x, Number y) {\n+        if (x == null) {\n+            throw new IllegalArgumentException(\"Null 'x' argument.\");\n+        }\n+\n+        // if we get to here, we know that duplicate X values are not permitted\n+        XYDataItem overwritten = null;\n+        int index = indexOf(x);\n+        if (index >= 0 && !this.allowDuplicateXValues) {\n+            XYDataItem existing = (XYDataItem) this.data.get(index);\n+            try {\n+                overwritten = (XYDataItem) existing.clone();\n+            }\n+            catch (CloneNotSupportedException e) {\n+                throw new SeriesException(\"Couldn't clone XYDataItem!\");\n+            }\n+            existing.setY(y);\n+        }\n+        else {\n+            // if the series is sorted, the negative index is a result from\n+            // Collections.binarySearch() and tells us where to insert the\n+            // new item...otherwise it will be just -1 and we should just\n+            // append the value to the list...\n+            int insertIndex = -1;\n+            if (this.autoSort && index < 0) {\n+                insertIndex = -index - 1;\n+            }\n+            else {\n+                insertIndex = this.data.size();\n+            }\n+            this.data.add(insertIndex, new XYDataItem(x, y));\n+\n+            // check if this addition will exceed the maximum item count...\n+            if (getItemCount() > this.maximumItemCount) {\n+                this.data.remove(0);\n+            }\n+        }\n+        fireSeriesChanged();\n+        return overwritten;\n+    }\n+\n \n     /**\n      * Returns the index of the item with the specified x-value, or a negative"}
{"project": "Chart", "bug_id": "6", "eval": "PASS", "attempt": 6, "mode": "SH", "patch": "\n        ShapeList other = (ShapeList) obj;\n        if (this.size() != other.size()) {\n            return false;\n        }\n        for (int i = 0; i < this.size(); i++) {\n            if (!ShapeUtilities.equal((Shape) this.get(i), (Shape) other.get(i))) {\n                return false;\n            }\n        }\n        return true;\n", "diff": "diff --git a/source/org/jfree/chart/util/ShapeList.java b/source/org/jfree/chart/util/ShapeList.java\nindex 85f1c81..98586cf 100644\n--- a/source/org/jfree/chart/util/ShapeList.java\n+++ b/source/org/jfree/chart/util/ShapeList.java\n@@ -108,7 +108,18 @@ public class ShapeList extends AbstractObjectList {\n         if (!(obj instanceof ShapeList)) {\n             return false;\n         }\n-        return super.equals(obj);\n+\n+        ShapeList other = (ShapeList) obj;\n+        if (this.size() != other.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < this.size(); i++) {\n+            if (!ShapeUtilities.equal((Shape) this.get(i), (Shape) other.get(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+\n \n     }\n \n@@ -169,4 +180,3 @@ public class ShapeList extends AbstractObjectList {\n     }\n \n }\n-"}
{"project": "Chart", "bug_id": "7", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }\n", "diff": "diff --git a/source/org/jfree/data/time/TimePeriodValues.java b/source/org/jfree/data/time/TimePeriodValues.java\nindex 0a3e7a1..426effe 100644\n--- a/source/org/jfree/data/time/TimePeriodValues.java\n+++ b/source/org/jfree/data/time/TimePeriodValues.java\n@@ -254,85 +254,87 @@ public class TimePeriodValues extends Series implements Serializable {\n      * @param period  the time period.\n      * @param index  the index of the time period.\n      */\n-    private void updateBounds(TimePeriod period, int index) {\n-        \n-        long start = period.getStart().getTime();\n-        long end = period.getEnd().getTime();\n-        long middle = start + ((end - start) / 2);\n-\n-        if (this.minStartIndex >= 0) {\n-            long minStart = getDataItem(this.minStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start < minStart) {\n-                this.minStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minStartIndex = index;\n-        }\n-        \n-        if (this.maxStartIndex >= 0) {\n-            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n-                .getStart().getTime();\n-            if (start > maxStart) {\n-                this.maxStartIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxStartIndex = index;\n-        }\n-        \n-        if (this.minMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long minMiddle = s + (e - s) / 2;\n-            if (middle < minMiddle) {\n-                this.minMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minMiddleIndex = index;\n-        }\n-        \n-        if (this.maxMiddleIndex >= 0) {\n-            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n-                .getTime();\n-            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n-                .getTime();\n-            long maxMiddle = s + (e - s) / 2;\n-            if (middle > maxMiddle) {\n-                this.maxMiddleIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxMiddleIndex = index;\n-        }\n-        \n-        if (this.minEndIndex >= 0) {\n-            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end < minEnd) {\n-                this.minEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.minEndIndex = index;\n-        }\n-       \n-        if (this.maxEndIndex >= 0) {\n-            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n-                .getTime();\n-            if (end > maxEnd) {\n-                this.maxEndIndex = index;           \n-            }\n-        }\n-        else {\n-            this.maxEndIndex = index;\n-        }\n-        \n-    }\n+\n+    private void updateBounds(TimePeriod period, int index) {\n+        \n+        long start = period.getStart().getTime();\n+        long end = period.getEnd().getTime();\n+        long middle = start + ((end - start) / 2);\n+\n+        if (this.minStartIndex >= 0) {\n+            long minStart = getDataItem(this.minStartIndex).getPeriod()\n+                .getStart().getTime();\n+            if (start < minStart) {\n+                this.minStartIndex = index;           \n+            }\n+        }\n+        else {\n+            this.minStartIndex = index;\n+        }\n+        \n+        if (this.maxStartIndex >= 0) {\n+            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n+                .getStart().getTime();\n+            if (start > maxStart) {\n+                this.maxStartIndex = index;           \n+            }\n+        }\n+        else {\n+            this.maxStartIndex = index;\n+        }\n+        \n+        if (this.minMiddleIndex >= 0) {\n+            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n+                .getTime();\n+            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n+                .getTime();\n+            long minMiddle = s + (e - s) / 2;\n+            if (middle < minMiddle) {\n+                this.minMiddleIndex = index;           \n+            }\n+        }\n+        else {\n+            this.minMiddleIndex = index;\n+        }\n+        \n+        if (this.maxMiddleIndex >= 0) {\n+            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n+                .getTime();\n+            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n+                .getTime();\n+            long maxMiddle = s + (e - s) / 2;\n+            if (middle > maxMiddle) {\n+                this.maxMiddleIndex = index;           \n+            }\n+        }\n+        else {\n+            this.maxMiddleIndex = index;\n+        }\n+        \n+        if (this.minEndIndex >= 0) {\n+            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n+                .getTime();\n+            if (end < minEnd) {\n+                this.minEndIndex = index;           \n+            }\n+        }\n+        else {\n+            this.minEndIndex = index;\n+        }\n+       \n+        if (this.maxEndIndex >= 0) {\n+            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n+                .getTime();\n+            if (end > maxEnd) {\n+                this.maxEndIndex = index;           \n+            }\n+        }\n+        else {\n+            this.maxEndIndex = index;\n+        }\n+        \n+    }\n+\n     \n     /**\n      * Recalculates the bounds for the collection of items."}
{"project": "Chart", "bug_id": "8", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        this(time, zone, Locale.getDefault());", "diff": "diff --git a/source/org/jfree/data/time/Week.java b/source/org/jfree/data/time/Week.java\nindex 3cc4138..183bac2 100644\n--- a/source/org/jfree/data/time/Week.java\n+++ b/source/org/jfree/data/time/Week.java\n@@ -172,7 +172,7 @@ public class Week extends RegularTimePeriod implements Serializable {\n      */\n     public Week(Date time, TimeZone zone) {\n         // defer argument checking...\n-        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n+        this(time, zone, Locale.getDefault());\n     }\n \n     /**"}
{"project": "Chart", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "10", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "        return \" title=\\\"\" + toolTipText.replace(\"\\\"\", \"&quot;\") ", "diff": "diff --git a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\nindex cf2934c..fcf804b 100644\n--- a/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n+++ b/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java\n@@ -62,7 +62,7 @@ public class StandardToolTipTagFragmentGenerator\n      * @return The formatted HTML area tag attribute(s).\n      */\n     public String generateToolTipFragment(String toolTipText) {\n-        return \" title=\\\"\" + toolTipText\n+        return \" title=\\\"\" + toolTipText.replace(\"\\\"\", \"&quot;\") \n             + \"\\\" alt=\\\"\\\"\";\n     }\n "}
{"project": "Chart", "bug_id": "11", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        PathIterator iterator2 = p2.getPathIterator(null);", "diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..f49ecb5 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -272,7 +272,7 @@ public class ShapeUtilities {\n             return false;\n         }\n         PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n+        PathIterator iterator2 = p2.getPathIterator(null);\n         double[] d1 = new double[6];\n         double[] d2 = new double[6];\n         boolean done = iterator1.isDone() && iterator2.isDone();"}
{"project": "Chart", "bug_id": "12", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "        setDataset(dataset);", "diff": "diff --git a/source/org/jfree/chart/plot/MultiplePiePlot.java b/source/org/jfree/chart/plot/MultiplePiePlot.java\nindex fedc205..941de08 100644\n--- a/source/org/jfree/chart/plot/MultiplePiePlot.java\n+++ b/source/org/jfree/chart/plot/MultiplePiePlot.java\n@@ -142,7 +142,7 @@ public class MultiplePiePlot extends Plot implements Cloneable, Serializable {\n      */\n     public MultiplePiePlot(CategoryDataset dataset) {\n         super();\n-        this.dataset = dataset;\n+        setDataset(dataset);\n         PiePlot piePlot = new PiePlot(null);\n         this.pieChart = new JFreeChart(piePlot);\n         this.pieChart.removeLegend();"}
{"project": "Chart", "bug_id": "13", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "                    new Range(0.0, constraint.getWidth()),", "diff": "diff --git a/source/org/jfree/chart/block/BorderArrangement.java b/source/org/jfree/chart/block/BorderArrangement.java\nindex 730aeb3..52600c3 100644\n--- a/source/org/jfree/chart/block/BorderArrangement.java\n+++ b/source/org/jfree/chart/block/BorderArrangement.java\n@@ -452,7 +452,7 @@ public class BorderArrangement implements Arrangement, Serializable {\n         h[3] = h[2];\n         if (this.rightBlock != null) {\n             RectangleConstraint c4 = new RectangleConstraint(0.0,\n-                    new Range(0.0, constraint.getWidth() - w[2]),\n+                    new Range(0.0, constraint.getWidth()),\n                     LengthConstraintType.RANGE, h[2], null,\n                     LengthConstraintType.FIXED);\n             Size2D size = this.rightBlock.arrange(g2, c4);"}
{"project": "Chart", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "20", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        super(paint, stroke, outlinePaint, outlineStroke, alpha);", "diff": "diff --git a/source/org/jfree/chart/plot/ValueMarker.java b/source/org/jfree/chart/plot/ValueMarker.java\nindex 075683d..83af579 100644\n--- a/source/org/jfree/chart/plot/ValueMarker.java\n+++ b/source/org/jfree/chart/plot/ValueMarker.java\n@@ -92,7 +92,7 @@ public class ValueMarker extends Marker {\n      */\n     public ValueMarker(double value, Paint paint, Stroke stroke, \n                        Paint outlinePaint, Stroke outlineStroke, float alpha) {\n-        super(paint, stroke, paint, stroke, alpha);\n+        super(paint, stroke, outlinePaint, outlineStroke, alpha);\n         this.value = value;\n     }\n     "}
{"project": "Chart", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Chart", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "5", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (str == null)\n        {\n            return null;\n        }\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Util.java b/src/java/org/apache/commons/cli/Util.java\nindex 2d88c30..931f7a1 100644\n--- a/src/java/org/apache/commons/cli/Util.java\n+++ b/src/java/org/apache/commons/cli/Util.java\n@@ -33,6 +33,12 @@ class Util {\n      */\n     static String stripLeadingHyphens(String str)\n     {\n+\n+        if (str == null)\n+        {\n+            return null;\n+        }\n+\n         if (str.startsWith(\"--\"))\n         {\n             return str.substring(2, str.length());\n@@ -64,4 +70,4 @@ class Util {\n         }\n         return str;\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Cli", "bug_id": "8", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            pos = findWrapPos(text, width, 0);", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 639b9d5..40873f5 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -809,7 +809,7 @@ public class HelpFormatter {\n         while (true)\n         {\n             text = padding + text.substring(pos).trim();\n-            pos = findWrapPos(text, width, nextLineTabStop);\n+            pos = findWrapPos(text, width, 0);\n \n             if (pos == -1)\n             {"}
{"project": "Cli", "bug_id": "9", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    protected void checkRequiredOptions()\n        throws MissingOptionException\n    {\n        // if there are required options that have not been\n        // processsed\n        if (getRequiredOptions().size() > 0)\n        {\n            Iterator iter = getRequiredOptions().iterator();\n            StringBuffer buff = new StringBuffer(\"Missing required option\");\n            buff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\n            buff.append(\": \");\n\n\n            // loop through the required options\n            while (iter.hasNext())\n            {\n                buff.append(iter.next());\n                if (iter.hasNext())\n                    buff.append(\", \");\n            }\n\n            throw new MissingOptionException(buff.toString());\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex dbace06..ab47be0 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -300,6 +300,7 @@ public abstract class Parser implements CommandLineParser {\n      * @throws MissingOptionException if any of the required Options\n      * are not present.\n      */\n+\n     protected void checkRequiredOptions()\n         throws MissingOptionException\n     {\n@@ -317,12 +318,15 @@ public abstract class Parser implements CommandLineParser {\n             while (iter.hasNext())\n             {\n                 buff.append(iter.next());\n+                if (iter.hasNext())\n+                    buff.append(\", \");\n             }\n \n             throw new MissingOptionException(buff.toString());\n         }\n     }\n \n+\n     /**\n      * <p>Process the argument values for the specified Option\n      * <code>opt</code> using the values retrieved from the "}
{"project": "Cli", "bug_id": "11", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        if (option.hasArg() && (option.getArgName() != null) && !option.getArgName().isEmpty())", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 183cae3..5e24e84 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -629,7 +629,7 @@ public class HelpFormatter {\n         }\n \n         // if the Option has a value\n-        if (option.hasArg() && (option.getArgName() != null))\n+        if (option.hasArg() && (option.getArgName() != null) && !option.getArgName().isEmpty())\n         {\n             buff.append(\" <\").append(option.getArgName()).append(\">\");\n         }"}
{"project": "Cli", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "17", "eval": "PASS", "attempt": 13, "mode": "SL", "patch": "                return;", "diff": "diff --git a/src/java/org/apache/commons/cli/PosixParser.java b/src/java/org/apache/commons/cli/PosixParser.java\nindex cafcede..abb1e69 100644\n--- a/src/java/org/apache/commons/cli/PosixParser.java\n+++ b/src/java/org/apache/commons/cli/PosixParser.java\n@@ -300,6 +300,7 @@ public class PosixParser extends Parser {\n             else if (stopAtNonOption)\n             {\n                 process(token.substring(i));\n+                return;\n             }\n             else\n             {"}
{"project": "Cli", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "24", "eval": "PASS", "attempt": 15, "mode": "SH", "patch": "\n            if (nextLineTabStop >= width) {\n                nextLineTabStop = width - 1;\n                if (nextLineTabStop < 0) {\n                    throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n                                                    \"- no room for the description\");\n                }\n            }\n", "diff": "diff --git a/src/java/org/apache/commons/cli/HelpFormatter.java b/src/java/org/apache/commons/cli/HelpFormatter.java\nindex 9993a07..daa75dc 100644\n--- a/src/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/java/org/apache/commons/cli/HelpFormatter.java\n@@ -822,8 +822,15 @@ public class HelpFormatter\n         if (nextLineTabStop >= width)\n         {\n             // stops infinite loop happening\n-            throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n-                                            \"- no room for the description\");\n+\n+            if (nextLineTabStop >= width) {\n+                nextLineTabStop = width - 1;\n+                if (nextLineTabStop < 0) {\n+                    throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n+                                                    \"- no room for the description\");\n+                }\n+            }\n+\n         }\n \n         // all following lines must be padded with nextLineTabStop space "}
{"project": "Cli", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "28", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                    continue;", "diff": "diff --git a/src/java/org/apache/commons/cli/Parser.java b/src/java/org/apache/commons/cli/Parser.java\nindex 6b39536..c106932 100644\n--- a/src/java/org/apache/commons/cli/Parser.java\n+++ b/src/java/org/apache/commons/cli/Parser.java\n@@ -287,7 +287,7 @@ public abstract class Parser implements CommandLineParser\n                 {\n                     // if the value is not yes, true or 1 then don't add the\n                     // option to the CommandLine\n-                    break;\n+                    continue;\n                 }\n \n                 cmd.addOption(opt);"}
{"project": "Cli", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Cli", "bug_id": "32", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (pos == startPos)\n        {\n            while ((pos > startPos) && ((c = text.charAt(pos)) != ' ')\n                    && (c != '\\n') && (c != '\\r'))\n            {\n                --pos;\n            }\n        }\n        else if (pos == text.length())\n        {\n            return -1;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/HelpFormatter.java b/src/main/java/org/apache/commons/cli/HelpFormatter.java\nindex 6b74e4e..2dfa16c 100644\n--- a/src/main/java/org/apache/commons/cli/HelpFormatter.java\n+++ b/src/main/java/org/apache/commons/cli/HelpFormatter.java\n@@ -934,11 +934,20 @@ public class HelpFormatter\n         \n         // if we didn't find one, simply chop at startPos+width\n         pos = startPos + width;\n-        while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n-               && (c != '\\n') && (c != '\\r'))\n+\n+        if (pos == startPos)\n+        {\n+            while ((pos > startPos) && ((c = text.charAt(pos)) != ' ')\n+                    && (c != '\\n') && (c != '\\r'))\n+            {\n+                --pos;\n+            }\n+        }\n+        else if (pos == text.length())\n         {\n-            ++pos;\n-        }        \n+            return -1;\n+        }\n+\n         return pos == text.length() ? -1 : pos;\n     }\n "}
{"project": "Cli", "bug_id": "35", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        if (longOpts.containsKey(opt))\n        {\n            matchingOpts.add(opt);\n            return matchingOpts;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/Options.java b/src/main/java/org/apache/commons/cli/Options.java\nindex e9a0aa9..0f2058c 100644\n--- a/src/main/java/org/apache/commons/cli/Options.java\n+++ b/src/main/java/org/apache/commons/cli/Options.java\n@@ -238,6 +238,13 @@ public class Options implements Serializable\n \n         // for a perfect match return the single option only\n \n+        if (longOpts.containsKey(opt))\n+        {\n+            matchingOpts.add(opt);\n+            return matchingOpts;\n+        }\n+\n+\n         for (String longOpt : longOpts.keySet())\n         {\n             if (longOpt.startsWith(opt))"}
{"project": "Cli", "bug_id": "37", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        String option = token.startsWith(\"-\") ? token.substring(1, token.contains(\"=\") ? token.indexOf(\"=\") : token.length()) : \"\";\n        return !option.isEmpty() && options.hasShortOption(option);\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 6aeaebe..7029330 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -296,14 +296,15 @@ public class DefaultParser implements CommandLineParser\n      * \n      * @param token\n      */\n+\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n-        return token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n-\n-        // remove leading \"-\" and \"=value\"\n+        String option = token.startsWith(\"-\") ? token.substring(1, token.contains(\"=\") ? token.indexOf(\"=\") : token.length()) : \"\";\n+        return !option.isEmpty() && options.hasShortOption(option);\n     }\n \n+\n     /**\n      * Tells if the token looks like a long option.\n      *"}
{"project": "Cli", "bug_id": "38", "eval": "PASS", "attempt": 15, "mode": "SF", "patch": "\n    private boolean isShortOption(String token)\n    {\n        // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n        if (!token.startsWith(\"-\") || token.length() == 1)\n        {\n            return false;\n        }\n\n        // remove leading \"-\" and \"=value\"\n        int pos = token.indexOf(\"=\");\n        String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n        boolean hasOption = options.hasShortOption(optName);\n        \n        // If option is not recognized, check for several concatenated short options\n        if (!hasOption) {\n            for (char ch : optName.toCharArray()) {\n                if (!options.hasShortOption(String.valueOf(ch))) {\n                    return false;\n                }\n            }\n            hasOption = true;\n        }\n        return hasOption;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/cli/DefaultParser.java b/src/main/java/org/apache/commons/cli/DefaultParser.java\nindex 4bff7f3..4a91787 100644\n--- a/src/main/java/org/apache/commons/cli/DefaultParser.java\n+++ b/src/main/java/org/apache/commons/cli/DefaultParser.java\n@@ -296,6 +296,7 @@ public class DefaultParser implements CommandLineParser\n      * \n      * @param token\n      */\n+\n     private boolean isShortOption(String token)\n     {\n         // short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\n@@ -307,10 +308,21 @@ public class DefaultParser implements CommandLineParser\n         // remove leading \"-\" and \"=value\"\n         int pos = token.indexOf(\"=\");\n         String optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\n-        return options.hasShortOption(optName);\n-        // check for several concatenated short options\n+        boolean hasOption = options.hasShortOption(optName);\n+        \n+        // If option is not recognized, check for several concatenated short options\n+        if (!hasOption) {\n+            for (char ch : optName.toCharArray()) {\n+                if (!options.hasShortOption(String.valueOf(ch))) {\n+                    return false;\n+                }\n+            }\n+            hasOption = true;\n+        }\n+        return hasOption;\n     }\n \n+\n     /**\n      * Tells if the token looks like a long option.\n      *"}
{"project": "Cli", "bug_id": "40", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            throw new ParseException(\"Cannot parse the value: \" + str + \" for class: \" + clazz);", "diff": "diff --git a/src/main/java/org/apache/commons/cli/TypeHandler.java b/src/main/java/org/apache/commons/cli/TypeHandler.java\nindex 6bd84b0..a108285 100644\n--- a/src/main/java/org/apache/commons/cli/TypeHandler.java\n+++ b/src/main/java/org/apache/commons/cli/TypeHandler.java\n@@ -100,7 +100,7 @@ public class TypeHandler\n         }\n         else\n         {\n-            return null;\n+            throw new ParseException(\"Cannot parse the value: \" + str + \" for class: \" + clazz);\n         }\n     }\n "}
{"project": "Closure", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "2", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n  private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n      String functionName, HashMap<String, ObjectType> properties,\n      HashMap<String, ObjectType> currentProperties,\n      ObjectType interfaceType) {\n    ObjectType implicitProto = interfaceType.getImplicitPrototype();\n    Set<String> currentPropertyNames;\n    // This can be the case if interfaceType is proxy to a non-existent\n    // object (which is a bad type annotation, but shouldn't crash).\n    if (implicitProto != null) {\n        currentPropertyNames = implicitProto.getOwnPropertyNames();\n        for (String name : currentPropertyNames) {\n            ObjectType oType = properties.get(name);\n            if (oType != null) {\n                if (!interfaceType.getPropertyType(name).isEquivalentTo(\n                    oType.getPropertyType(name))) {\n                    compiler.report(\n                        t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n                            functionName, name, oType.toString(),\n                            interfaceType.toString()));\n                }\n            }\n            currentProperties.put(name, interfaceType);\n        }\n    }\n    for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n        if(iType != null) {\n            checkInterfaceConflictProperties(t, n, functionName, properties,\n                currentProperties, iType);\n        }\n    }\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex a0f95db9..59a4fc47 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1563,34 +1563,40 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * that have been visited\n    * @param interfaceType The super interface that is being visited\n    */\n+\n   private void checkInterfaceConflictProperties(NodeTraversal t, Node n,\n       String functionName, HashMap<String, ObjectType> properties,\n       HashMap<String, ObjectType> currentProperties,\n       ObjectType interfaceType) {\n     ObjectType implicitProto = interfaceType.getImplicitPrototype();\n     Set<String> currentPropertyNames;\n-      // This can be the case if interfaceType is proxy to a non-existent\n-      // object (which is a bad type annotation, but shouldn't crash).\n-      currentPropertyNames = implicitProto.getOwnPropertyNames();\n-    for (String name : currentPropertyNames) {\n-      ObjectType oType = properties.get(name);\n-      if (oType != null) {\n-        if (!interfaceType.getPropertyType(name).isEquivalentTo(\n-            oType.getPropertyType(name))) {\n-          compiler.report(\n-              t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n-                  functionName, name, oType.toString(),\n-                  interfaceType.toString()));\n+    // This can be the case if interfaceType is proxy to a non-existent\n+    // object (which is a bad type annotation, but shouldn't crash).\n+    if (implicitProto != null) {\n+        currentPropertyNames = implicitProto.getOwnPropertyNames();\n+        for (String name : currentPropertyNames) {\n+            ObjectType oType = properties.get(name);\n+            if (oType != null) {\n+                if (!interfaceType.getPropertyType(name).isEquivalentTo(\n+                    oType.getPropertyType(name))) {\n+                    compiler.report(\n+                        t.makeError(n, INCOMPATIBLE_EXTENDED_PROPERTY_TYPE,\n+                            functionName, name, oType.toString(),\n+                            interfaceType.toString()));\n+                }\n+            }\n+            currentProperties.put(name, interfaceType);\n         }\n-      }\n-      currentProperties.put(name, interfaceType);\n     }\n     for (ObjectType iType : interfaceType.getCtorExtendedInterfaces()) {\n-      checkInterfaceConflictProperties(t, n, functionName, properties,\n-          currentProperties, iType);\n+        if(iType != null) {\n+            checkInterfaceConflictProperties(t, n, functionName, properties,\n+                currentProperties, iType);\n+        }\n     }\n   }\n \n+\n   /**\n    * Visits a {@link Token#FUNCTION} node.\n    *"}
{"project": "Closure", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "5", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n\n        if (gramps.isDelProp()) {\n          return false;\n        }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..ac5ca757 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -174,6 +174,12 @@ class InlineObjectLiterals implements CompilerPass {\n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n \n+\n+        if (gramps.isDelProp()) {\n+          return false;\n+        }\n+\n+\n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an\n           // object, then the value is undefined. This is not true, because"}
{"project": "Closure", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "10", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "      return mayBeStringHelper(n);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex eef27927..fb514773 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1414,7 +1414,7 @@ public final class NodeUtil {\n \n   static boolean mayBeString(Node n, boolean recurse) {\n     if (recurse) {\n-      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n+      return mayBeStringHelper(n);\n     } else {\n       return mayBeStringHelper(n);\n     }"}
{"project": "Closure", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "13", "eval": "PASS", "attempt": 9, "mode": "SF", "patch": "\nprivate void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\nindex b51c088e..3a132fec 100644\n--- a/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n+++ b/src/com/google/javascript/jscomp/PeepholeOptimizationsPass.java\n@@ -110,7 +110,8 @@ class PeepholeOptimizationsPass\n     compiler.removeChangeHandler(handler);\n   }\n \n-  private void traverse(Node node) {\n+\n+private void traverse(Node node) {\n     // The goal here is to avoid retraversing\n     // the entire AST to catch newly created opportunities.\n     // So we track whether a \"unit of code\" has changed,\n@@ -123,8 +124,8 @@ class PeepholeOptimizationsPass\n     do {\n       Node c = node.getFirstChild();\n       while(c != null) {\n-        traverse(c);\n         Node next = c.getNext();\n+        traverse(c);\n         c = next;\n       }\n \n@@ -135,7 +136,8 @@ class PeepholeOptimizationsPass\n     } while (shouldRetraverse(node));\n \n     exitNode(node);\n-  }\n+}\n+\n \n   private boolean shouldRetraverse(Node node) {\n     if (node.getParent() != null && node.isFunction() || node.isScript()) {"}
{"project": "Closure", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      if (options.dependencyOptions.needsManagement()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77f..3756b998 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      if (options.dependencyOptions.needsManagement()) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process."}
{"project": "Closure", "bug_id": "19", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\nprotected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        scope.inferSlotType(\"this\", type);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..e196b985 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,7 +154,8 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n         scope.inferSlotType(node.getString(), type);\n@@ -169,13 +170,16 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n+      case Token.THIS:\n+        scope.inferSlotType(\"this\", type);\n+        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n             node.toStringTree());\n     }\n-  }\n+}\n+\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)"}
{"project": "Closure", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "29", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "31", "eval": "PASS", "attempt": 15, "mode": "SL", "patch": "          options.dependencyOptions.needsManagement() &&", "diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..3f255226 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,7 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+          options.dependencyOptions.needsManagement() &&\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they"}
{"project": "Closure", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "44", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n  void add(String newcode) {\n    maybeEndStatement();\n\n    if (newcode.length() == 0) {\n      return;\n    }\n\n    char c = newcode.charAt(0);\n    if ((isWordChar(c) || c == '\\\\') &&\n        isWordChar(getLastChar())) {\n      // need space to separate. This is not pretty printing.\n      // For example: \"return foo;\"\n      append(\" \");\n      // Do not allow a forward slash to appear after a DIV.\n      // For example,\n      // REGEXP DIV REGEXP\n      // is valid and should print like\n      // / // / /\n    }\n\n    // Fix the bug here\n    if (c == '/' && getLastChar() == '/') {\n      append(\" \");\n    }\n\n    append(newcode);\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 47556652..0e74c403 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -178,6 +178,7 @@ abstract class CodeConsumer {\n   void endCaseBody() {\n   }\n \n+\n   void add(String newcode) {\n     maybeEndStatement();\n \n@@ -198,9 +199,15 @@ abstract class CodeConsumer {\n       // / // / /\n     }\n \n+    // Fix the bug here\n+    if (c == '/' && getLastChar() == '/') {\n+      append(\" \");\n+    }\n+\n     append(newcode);\n   }\n \n+\n   void appendOp(String op, boolean binOp) {\n     append(op);\n   }"}
{"project": "Closure", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "52", "eval": "PASS", "attempt": 12, "mode": "SL", "patch": "    return len > 0 && s.charAt(0) != '0';", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex ac6299d1..535148cd 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -742,7 +742,7 @@ class CodeGenerator {\n         return false;\n       }\n     }\n-    return len > 0;\n+    return len > 0 && s.charAt(0) != '0';\n   }\n \n   static double getSimpleNumber(String s) {"}
{"project": "Closure", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "56", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\npublic String getLine(int lineNumber) {\n    String js = \"\";\n    try {\n      // NOTE(nicksantos): Right now, this is optimized for few warnings.\n      // This is probably the right trade-off, but will be slow if there\n      // are lots of warnings in one file.\n      js = getCode();\n    } catch (IOException e) {\n      return null;\n    }\n\n    int pos = 0;\n    int startLine = 1;\n\n    // If we've saved a previous offset and it's for a line less than the\n    // one we're searching for, then start at that point.\n    if (lineNumber >= lastLine) {\n      pos = lastOffset;\n      startLine = lastLine;\n    }\n\n    for (int n = startLine; n < lineNumber; n++) {\n      int nextpos = js.indexOf('\\n', pos);\n      if (nextpos == -1) {\n        return null;\n      }\n      pos = nextpos + 1;\n    }\n\n    // Remember this offset for the next search we do.\n    lastOffset = pos;\n    lastLine = lineNumber;\n\n    if (js.indexOf('\\n', pos) == -1) {\n      // If next new line cannot be found, there are two cases\n      // 1. pos already reaches the end of file, then null should be returned\n      // 2. otherwise, return the contents between pos and the end of file.\n        if(pos == js.length()) {\n            return null;\n        } else {\n            return js.substring(pos);\n        }\n    } else {\n      return js.substring(pos, js.indexOf('\\n', pos));\n    }\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/SourceFile.java b/src/com/google/javascript/jscomp/SourceFile.java\nindex fc0cf3fc..1dc8c0cc 100644\n--- a/src/com/google/javascript/jscomp/SourceFile.java\n+++ b/src/com/google/javascript/jscomp/SourceFile.java\n@@ -202,7 +202,8 @@ public class SourceFile implements StaticSourceFile, Serializable {\n    *     of the file. Returns {@code null} if it does not exist,\n    *     or if there was an IO exception.\n    */\n-  public String getLine(int lineNumber) {\n+\n+public String getLine(int lineNumber) {\n     String js = \"\";\n     try {\n       // NOTE(nicksantos): Right now, this is optimized for few warnings.\n@@ -239,12 +240,17 @@ public class SourceFile implements StaticSourceFile, Serializable {\n       // If next new line cannot be found, there are two cases\n       // 1. pos already reaches the end of file, then null should be returned\n       // 2. otherwise, return the contents between pos and the end of file.\n-        return null;\n+        if(pos == js.length()) {\n+            return null;\n+        } else {\n+            return js.substring(pos);\n+        }\n     } else {\n       return js.substring(pos, js.indexOf('\\n', pos));\n     }\n   }\n \n+\n   /**\n    * Get a region around the indicated line number. The exact definition of a\n    * region is implementation specific, but it must contain the line indicated"}
{"project": "Closure", "bug_id": "57", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "          if (target != null && target.getType() == Token.STRING) {", "diff": "diff --git a/src/com/google/javascript/jscomp/ClosureCodingConvention.java b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\nindex c507c924..b5a3c1b2 100644\n--- a/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n+++ b/src/com/google/javascript/jscomp/ClosureCodingConvention.java\n@@ -194,7 +194,7 @@ public class ClosureCodingConvention extends DefaultCodingConvention {\n         String qualifiedName = callee.getQualifiedName();\n         if (functionName.equals(qualifiedName)) {\n           Node target = callee.getNext();\n-          if (target != null) {\n+          if (target != null && target.getType() == Token.STRING) {\n             className = target.getString();\n           }\n         }"}
{"project": "Closure", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "59", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "62", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "          && 0 <= charno && charno <= sourceExcerpt.length()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\nindex 5a4f884c..420dbc07 100644\n--- a/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n+++ b/src/com/google/javascript/jscomp/LightweightMessageFormatter.java\n@@ -95,7 +95,7 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {\n       // charno == sourceExpert.length() means something is missing\n       // at the end of the line\n       if (excerpt.equals(LINE)\n-          && 0 <= charno && charno < sourceExcerpt.length()) {\n+          && 0 <= charno && charno <= sourceExcerpt.length()) {\n         for (int i = 0; i < charno; i++) {\n           char c = sourceExcerpt.charAt(i);\n           if (Character.isWhitespace(c)) {"}
{"project": "Closure", "bug_id": "65", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "        case '\\0': sb.append(\"\\\\000\"); break;", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 6117a89b..cb9229a8 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1012,7 +1012,7 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n+        case '\\0': sb.append(\"\\\\000\"); break;\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;"}
{"project": "Closure", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "67", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "70", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "                  jsDocParameter.getJSType(), false);", "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 210bb66e..aa7e2458 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1742,7 +1742,7 @@ final class TypedScopeCreator implements ScopeCreator {\n           for (Node astParameter : astParameters.children()) {\n             if (jsDocParameter != null) {\n               defineSlot(astParameter, functionNode,\n-                  jsDocParameter.getJSType(), true);\n+                  jsDocParameter.getJSType(), false);\n               jsDocParameter = jsDocParameter.getNext();\n             } else {\n               defineSlot(astParameter, functionNode, null, true);"}
{"project": "Closure", "bug_id": "71", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "73", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "            if (c > 0x1f && c < 0x7f) {", "diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..823d897a 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,7 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+            if (c > 0x1f && c < 0x7f) {\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,"}
{"project": "Closure", "bug_id": "77", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "80", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "81", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "83", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "86", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return locals.apply(value);", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dd78f900..4d7360ad 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,7 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        return locals.apply(value);\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:"}
{"project": "Closure", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "91", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "92", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "94", "eval": "PASS", "attempt": 18, "mode": "SF", "patch": "\nstatic boolean isValidDefineValue(Node val, Set<String> defines) {\n  switch (val.getType()) {\n    case Token.STRING:\n    case Token.NUMBER:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n\n    // Binary operators are only valid if both children are valid.\n    case Token.BITAND:\n    case Token.BITOR:\n    case Token.BITXOR:\n    case Token.ADD:\n      return isValidDefineValue(val.getFirstChild(), defines)\n          && isValidDefineValue(val.getLastChild(), defines);\n\n    // Uniary operators are valid if the child is valid.\n    case Token.NOT:\n    case Token.NEG:\n      return isValidDefineValue(val.getFirstChild(), defines);\n\n    // Names are valid if and only if they are defines themselves.\n    case Token.NAME:\n    case Token.GETPROP:\n      if (val.isQualifiedName()) {\n        return defines.contains(val.getQualifiedName());\n      }\n  }\n  return false;\n}\n", "diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex a31b17a2..02a38cc5 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -317,34 +317,38 @@ public final class NodeUtil {\n    * @param val The value being assigned.\n    * @param defines The list of names of existing defines.\n    */\n-  static boolean isValidDefineValue(Node val, Set<String> defines) {\n-    switch (val.getType()) {\n-      case Token.STRING:\n-      case Token.NUMBER:\n-      case Token.TRUE:\n-      case Token.FALSE:\n-        return true;\n \n-      // Binary operators are only valid if both children are valid.\n-      case Token.BITAND:\n-      case Token.BITNOT:\n-      case Token.BITOR:\n-      case Token.BITXOR:\n-\n-      // Uniary operators are valid if the child is valid.\n-      case Token.NOT:\n-      case Token.NEG:\n-        return isValidDefineValue(val.getFirstChild(), defines);\n+static boolean isValidDefineValue(Node val, Set<String> defines) {\n+  switch (val.getType()) {\n+    case Token.STRING:\n+    case Token.NUMBER:\n+    case Token.TRUE:\n+    case Token.FALSE:\n+      return true;\n \n-      // Names are valid if and only if they are defines themselves.\n-      case Token.NAME:\n-      case Token.GETPROP:\n-        if (val.isQualifiedName()) {\n-          return defines.contains(val.getQualifiedName());\n-        }\n-    }\n-    return false;\n+    // Binary operators are only valid if both children are valid.\n+    case Token.BITAND:\n+    case Token.BITOR:\n+    case Token.BITXOR:\n+    case Token.ADD:\n+      return isValidDefineValue(val.getFirstChild(), defines)\n+          && isValidDefineValue(val.getLastChild(), defines);\n+\n+    // Uniary operators are valid if the child is valid.\n+    case Token.NOT:\n+    case Token.NEG:\n+      return isValidDefineValue(val.getFirstChild(), defines);\n+\n+    // Names are valid if and only if they are defines themselves.\n+    case Token.NAME:\n+    case Token.GETPROP:\n+      if (val.isQualifiedName()) {\n+        return defines.contains(val.getQualifiedName());\n+      }\n   }\n+  return false;\n+}\n+\n \n   /**\n    * Returns whether this a BLOCK node with no children."}
{"project": "Closure", "bug_id": "95", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "96", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "97", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "99", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "104", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "    if (result != null && !result.isEmptyType()) {", "diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..c6dbfd28 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,7 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+    if (result != null && !result.isEmptyType()) {\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);"}
{"project": "Closure", "bug_id": "105", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "109", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "111", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "113", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "114", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "115", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "116", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "117", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "118", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "119", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "120", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "121", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "122", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "123", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "124", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n  private boolean isSafeReplacement(Node node, Node replacement) {\n    // No checks are needed for simple names.\n    if (node.isName()) {\n      return true;\n    }\n    Preconditions.checkArgument(node.isGetProp());\n\n    Node targetNode = node.getFirstChild();\n    while (targetNode.isGetProp()) {\n      targetNode = targetNode.getFirstChild();\n    }\n\n    if (targetNode.isName()\n        && isNameAssignedTo(targetNode.getString(), replacement)) {\n      return false;\n    }\n\n    return true;\n  }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/ExploitAssigns.java b/src/com/google/javascript/jscomp/ExploitAssigns.java\nindex 0f03e355..b17d8b9b 100644\n--- a/src/com/google/javascript/jscomp/ExploitAssigns.java\n+++ b/src/com/google/javascript/jscomp/ExploitAssigns.java\n@@ -203,6 +203,7 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n    * changed.\n    * @return Whether the replacement can be made.\n    */\n+\n   private boolean isSafeReplacement(Node node, Node replacement) {\n     // No checks are needed for simple names.\n     if (node.isName()) {\n@@ -210,15 +211,20 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n     }\n     Preconditions.checkArgument(node.isGetProp());\n \n-      node = node.getFirstChild();\n-    if (node.isName()\n-        && isNameAssignedTo(node.getString(), replacement)) {\n+    Node targetNode = node.getFirstChild();\n+    while (targetNode.isGetProp()) {\n+      targetNode = targetNode.getFirstChild();\n+    }\n+\n+    if (targetNode.isName()\n+        && isNameAssignedTo(targetNode.getString(), replacement)) {\n       return false;\n     }\n \n     return true;\n   }\n \n+\n   /**\n    * @return Whether name is assigned in the expression rooted at node.\n    */\n@@ -241,4 +247,4 @@ class ExploitAssigns extends AbstractPeepholeOptimization {\n \n     return false;\n   }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Closure", "bug_id": "125", "eval": "PASS", "attempt": 17, "mode": "SL", "patch": "      if (fnType != null && fnType.hasInstanceType()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 4e053258..de14c04e 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1658,7 +1658,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n     if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n       FunctionType fnType = type.toMaybeFunctionType();\n-      if (fnType != null) {\n+      if (fnType != null && fnType.hasInstanceType()) {\n         visitParameterList(t, n, fnType);\n         ensureTyped(t, n, fnType.getInstanceType());\n       } else {"}
{"project": "Closure", "bug_id": "126", "eval": "PASS", "attempt": 16, "mode": "SH", "patch": "\n    /* Don't try to minimize the exits of finally blocks, as this\n     * can cause problems if it changes the completion type of the finally\n     * block. See ECMA 262 Sections 8.9 & 12.14\n     */\n    if (NodeUtil.hasFinally(n)) {\n      return;\n    }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..04f67a51 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,15 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+\n+    /* Don't try to minimize the exits of finally blocks, as this\n+     * can cause problems if it changes the completion type of the finally\n+     * block. See ECMA 262 Sections 8.9 & 12.14\n+     */\n+    if (NodeUtil.hasFinally(n)) {\n+      return;\n+    }\n+\n     }\n \n     // Just a 'label'."}
{"project": "Closure", "bug_id": "128", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "129", "eval": "PASS", "attempt": 19, "mode": "SH", "patch": "\n      if (first.isCast()) {\n        first = first.getFirstChild();\n      }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex d993bee7..6b472251 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -164,6 +164,11 @@ class PrepareAst implements CompilerPass {\n \n       // ignore cast nodes.\n \n+      if (first.isCast()) {\n+        first = first.getFirstChild();\n+      }\n+\n+\n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);\n       }"}
{"project": "Closure", "bug_id": "130", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "131", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\n    public static boolean isJSIdentifier(String s) {\n      int length = s.length();\n\n      if (length == 0 ||\n          !Character.isJavaIdentifierStart(s.charAt(0))) {\n        return false;\n      }\n\n      for (int i = 1; i < length; i++) {\n        if (s.charAt(i) == '\\u0004' ||\n            !Character.isJavaIdentifierPart(s.charAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n", "diff": "diff --git a/src/com/google/javascript/rhino/TokenStream.java b/src/com/google/javascript/rhino/TokenStream.java\nindex 144a4adc..05d98515 100644\n--- a/src/com/google/javascript/rhino/TokenStream.java\n+++ b/src/com/google/javascript/rhino/TokenStream.java\n@@ -187,6 +187,7 @@ public class TokenStream {\n         return id;\n     }\n \n+\n     public static boolean isJSIdentifier(String s) {\n       int length = s.length();\n \n@@ -196,7 +197,7 @@ public class TokenStream {\n       }\n \n       for (int i = 1; i < length; i++) {\n-        if (\n+        if (s.charAt(i) == '\\u0004' ||\n             !Character.isJavaIdentifierPart(s.charAt(i))) {\n           return false;\n         }\n@@ -204,4 +205,5 @@ public class TokenStream {\n \n       return true;\n     }\n+\n }"}
{"project": "Closure", "bug_id": "132", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "133", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "140", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "145", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "146", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "150", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "152", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "159", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "160", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "161", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\n      // If GETPROP/GETELEM is used as assignment target the array literal is\n      // acting as a temporary we can't fold it here:\n      //    \"[][0] += 1\"\n      return n;\n    }\n", "diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..a0c2c5af 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1281,6 +1281,14 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n \n+    if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) {\n+      // If GETPROP/GETELEM is used as assignment target the array literal is\n+      // acting as a temporary we can't fold it here:\n+      //    \"[][0] += 1\"\n+      return n;\n+    }\n+\n+\n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into\n       // arrays, or strings to index into array methods."}
{"project": "Closure", "bug_id": "164", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Closure", "bug_id": "168", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "      if (t.inGlobalScope()) {", "diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..f1790dab 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1993,7 +1993,7 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+      if (t.inGlobalScope()) {\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")"}
{"project": "Closure", "bug_id": "176", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "6", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\npublic int read(byte b[], int offset, int len) throws IOException {\n    if (b == null) {\n        throw new NullPointerException();\n    } else if (offset < 0 || len < 0) {\n        throw new IndexOutOfBoundsException();\n    } else if (offset > b.length || offset + len > b.length) {\n        throw new IndexOutOfBoundsException();\n    } else if (len == 0) {\n        return 0;\n    } else {\n        /*\n         Rationale for while-loop on (readLen == 0):\n         -----\n         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n         rare case where it returns 0, we just keep trying.\n\n         This is essentially an undocumented contract for InputStream\n         implementors that want their code to work properly with\n         java.io.InputStreamReader, since the latter hates it when\n         InputStream.read(byte[]) returns a zero.  Unfortunately our\n         readResults() call must return 0 if a large amount of the data\n         being decoded was non-base64, so this while-loop enables proper\n         interop with InputStreamReader for that scenario.\n         -----\n         This is a fix for CODEC-101\n        */\n        int readLen = -1;\n        while((readLen = base64.readResults(b, offset, len)) == 0) {\n            if (!base64.hasData()) {\n                byte[] buf = new byte[doEncode ? 4096 : 8192];\n                int c = in.read(buf);\n                // A little optimization to avoid System.arraycopy()\n                // when possible.\n                if (c > 0 && b.length == len) {\n                    base64.setInitialBuffer(b, offset, len);\n                }\n                if (doEncode) {\n                    base64.encode(buf, 0, c);\n                } else {\n                    base64.decode(buf, 0, c);\n                }\n            } else {\n                break;\n            }\n        }\n        return readLen;\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64InputStream.java b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\nindex 583a5847..300f7629 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64InputStream.java\n@@ -135,49 +135,56 @@ public class Base64InputStream extends FilterInputStream {\n      * @throws IndexOutOfBoundsException\n      *             if offset, len or buffer size are invalid\n      */\n-    public int read(byte b[], int offset, int len) throws IOException {\n-        if (b == null) {\n-            throw new NullPointerException();\n-        } else if (offset < 0 || len < 0) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (offset > b.length || offset + len > b.length) {\n-            throw new IndexOutOfBoundsException();\n-        } else if (len == 0) {\n-            return 0;\n-        } else {\n-            /*\n-             Rationale for while-loop on (readLen == 0):\n-             -----\n-             Base64.readResults() usually returns > 0 or EOF (-1).  In the\n-             rare case where it returns 0, we just keep trying.\n \n-             This is essentially an undocumented contract for InputStream\n-             implementors that want their code to work properly with\n-             java.io.InputStreamReader, since the latter hates it when\n-             InputStream.read(byte[]) returns a zero.  Unfortunately our\n-             readResults() call must return 0 if a large amount of the data\n-             being decoded was non-base64, so this while-loop enables proper\n-             interop with InputStreamReader for that scenario.\n-             -----\n-             This is a fix for CODEC-101\n-            */\n-                if (!base64.hasData()) {\n-                    byte[] buf = new byte[doEncode ? 4096 : 8192];\n-                    int c = in.read(buf);\n-                    // A little optimization to avoid System.arraycopy()\n-                    // when possible.\n-                    if (c > 0 && b.length == len) {\n-                        base64.setInitialBuffer(b, offset, len);\n-                    }\n-                    if (doEncode) {\n-                        base64.encode(buf, 0, c);\n-                    } else {\n-                        base64.decode(buf, 0, c);\n-                    }\n+public int read(byte b[], int offset, int len) throws IOException {\n+    if (b == null) {\n+        throw new NullPointerException();\n+    } else if (offset < 0 || len < 0) {\n+        throw new IndexOutOfBoundsException();\n+    } else if (offset > b.length || offset + len > b.length) {\n+        throw new IndexOutOfBoundsException();\n+    } else if (len == 0) {\n+        return 0;\n+    } else {\n+        /*\n+         Rationale for while-loop on (readLen == 0):\n+         -----\n+         Base64.readResults() usually returns > 0 or EOF (-1).  In the\n+         rare case where it returns 0, we just keep trying.\n+\n+         This is essentially an undocumented contract for InputStream\n+         implementors that want their code to work properly with\n+         java.io.InputStreamReader, since the latter hates it when\n+         InputStream.read(byte[]) returns a zero.  Unfortunately our\n+         readResults() call must return 0 if a large amount of the data\n+         being decoded was non-base64, so this while-loop enables proper\n+         interop with InputStreamReader for that scenario.\n+         -----\n+         This is a fix for CODEC-101\n+        */\n+        int readLen = -1;\n+        while((readLen = base64.readResults(b, offset, len)) == 0) {\n+            if (!base64.hasData()) {\n+                byte[] buf = new byte[doEncode ? 4096 : 8192];\n+                int c = in.read(buf);\n+                // A little optimization to avoid System.arraycopy()\n+                // when possible.\n+                if (c > 0 && b.length == len) {\n+                    base64.setInitialBuffer(b, offset, len);\n+                }\n+                if (doEncode) {\n+                    base64.encode(buf, 0, c);\n+                } else {\n+                    base64.decode(buf, 0, c);\n                 }\n-            return base64.readResults(b, offset, len);\n+            } else {\n+                break;\n+            }\n         }\n+        return readLen;\n     }\n+}\n+\n \n     /**\n      * {@inheritDoc}"}
{"project": "Codec", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "9", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, isChunked ? CHUNK_SEPARATOR : null);", "diff": "diff --git a/src/java/org/apache/commons/codec/binary/Base64.java b/src/java/org/apache/commons/codec/binary/Base64.java\nindex 2cd0163b..243a2169 100644\n--- a/src/java/org/apache/commons/codec/binary/Base64.java\n+++ b/src/java/org/apache/commons/codec/binary/Base64.java\n@@ -824,7 +824,7 @@ public class Base64 implements BinaryEncoder, BinaryDecoder {\n             return binaryData;\n         }\n \n-        long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n+        long len = getEncodeLength(binaryData, isChunked ? MIME_CHUNK_SIZE : 0, isChunked ? CHUNK_SEPARATOR : null);\n         if (len > maxResultSize) {\n             throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                 len +"}
{"project": "Codec", "bug_id": "10", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "        txt = txt.replaceAll(\"mb$\", \"M1\");", "diff": "diff --git a/src/java/org/apache/commons/codec/language/Caverphone.java b/src/java/org/apache/commons/codec/language/Caverphone.java\nindex 5ac7e9ce..6d977211 100644\n--- a/src/java/org/apache/commons/codec/language/Caverphone.java\n+++ b/src/java/org/apache/commons/codec/language/Caverphone.java\n@@ -73,7 +73,7 @@ public class Caverphone implements StringEncoder {\n         txt = txt.replaceAll(\"^gn\", \"2n\");\n \n         // End \n-        txt = txt.replaceAll(\"^mb\", \"m2\");\n+        txt = txt.replaceAll(\"mb$\", \"M1\");\n \n         // 4. Handle replacements\n         txt = txt.replaceAll(\"cq\", \"2q\");"}
{"project": "Codec", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Codec", "bug_id": "17", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex 5b14ca0c..9ca695b9 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -336,7 +336,7 @@ public class StringUtils {\n      * @since As of 1.7, throws {@link NullPointerException} instead of UnsupportedEncodingException\n      */\n     public static String newStringIso8859_1(final byte[] bytes) {\n-        return new String(bytes, Charsets.ISO_8859_1);\n+        return bytes == null ? null : new String(bytes, Charsets.ISO_8859_1);\n     }\n \n     /**"}
{"project": "Codec", "bug_id": "18", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());", "diff": "diff --git a/src/main/java/org/apache/commons/codec/binary/StringUtils.java b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\nindex bef55f70..e5fb7187 100644\n--- a/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n+++ b/src/main/java/org/apache/commons/codec/binary/StringUtils.java\n@@ -78,7 +78,7 @@ public class StringUtils {\n         if (cs1 instanceof String && cs2 instanceof String) {\n             return cs1.equals(cs2);\n         }\n-        return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n+        return cs1.length() == cs2.length() && CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, cs1.length());\n     }\n \n     /**"}
{"project": "Collections", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "7", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public static String parseName(byte[] buffer, final int offset, final int length) {\n        StringBuilder result = new StringBuilder(length);\n        int          end = offset + length;\n\n        for (int i = offset; i < end; ++i) {\n            if (buffer[i] == 0) {\n                break;\n            }\n            result.append((char)(buffer[i] & 0xFF));\n        }\n\n        return result.toString();\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex bca115fa..813b83e9 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -90,20 +90,22 @@ public class TarUtils {\n      * @param length The maximum number of bytes to parse.\n      * @return The entry name.\n      */\n+\n     public static String parseName(byte[] buffer, final int offset, final int length) {\n-        StringBuffer result = new StringBuffer(length);\n+        StringBuilder result = new StringBuilder(length);\n         int          end = offset + length;\n \n         for (int i = offset; i < end; ++i) {\n             if (buffer[i] == 0) {\n                 break;\n             }\n-            result.append((char) buffer[i]);\n+            result.append((char)(buffer[i] & 0xFF));\n         }\n \n         return result.toString();\n     }\n \n+\n     /**\n      * Copy a name (StringBuffer) into a buffer.\n      * Copies characters from the name into the buffer"}
{"project": "Compress", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "13", "eval": "PASS", "attempt": 8, "mode": "SH", "patch": "\n        if (name.contains(\"\\\\\")) {\n            name = name.replace(\"\\\\\", \"/\");\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 88cf183f..ddccf27e 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -509,6 +509,11 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n      * @param name the name to use\n      */\n     protected void setName(String name) {\n+\n+        if (name.contains(\"\\\\\")) {\n+            name = name.replace(\"\\\\\", \"/\");\n+        }\n+\n         this.name = name;\n     }\n "}
{"project": "Compress", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "15", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (obj == null || getClass() != obj.getClass()) {\n            return false;\n        }\n        ZipArchiveEntry other = (ZipArchiveEntry) obj;\n        String myName = getName();\n        String otherName = other.getName();\n        if (myName == null) {\n            if (otherName != null) {\n                return false;\n            }\n        } else if (!myName.equals(otherName)) {\n            return false;\n        }\n        String myComment = getComment() == null ? \"\" : getComment();\n        String otherComment = other.getComment() == null ? \"\" : other.getComment();\n        if (myComment == null) {\n            if (otherComment != null) {\n                return false;\n            }\n        } else if (!myComment.equals(otherComment)) {\n            return false;\n        }\n        return getTime() == other.getTime()\n            && getInternalAttributes() == other.getInternalAttributes()\n            && getPlatform() == other.getPlatform()\n            && getExternalAttributes() == other.getExternalAttributes()\n            && getMethod() == other.getMethod()\n            && getSize() == other.getSize()\n            && getCrc() == other.getCrc()\n            && getCompressedSize() == other.getCompressedSize()\n            && Arrays.equals(getCentralDirectoryExtra(),\n                             other.getCentralDirectoryExtra())\n            && Arrays.equals(getLocalFileDataExtra(),\n                             other.getLocalFileDataExtra())\n            && gpb.equals(other.gpb);\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\nindex 1833227c..fac9468d 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveEntry.java\n@@ -646,6 +646,7 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n      * @see java.lang.Object#equals(java.lang.Object)\n      */\n     @Override\n+\n     public boolean equals(Object obj) {\n         if (this == obj) {\n             return true;\n@@ -663,8 +664,8 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n         } else if (!myName.equals(otherName)) {\n             return false;\n         }\n-        String myComment = getComment();\n-        String otherComment = other.getComment();\n+        String myComment = getComment() == null ? \"\" : getComment();\n+        String otherComment = other.getComment() == null ? \"\" : other.getComment();\n         if (myComment == null) {\n             if (otherComment != null) {\n                 return false;\n@@ -686,4 +687,5 @@ public class ZipArchiveEntry extends java.util.zip.ZipEntry\n                              other.getLocalFileDataExtra())\n             && gpb.equals(other.gpb);\n     }\n+\n }"}
{"project": "Compress", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "21", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n        int cache = 0;\n        int shift = 7;\n        for (int i = 0; i < length; i++) {\n            cache |= ((bits.get(i) ? 1 : 0) << shift);\n            --shift;\n            if (shift == -1) {\n                header.write(cache);\n                shift = 7;\n                cache = 0;\n            }\n        }\n        if (length > 0 && shift != 7) {\n            header.write(cache);\n        }\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\nindex 05912b9f..c7fa8a63 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/SevenZOutputFile.java\n@@ -631,23 +631,25 @@ public class SevenZOutputFile {\n         }\n     }\n \n+\n     private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\n         int cache = 0;\n         int shift = 7;\n         for (int i = 0; i < length; i++) {\n             cache |= ((bits.get(i) ? 1 : 0) << shift);\n             --shift;\n-            if (shift == 0) {\n+            if (shift == -1) {\n                 header.write(cache);\n                 shift = 7;\n                 cache = 0;\n             }\n         }\n-        if (length > 0 && shift > 0) {\n+        if (length > 0 && shift != 7) {\n             header.write(cache);\n         }\n     }\n \n+\n     private class OutputStreamWrapper extends OutputStream {\n         @Override\n         public void write(final int b) throws IOException {"}
{"project": "Compress", "bug_id": "23", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "                dictSize |= ((long) coder.properties[i + 1] & 0xFF) << (8 * i);", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\nindex 0bc5a1ee..5a9e9dd9 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java\n@@ -109,7 +109,7 @@ class Coders {\n             byte propsByte = coder.properties[0];\n             long dictSize = coder.properties[1];\n             for (int i = 1; i < 4; i++) {\n-                dictSize |= (coder.properties[i + 1] << (8 * i));\n+                dictSize |= ((long) coder.properties[i + 1] & 0xFF) << (8 * i);\n             }\n             if (dictSize > LZMAInputStream.DICT_SIZE_MAX) {\n                 throw new IOException(\"Dictionary larger than 4GiB maximum size\");"}
{"project": "Compress", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "26", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (numToSkip > 0) {\n            int b;\n            while (numToSkip > 0 && (b = input.read()) != -1) {\n                numToSkip--;\n            }\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/utils/IOUtils.java b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\nindex 686d75ad..f5b05bed 100644\n--- a/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n+++ b/src/main/java/org/apache/commons/compress/utils/IOUtils.java\n@@ -101,6 +101,14 @@ public final class IOUtils {\n             numToSkip -= skipped;\n         }\n             \n+\n+        if (numToSkip > 0) {\n+            int b;\n+            while (numToSkip > 0 && (b = input.read()) != -1) {\n+                numToSkip--;\n+            }\n+        }\n+\n         return available - numToSkip;\n     }\n "}
{"project": "Compress", "bug_id": "27", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (start == end) {\n            return 0L;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 4cf32d6f..f0b1f005 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -130,11 +130,12 @@ public class TarUtils {\n             end--;\n             trailer = buffer[end - 1];\n         }\n+\n         if (start == end) {\n-            throw new IllegalArgumentException(\n-                    exceptionMessage(buffer, offset, length, start, trailer));\n+            return 0L;\n         }\n \n+\n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n             // CheckStyle:MagicNumber OFF"}
{"project": "Compress", "bug_id": "28", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public int read(byte[] buf, int offset, int numToRead) throws IOException {\n    \tint totalRead = 0;\n\n        if (hasHitEOF || entryOffset >= entrySize) {\n            return -1;\n        }\n\n        if (currEntry == null) {\n            throw new IllegalStateException(\"No current tar entry\");\n        }\n\n        numToRead = Math.min(numToRead, available());\n        \n        totalRead = is.read(buf, offset, numToRead);\n        count(totalRead);\n        \n        if (totalRead == -1) {\n            if(entryOffset < entrySize){\n                throw new IOException(\"Corrupt tar archive. EOF encountered in the middle of the entry\");\n            }\n        } else {\n            entryOffset += totalRead;\n        }\n\n        return totalRead;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex fe2c1133..ea7a2614 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -566,6 +566,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n      * @throws IOException on error\n      */\n     @Override\n+\n     public int read(byte[] buf, int offset, int numToRead) throws IOException {\n     \tint totalRead = 0;\n \n@@ -583,7 +584,9 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n         count(totalRead);\n         \n         if (totalRead == -1) {\n-            hasHitEOF = true;\n+            if(entryOffset < entrySize){\n+                throw new IOException(\"Corrupt tar archive. EOF encountered in the middle of the entry\");\n+            }\n         } else {\n             entryOffset += totalRead;\n         }\n@@ -591,6 +594,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n         return totalRead;\n     }\n \n+\n     /**\n      * Whether this class is able to read the given entry.\n      *"}
{"project": "Compress", "bug_id": "30", "eval": "PASS", "attempt": 2, "mode": "SH", "patch": "\n        if (len == 0) {\n            return 0;\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\nindex e0e3b1ec..8c2bf0bd 100644\n--- a/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/compressors/bzip2/BZip2CompressorInputStream.java\n@@ -166,6 +166,11 @@ public class BZip2CompressorInputStream extends CompressorInputStream implements\n             throw new IOException(\"stream closed\");\n         }\n \n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+\n         final int hi = offs + len;\n         int destOffs = offs;\n         int b;"}
{"project": "Compress", "bug_id": "31", "eval": "PASS", "attempt": 12, "mode": "SH", "patch": "\n            if ((currentByte < '0' || currentByte > '7') && currentByte != ' ' && currentByte != 0) {\n                throw new IllegalArgumentException(\n                        exceptionMessage(buffer, offset, length, start, currentByte));\n            }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 40e7871f..cb6b31e0 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -132,9 +132,12 @@ public class TarUtils {\n \n         for ( ;start < end; start++) {\n             final byte currentByte = buffer[start];\n-            if (currentByte == 0) {\n-                break;\n+\n+            if ((currentByte < '0' || currentByte > '7') && currentByte != ' ' && currentByte != 0) {\n+                throw new IllegalArgumentException(\n+                        exceptionMessage(buffer, offset, length, start, currentByte));\n             }\n+\n             // CheckStyle:MagicNumber OFF\n             if (currentByte < '0' || currentByte > '7'){\n                 throw new IllegalArgumentException("}
{"project": "Compress", "bug_id": "32", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n        /*\n         * The following headers are defined for Pax.\n         * atime, ctime, charset: cannot use these without changing TarArchiveEntry fields\n         * mtime\n         * comment\n         * gid, gname\n         * linkpath\n         * size\n         * uid,uname\n         * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n         */\n        for (Map.Entry<String, String> ent : headers.entrySet()){\n            String key = ent.getKey();\n            String val = ent.getValue();\n            if (\"path\".equals(key)){\n                currEntry.setName(val);\n            } else if (\"linkpath\".equals(key)){\n                currEntry.setLinkName(val);\n            } else if (\"gid\".equals(key)){\n                currEntry.setGroupId(Long.parseLong(val)); // Convert gid to long\n            } else if (\"gname\".equals(key)){\n                currEntry.setGroupName(val);\n            } else if (\"uid\".equals(key)){\n                currEntry.setUserId(Integer.parseInt(val));\n            } else if (\"uname\".equals(key)){\n                currEntry.setUserName(val);\n            } else if (\"size\".equals(key)){\n                currEntry.setSize(Long.parseLong(val));\n            } else if (\"mtime\".equals(key)){\n                currEntry.setModTime((long) (Double.parseDouble(val) * 1000));\n            } else if (\"SCHILY.devminor\".equals(key)){\n                currEntry.setDevMinor(Integer.parseInt(val));\n            } else if (\"SCHILY.devmajor\".equals(key)){\n                currEntry.setDevMajor(Integer.parseInt(val));\n            }\n        } \n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\nindex c5570071..909c4512 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java\n@@ -478,6 +478,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n         return headers;\n     }\n \n+\n     private void applyPaxHeadersToCurrentEntry(Map<String, String> headers) {\n         /*\n          * The following headers are defined for Pax.\n@@ -490,7 +491,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n          * uid,uname\n          * SCHILY.devminor, SCHILY.devmajor: don't have setters/getters for those\n          */\n-        for (Entry<String, String> ent : headers.entrySet()){\n+        for (Map.Entry<String, String> ent : headers.entrySet()){\n             String key = ent.getKey();\n             String val = ent.getValue();\n             if (\"path\".equals(key)){\n@@ -498,7 +499,7 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n             } else if (\"linkpath\".equals(key)){\n                 currEntry.setLinkName(val);\n             } else if (\"gid\".equals(key)){\n-                currEntry.setGroupId(Integer.parseInt(val));\n+                currEntry.setGroupId(Long.parseLong(val)); // Convert gid to long\n             } else if (\"gname\".equals(key)){\n                 currEntry.setGroupName(val);\n             } else if (\"uid\".equals(key)){\n@@ -514,9 +515,10 @@ public class TarArchiveInputStream extends ArchiveInputStream {\n             } else if (\"SCHILY.devmajor\".equals(key)){\n                 currEntry.setDevMajor(Integer.parseInt(val));\n             }\n-        }\n+        } \n     }\n \n+\n     /**\n      * Adds the sparse chunks from the current entry to the sparse chunks,\n      * including any additional sparse entries following the current entry."}
{"project": "Compress", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "36", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "41", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Compress", "bug_id": "44", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n        if (checksum == null || in == null) {\n            throw new NullPointerException();\n        }\n        this.checksum = checksum;\n        this.in = in;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\nindex 10c7d68d..4a6d163d 100644\n--- a/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n+++ b/src/main/java/org/apache/commons/compress/utils/ChecksumCalculatingInputStream.java\n@@ -30,14 +30,16 @@ public class ChecksumCalculatingInputStream extends InputStream {\n     private final InputStream in;\n     private final Checksum checksum;\n \n-    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n-\n-\n \n+    public ChecksumCalculatingInputStream(final Checksum checksum, final InputStream in) {\n+        if (checksum == null || in == null) {\n+            throw new NullPointerException();\n+        }\n         this.checksum = checksum;\n         this.in = in;\n     }\n \n+\n     /**\n      * Reads a single byte from the stream\n      * @throws IOException if the underlying stream throws or the"}
{"project": "Compress", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public static int formatLongOctalOrBinaryBytes(\n        final long value, final byte[] buf, final int offset, final int length) {\n\n        // Check whether we are dealing with UID/GID or SIZE field\n        final long maxAsOctalChar = length == TarConstants.UIDLEN ? TarConstants.MAXID : TarConstants.MAXSIZE;\n\n        final boolean negative = value < 0;\n        if (!negative && value <= maxAsOctalChar) { // OK to store as octal chars\n            return formatLongOctalBytes(value, buf, offset, length);\n        }\n\n        if (length < 9) {\n            formatLongBinary(value, buf, offset, length, negative);\n        } else {\n            formatBigIntegerBinary(value, buf, offset, length, negative);\n        }\n\n        buf[offset] = (byte) (negative ? 0xff : 0x80);\n        return offset + length;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\nindex 39ce5c1a..d9b2331d 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java\n@@ -471,6 +471,7 @@ public static int formatLongOctalBytes(final long value, final byte[] buf, final\n      * will not fit in the buffer.\n      * @since 1.4\n      */\n+\n     public static int formatLongOctalOrBinaryBytes(\n         final long value, final byte[] buf, final int offset, final int length) {\n \n@@ -484,13 +485,15 @@ public static int formatLongOctalOrBinaryBytes(\n \n         if (length < 9) {\n             formatLongBinary(value, buf, offset, length, negative);\n+        } else {\n+            formatBigIntegerBinary(value, buf, offset, length, negative);\n         }\n-        formatBigIntegerBinary(value, buf, offset, length, negative);\n \n         buf[offset] = (byte) (negative ? 0xff : 0x80);\n         return offset + length;\n     }\n \n+\n     private static void formatLongBinary(final long value, final byte[] buf,\n                                          final int offset, final int length,\n                                          final boolean negative) {"}
{"project": "Compress", "bug_id": "46", "eval": "PASS", "attempt": 10, "mode": "SH", "patch": "\n        final long TWO_TO_32 = 0x100000000L;\n        if (l < -TWO_TO_32 / 2 || l >= TWO_TO_32 / 2) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\nindex f7a74406..48ef6338 100644\n--- a/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n+++ b/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java\n@@ -526,8 +526,10 @@ private static ZipLong dateToZipLong(final Date d) {\n     }\n \n     private static ZipLong unixTimeToZipLong(long l) {\n+\n         final long TWO_TO_32 = 0x100000000L;\n-        if (l >= TWO_TO_32) {\n+        if (l < -TWO_TO_32 / 2 || l >= TWO_TO_32 / 2) {\n+\n             throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l);\n         }\n         return new ZipLong(l);"}
{"project": "Csv", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "2", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\npublic String get(final String name) {\n    if (mapping == null) {\n        throw new IllegalStateException(\n                \"No header mapping was specified, the record values can't be accessed by name\");\n    }\n    final Integer index = mapping.get(name);\n        \n    if (index == null || index < 0 || index >= values.length) {\n        throw new IllegalArgumentException(\"Provided name does not exist in the record\");\n    }\n    return values[index.intValue()];\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex dc52017..1735c9a 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -76,14 +76,20 @@ public class CSVRecord implements Serializable, Iterable<String> {\n      *             if the record is inconsistent\n      * @see #isConsistent()\n      */\n-    public String get(final String name) {\n-        if (mapping == null) {\n-            throw new IllegalStateException(\n-                    \"No header mapping was specified, the record values can't be accessed by name\");\n-        }\n-        final Integer index = mapping.get(name);\n-            return index != null ? values[index.intValue()] : null;\n+\n+public String get(final String name) {\n+    if (mapping == null) {\n+        throw new IllegalStateException(\n+                \"No header mapping was specified, the record values can't be accessed by name\");\n+    }\n+    final Integer index = mapping.get(name);\n+        \n+    if (index == null || index < 0 || index >= values.length) {\n+        throw new IllegalArgumentException(\"Provided name does not exist in the record\");\n     }\n+    return values[index.intValue()];\n+}\n+\n \n     /**\n      * Returns true if this record is consistent, false if not. Currently, the only check is matching the record size to"}
{"project": "Csv", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "4", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex 9d56f1a..e97a364 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -285,7 +285,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n      * @return a copy of the header map that iterates in column order.\n      */\n     public Map<String, Integer> getHeaderMap() {\n-        return new LinkedHashMap<String, Integer>(this.headerMap);\n+        return this.headerMap == null ? null : new LinkedHashMap<String, Integer>(this.headerMap);\n     }\n \n     /**"}
{"project": "Csv", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public void println() throws IOException {\n        final String recordSeparator = format.getRecordSeparator();\n        if (recordSeparator != null) {\n            out.append(recordSeparator);\n        }\n        newRecord = true;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex 3255360..baf9cab 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -320,12 +320,16 @@ public final class CSVPrinter implements Flushable, Closeable {\n      * @throws IOException\n      *             If an I/O error occurs\n      */\n+\n     public void println() throws IOException {\n         final String recordSeparator = format.getRecordSeparator();\n+        if (recordSeparator != null) {\n             out.append(recordSeparator);\n+        }\n         newRecord = true;\n     }\n \n+\n     /**\n      * Prints a single line of delimiter separated values. The values will be quoted if needed. Quotes and newLine\n      * characters will be escaped."}
{"project": "Csv", "bug_id": "6", "eval": "PASS", "attempt": 13, "mode": "SF", "patch": "\n    public Iterator<String> iterator() {\n        return toList().iterator();\n    }\n\n    /**\n     * Puts all values of this record into the given Map.\n     *\n     * @param map The Map to populate.\n     * @return the given map.\n     */\n    <M extends Map<String, String>> M putIn(final M map) {\n        for (final Entry<String, Integer> entry : mapping.entrySet()) {\n            int col = entry.getValue().intValue();\n            if (col < values.length) {  // Add this if check to prevent ArrayIndexOutOfBoundsException\n                map.put(entry.getKey(), values[col]);\n            }\n        }\n        return map;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVRecord.java b/src/main/java/org/apache/commons/csv/CSVRecord.java\nindex 7380d9f..5945e65 100644\n--- a/src/main/java/org/apache/commons/csv/CSVRecord.java\n+++ b/src/main/java/org/apache/commons/csv/CSVRecord.java\n@@ -166,6 +166,7 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      *\n      * @return an iterator over the values of this record.\n      */\n+\n     public Iterator<String> iterator() {\n         return toList().iterator();\n     }\n@@ -178,12 +179,15 @@ public final class CSVRecord implements Serializable, Iterable<String> {\n      */\n     <M extends Map<String, String>> M putIn(final M map) {\n         for (final Entry<String, Integer> entry : mapping.entrySet()) {\n-            final int col = entry.getValue().intValue();\n+            int col = entry.getValue().intValue();\n+            if (col < values.length) {  // Add this if check to prevent ArrayIndexOutOfBoundsException\n                 map.put(entry.getKey(), values[col]);\n+            }\n         }\n         return map;\n     }\n \n+\n     /**\n      * Returns the number of values in this record.\n      *"}
{"project": "Csv", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Csv", "bug_id": "10", "eval": "PASS", "attempt": 18, "mode": "SH", "patch": "\n        if (format.getHeader() != null) {\n            for (int i = 0; i < format.getHeader().length; i++) {\n                if (i > 0) {\n                    out.append(format.getDelimiter());\n                }\n                out.append(format.getHeader()[i]);\n            }\n            out.append(format.getRecordSeparator());\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVPrinter.java b/src/main/java/org/apache/commons/csv/CSVPrinter.java\nindex 94e5852..4417b84 100644\n--- a/src/main/java/org/apache/commons/csv/CSVPrinter.java\n+++ b/src/main/java/org/apache/commons/csv/CSVPrinter.java\n@@ -67,6 +67,17 @@ public final class CSVPrinter implements Flushable, Closeable {\n         this.format.validate();\n         // TODO: Is it a good idea to do this here instead of on the first call to a print method?\n         // It seems a pain to have to track whether the header has already been printed or not.\n+\n+        if (format.getHeader() != null) {\n+            for (int i = 0; i < format.getHeader().length; i++) {\n+                if (i > 0) {\n+                    out.append(format.getDelimiter());\n+                }\n+                out.append(format.getHeader()[i]);\n+            }\n+            out.append(format.getRecordSeparator());\n+        }\n+\n     }\n \n     // ======================================================"}
{"project": "Csv", "bug_id": "11", "eval": "PASS", "attempt": 14, "mode": "SL", "patch": "                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVParser.java b/src/main/java/org/apache/commons/csv/CSVParser.java\nindex b6867a4..23d7226 100644\n--- a/src/main/java/org/apache/commons/csv/CSVParser.java\n+++ b/src/main/java/org/apache/commons/csv/CSVParser.java\n@@ -381,7 +381,7 @@ public final class CSVParser implements Iterable<CSVRecord>, Closeable {\n                 for (int i = 0; i < headerRecord.length; i++) {\n                     final String header = headerRecord[i];\n                     final boolean containsHeader = hdrMap.containsKey(header);\n-                    final boolean emptyHeader = header.trim().isEmpty();\n+                    final boolean emptyHeader = (header == null) || header.trim().isEmpty();\n                     if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) {\n                         throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header +\n                                 \"\\\" in \" + Arrays.toString(headerRecord));"}
{"project": "Csv", "bug_id": "14", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                if ((c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z') && (c < '\\u0020' || c > '\\u007E')) {", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35ee86a..3c3919c 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1036,7 +1036,7 @@ public final class CSVFormat implements Serializable {\n                 char c = value.charAt(pos);\n \n                 // RFC4180 (https://tools.ietf.org/html/rfc4180) TEXTDATA =  %x20-21 / %x23-2B / %x2D-7E\n-                if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n+                if ((c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z') && (c < '\\u0020' || c > '\\u007E')) {\n                     quote = true;\n                 } else if (c <= COMMENT) {\n                     // Some other chars at the start of a value caused the parser to fail, so for now"}
{"project": "Csv", "bug_id": "15", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n                if (newRecord && (c < '#')) {\n                    quote = true;\n                } else if (c <= SP) {\n", "diff": "diff --git a/src/main/java/org/apache/commons/csv/CSVFormat.java b/src/main/java/org/apache/commons/csv/CSVFormat.java\nindex 35c2ad1..c2f57c8 100644\n--- a/src/main/java/org/apache/commons/csv/CSVFormat.java\n+++ b/src/main/java/org/apache/commons/csv/CSVFormat.java\n@@ -1186,9 +1186,11 @@ public final class CSVFormat implements Serializable {\n             } else {\n                 char c = value.charAt(pos);\n \n-                if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n+\n+                if (newRecord && (c < '#')) {\n                     quote = true;\n-                } else if (c <= COMMENT) {\n+                } else if (c <= SP) {\n+\n                     // Some other chars at the start of a value caused the parser to fail, so for now\n                     // encapsulate if we start in anything less than '#'. We are being conservative\n                     // by including the default comment char too."}
{"project": "Gson", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "11", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "      case STRING:", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\nindex 6a51c64e..31beb5d6 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/TypeAdapters.java\n@@ -368,6 +368,7 @@ public final class TypeAdapters {\n         in.nextNull();\n         return null;\n       case NUMBER:\n+      case STRING:\n         return new LazilyParsedNumber(in.nextString());\n       default:\n         throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);"}
{"project": "Gson", "bug_id": "12", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n  @Override public void skipValue() throws IOException {\n    if (peek() == JsonToken.NAME) {\n      nextName();\n      if (stackSize > 0) {\n        pathNames[stackSize - 2] = \"null\";\n      }\n    } else {\n      popStack();\n      if (stackSize > 0) {\n        pathNames[stackSize - 1] = \"null\";\n      }\n    }\n    if (stackSize > 0) {\n      pathIndices[stackSize - 1]++;\n    }\n  }\n", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\nindex 2e7644f0..cea7032a 100644\n--- a/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n+++ b/gson/src/main/java/com/google/gson/internal/bind/JsonTreeReader.java\n@@ -253,17 +253,25 @@ public final class JsonTreeReader extends JsonReader {\n     stackSize = 1;\n   }\n \n+\n   @Override public void skipValue() throws IOException {\n     if (peek() == JsonToken.NAME) {\n       nextName();\n-      pathNames[stackSize - 2] = \"null\";\n+      if (stackSize > 0) {\n+        pathNames[stackSize - 2] = \"null\";\n+      }\n     } else {\n       popStack();\n+      if (stackSize > 0) {\n         pathNames[stackSize - 1] = \"null\";\n+      }\n     }\n+    if (stackSize > 0) {\n       pathIndices[stackSize - 1]++;\n+    }\n   }\n \n+\n   @Override public String toString() {\n     return getClass().getSimpleName();\n   }"}
{"project": "Gson", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "16", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n  private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                              Collection<TypeVariable> visitedTypeVariables) {\n    // this implementation is made a little more complicated in an attempt to avoid object-creation\n    while (true) {\n      if (toResolve instanceof TypeVariable) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n        // cannot reduce due to infinite recursion\n        if (visitedTypeVariables.contains(typeVariable)) {\n          return typeVariable;\n        }\n        visitedTypeVariables.add(typeVariable);\n        toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n        if (toResolve == typeVariable) {\n          return toResolve;\n        }\n\n      } else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\n        Class<?> original = (Class<?>) toResolve;\n        Type componentType = original.getComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof GenericArrayType) {\n        GenericArrayType original = (GenericArrayType) toResolve;\n        Type componentType = original.getGenericComponentType();\n        Type newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\n        return componentType == newComponentType\n            ? original\n            : arrayOf(newComponentType);\n\n      } else if (toResolve instanceof ParameterizedType) {\n        ParameterizedType original = (ParameterizedType) toResolve;\n        Type ownerType = original.getOwnerType();\n        Type newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\n        boolean changed = newOwnerType != ownerType;\n\n        Type[] args = original.getActualTypeArguments();\n        for (int t = 0, length = args.length; t < length; t++) {\n          Type resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\n          if (resolvedTypeArgument != args[t]) {\n            if (!changed) {\n              args = args.clone();\n              changed = true;\n            }\n            args[t] = resolvedTypeArgument;\n          }\n        }\n\n        return changed\n            ? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n            : original;\n\n      } else if (toResolve instanceof WildcardType) {\n        WildcardType original = (WildcardType) toResolve;\n        Type[] originalLowerBound = original.getLowerBounds();\n        Type[] originalUpperBound = original.getUpperBounds();\n\n        if (originalLowerBound.length == 1) {\n          Type lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\n          if (lowerBound != originalLowerBound[0]) {\n            return supertypeOf(lowerBound);\n          }\n        } else if (originalUpperBound.length == 1) {\n          Type upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\n          if (upperBound != originalUpperBound[0]) {\n            return subtypeOf(upperBound);\n          }\n        }\n        return original;\n\n      } else {\n        return toResolve;\n      }\n    }\n  }\n", "diff": "diff --git a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\nindex 17ed0ff2..6061acd2 100644\n--- a/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n+++ b/gson/src/main/java/com/google/gson/internal/$Gson$Types.java\n@@ -333,13 +333,18 @@ public final class $Gson$Types {\n     return resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n   }\n \n+\n   private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\n                               Collection<TypeVariable> visitedTypeVariables) {\n     // this implementation is made a little more complicated in an attempt to avoid object-creation\n     while (true) {\n       if (toResolve instanceof TypeVariable) {\n         TypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\n-          // cannot reduce due to infinite recursion\n+        // cannot reduce due to infinite recursion\n+        if (visitedTypeVariables.contains(typeVariable)) {\n+          return typeVariable;\n+        }\n+        visitedTypeVariables.add(typeVariable);\n         toResolve = resolveTypeVariable(context, contextRawType, typeVariable);\n         if (toResolve == typeVariable) {\n           return toResolve;\n@@ -407,6 +412,7 @@ public final class $Gson$Types {\n     }\n   }\n \n+\n   static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\n     Class<?> declaredByRaw = declaringClassOf(unknown);\n "}
{"project": "Gson", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Gson", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "4", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\n    public char[] expandCurrentSegment()\n    {\n        final char[] curr = _currentSegment;\n        // Let's grow by 50% by default\n        final int len = curr.length;\n        // but above MAX_SEGMENT_LEN, slow to increase by 25%\n        // Changed from (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)) \n        // to (len == MAX_SEGMENT_LEN) ? MAX_SEGMENT_LEN*2 : Math.min(MAX_SEGMENT_LEN, len + (len >> 1))\n        int newLen = (len == MAX_SEGMENT_LEN) ? MAX_SEGMENT_LEN*2 : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n        return (_currentSegment = Arrays.copyOf(curr, newLen));\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex f97a083f..22ea38b0 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -577,16 +577,20 @@ public final class TextBuffer\n      * accommodate for more contiguous content. Usually only\n      * used when parsing tokens like names if even then.\n      */\n+\n     public char[] expandCurrentSegment()\n     {\n         final char[] curr = _currentSegment;\n         // Let's grow by 50% by default\n         final int len = curr.length;\n-        // but above intended maximum, slow to increase by 25%\n-        int newLen = (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n+        // but above MAX_SEGMENT_LEN, slow to increase by 25%\n+        // Changed from (len == MAX_SEGMENT_LEN) ? (MAX_SEGMENT_LEN+1) : Math.min(MAX_SEGMENT_LEN, len + (len >> 1)) \n+        // to (len == MAX_SEGMENT_LEN) ? MAX_SEGMENT_LEN*2 : Math.min(MAX_SEGMENT_LEN, len + (len >> 1))\n+        int newLen = (len == MAX_SEGMENT_LEN) ? MAX_SEGMENT_LEN*2 : Math.min(MAX_SEGMENT_LEN, len + (len >> 1));\n         return (_currentSegment = Arrays.copyOf(curr, newLen));\n     }\n \n+\n     /**\n      * Method called to expand size of the current segment, to\n      * accommodate for more contiguous content. Usually only"}
{"project": "JacksonCore", "bug_id": "5", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            char c = str.charAt(i);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\nindex d353b392..a8022391 100644\n--- a/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/JsonPointer.java\n@@ -190,7 +190,7 @@ public class JsonPointer\n             return -1;\n         }\n         for (int i = 0; i < len; ++i) {\n-            char c = str.charAt(i++);\n+            char c = str.charAt(i);\n             if (c > '9' || c < '0') {\n                 return -1;\n             }"}
{"project": "JacksonCore", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "8", "eval": "PASS", "attempt": 7, "mode": "SL", "patch": "        if (!_hasSegments)  return _currentSegment == null ? new char[0] : _currentSegment;", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\nindex e6f1cbc5..5306c847 100644\n--- a/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n+++ b/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java\n@@ -295,6 +295,7 @@ public final class TextBuffer\n         return true;\n     }\n     \n+\n     public char[] getTextBuffer()\n     {\n         // Are we just using shared input buffer?\n@@ -304,7 +305,7 @@ public final class TextBuffer\n             return (_resultArray = _resultString.toCharArray());\n         }\n         // Nope; but does it fit in just one segment?\n-        if (!_hasSegments)  return _currentSegment;\n+        if (!_hasSegments)  return _currentSegment == null ? new char[0] : _currentSegment;\n         // Nope, need to have/create a non-segmented array and return it\n         return contentsAsArray();\n     }"}
{"project": "JacksonCore", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonCore", "bug_id": "25", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            if (i < maxCode) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\nindex 2c1f5a23..f38e4aae 100644\n--- a/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n+++ b/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java\n@@ -1960,7 +1960,7 @@ public class ReaderBasedJsonParser // final in 2.3, earlier\n             }\n             char c = _inputBuffer[_inputPtr];\n             int i = (int) c;\n-            if (i <= maxCode) {\n+            if (i < maxCode) {\n                 if (codes[i] != 0) {\n                     break;\n                 }"}
{"project": "JacksonCore", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "5", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n            Class<?> mixInCls, AnnotatedMethodMap mixIns)\n    {\n        List<Class<?>> parents = new ArrayList<Class<?>>();\n        parents.add(mixInCls);\n        ClassUtil.findSuperTypes(mixInCls, targetClass, parents);\n        for (Class<?> mixin : parents) {\n            for (Method m : mixin.getDeclaredMethods()) {\n                if (!_isIncludableMemberMethod(m)) {\n                    continue;\n                }\n                AnnotatedMethod am = methods.find(m);\n                /* Do we already have a method to augment (from sub-class\n                 * that will mask this mixIn)? If so, add if visible\n                 * without masking (no such annotation)\n                 */\n                if (am != null) {\n                    _addMixUnders(m, am);\n                    /* Otherwise will have precedence, but must wait\n                     * until we find the real method (mixIn methods are\n                     * just placeholder, can't be called)\n                     */\n                } else {\n                    // Well, or, as per [Issue#515], multi-level merge within mixins...\n                    if (mixIns.find(m) == null) {\n                        mixIns.add(_constructMethod(m));\n                    }\n                }\n            }\n        }\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\nindex d6e44ab58..fec9ef496 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotatedClass.java\n@@ -631,6 +631,7 @@ public final class AnnotatedClass\n         }\n     }\n \n+\n     protected void _addMethodMixIns(Class<?> targetClass, AnnotatedMethodMap methods,\n             Class<?> mixInCls, AnnotatedMethodMap mixIns)\n     {\n@@ -655,12 +656,15 @@ public final class AnnotatedClass\n                      */\n                 } else {\n                     // Well, or, as per [Issue#515], multi-level merge within mixins...\n+                    if (mixIns.find(m) == null) {\n                         mixIns.add(_constructMethod(m));\n+                    }\n                 }\n             }\n         }\n     }\n \n+\n     /*\n     /**********************************************************\n     /* Helper methods for populating field information"}
{"project": "JacksonDatabind", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "8", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n    {\n        final int mask = (1 << typeIndex);\n        _hasNonDefaultCreator = true;\n        AnnotatedWithParams oldOne = _creators[typeIndex];\n        // already had an explicitly marked one?\n        if (oldOne != null) {\n\n            if ((_explicitCreators & mask) != 0) { // already had explicitly annotated, leave as-is\n                // but skip, if new one not annotated\n                if (!explicit) {\n                    return;\n                }\n            }\n\n            // one more thing: ok to override in sub-class\n            if (oldOne.getClass() == newOne.getClass()) {\n                // [databind#667]: avoid one particular class of bogus problems\n              \n                // both explicit: verify\n                // otherwise only verify if neither explicitly annotated.\n                if ((_explicitCreators & mask) != 0) {\n                    throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                            +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n                }\n            }\n        }\n        if (explicit) {\n            _explicitCreators |= mask;\n        }\n        _creators[typeIndex] = _fixAccess(newOne);\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\nindex 39514f63f..233bda9a9 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/CreatorCollector.java\n@@ -273,6 +273,7 @@ public class CreatorCollector\n         return member;\n     }\n \n+\n     protected void verifyNonDup(AnnotatedWithParams newOne, int typeIndex, boolean explicit)\n     {\n         final int mask = (1 << typeIndex);\n@@ -286,19 +287,18 @@ public class CreatorCollector\n                 if (!explicit) {\n                     return;\n                 }\n-                // both explicit: verify\n-                // otherwise only verify if neither explicitly annotated.\n             }\n \n             // one more thing: ok to override in sub-class\n             if (oldOne.getClass() == newOne.getClass()) {\n                 // [databind#667]: avoid one particular class of bogus problems\n-\n+              \n+                // both explicit: verify\n+                // otherwise only verify if neither explicitly annotated.\n+                if ((_explicitCreators & mask) != 0) {\n                     throw new IllegalArgumentException(\"Conflicting \"+TYPE_DESCS[typeIndex]\n                             +\" creators: already had explicitly marked \"+oldOne+\", encountered \"+newOne);\n-                // otherwise, which one to choose?\n-                    // new type more generic, use old\n-                // new type more specific, use it\n+                }\n             }\n         }\n         if (explicit) {\n@@ -307,6 +307,7 @@ public class CreatorCollector\n         _creators[typeIndex] = _fixAccess(newOne);\n     }\n \n+\n     /*\n     /**********************************************************\n     /* Helper class(es)"}
{"project": "JacksonDatabind", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "27", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                    if (ext.handlePropertyValue(p, ctxt, propName, null)) {", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\nindex fc7961de5..d5f20793b 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java\n@@ -791,7 +791,7 @@ public class BeanDeserializer\n                 // first: let's check to see if this might be part of value with external type id:\n                 // 11-Sep-2015, tatu: Important; do NOT pass buffer as last arg, but null,\n                 //   since it is not the bean\n-                if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n+                    if (ext.handlePropertyValue(p, ctxt, propName, null)) {\n                     ;\n                 } else {\n                     // Last creator property to set?"}
{"project": "JacksonDatabind", "bug_id": "28", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n        public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n                p.nextToken();\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n            //    if caller has advanced to the first token of Object, but for empty Object\n            if (p.getCurrentToken() == JsonToken.END_OBJECT) {\n                return ctxt.getNodeFactory().objectNode();\n            }\n            if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ObjectNode.class);\n         }\n    }\n        \n    final static class ArrayDeserializer\n        extends BaseNodeDeserializer<ArrayNode>\n    {\n        private static final long serialVersionUID = 1L;\n\n        protected final static ArrayDeserializer _instance = new ArrayDeserializer();\n\n        protected ArrayDeserializer() { super(ArrayNode.class); }\n\n        public static ArrayDeserializer getInstance() { return _instance; }\n        \n        @Override\n        public ArrayNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n        {\n            if (p.isExpectedStartArrayToken()) {\n                return deserializeArray(p, ctxt, ctxt.getNodeFactory());\n            }\n            throw ctxt.mappingException(ArrayNode.class);\n        }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\nindex 264ed2051..ff8767e9c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/JsonNodeDeserializer.java\n@@ -92,6 +92,7 @@ public class JsonNodeDeserializer\n         public static ObjectDeserializer getInstance() { return _instance; }\n         \n         @Override\n+\n         public ObjectNode deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n         {\n             if (p.getCurrentToken() == JsonToken.START_OBJECT) {\n@@ -100,6 +101,9 @@ public class JsonNodeDeserializer\n             }\n             // 23-Sep-2015, tatu: Ugh. We may also be given END_OBJECT (similar to FIELD_NAME),\n             //    if caller has advanced to the first token of Object, but for empty Object\n+            if (p.getCurrentToken() == JsonToken.END_OBJECT) {\n+                return ctxt.getNodeFactory().objectNode();\n+            }\n             if (p.getCurrentToken() == JsonToken.FIELD_NAME) {\n                 return deserializeObject(p, ctxt, ctxt.getNodeFactory());\n             }\n@@ -126,6 +130,7 @@ public class JsonNodeDeserializer\n             }\n             throw ctxt.mappingException(ArrayNode.class);\n         }\n+\n     }\n }\n "}
{"project": "JacksonDatabind", "bug_id": "34", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\nindex 5624624af..eee90649f 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java\n@@ -78,11 +78,11 @@ public class NumberSerializer\n         } else {\n             Class<?> h = handledType();\n             if (h == BigDecimal.class) {\n-                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n+                visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n             } else {\n                 // otherwise bit unclear what to call... but let's try:\n                 /*JsonNumberFormatVisitor v2 =*/ visitor.expectNumberFormat(typeHint);\n             }\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "JacksonDatabind", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "42", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n             if (_kind == STD_LOCALE) {\n                return Locale.ROOT;\n             }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex cdbd5e8ac..25f595ba9 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -281,6 +281,11 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 return URI.create(\"\");\n             }\n             // As per [databind#1123], Locale too\n+\n+             if (_kind == STD_LOCALE) {\n+                return Locale.ROOT;\n+             }\n+\n             return super._deserializeFromEmptyString();\n         }\n     }"}
{"project": "JacksonDatabind", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "46", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "47", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "49", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public Object generateId(Object forPojo) {\n        if (this.id != null) {\n            return this.id;\n        }\n        this.id = generator.generateId(forPojo);\n        return this.id;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\nindex af141e12a..48c8378b5 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ser/impl/WritableObjectId.java\n@@ -43,14 +43,17 @@ public final class WritableObjectId\n         return false;\n     }\n     \n+\n+\n     public Object generateId(Object forPojo) {\n-        // 04-Jun-2016, tatu: As per [databind#1255], need to consider possibility of\n-        //    id being generated for \"alwaysAsId\", but not being written as POJO; regardless,\n-        //    need to use existing id if there is one:\n-            id = generator.generateId(forPojo);\n-        return id;\n+        if (this.id != null) {\n+            return this.id;\n+        }\n+        this.id = generator.generateId(forPojo);\n+        return this.id;\n     }\n \n+\n     /**\n      * Method called to output Object Id as specified.\n      */"}
{"project": "JacksonDatabind", "bug_id": "51", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n    protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n            String typeId) throws IOException\n    {\n        JsonDeserializer<Object> deser = _deserializers.get(typeId);\n        if (deser == null) {\n            /* As per [Databind#305], need to provide contextual info. But for\n             * backwards compatibility, let's start by only supporting this\n             * for base class, not via interface. Later on we can add this\n             * to the interface, assuming deprecation at base class helps.\n             */\n            JavaType type = _idResolver.typeFromId(ctxt, typeId);\n            if (type == null) {\n                // As per [JACKSON-614], use the default impl if no type id available:\n                deser = _findDefaultImplDeserializer(ctxt);\n                if (deser == null) {\n                    // 10-May-2016, tatu: We may get some help...\n                    JavaType actual = _handleUnknownTypeId(ctxt, typeId, _idResolver, _baseType);\n                    if (actual == null) { // what should this be taken to mean?\n                        // TODO: try to figure out something better\n                        return null;\n                    }\n                    // ... would this actually work?\n                    deser = ctxt.findContextualValueDeserializer(actual, _property);\n                }\n            } else {\n                /* 16-Dec-2010, tatu: Since nominal type we get here has no (generic) type parameters,\n                 *   we actually now need to explicitly narrow from base type (which may have parameterization)\n                 *   using raw type.\n                 *\n                 *   One complication, though; can not change 'type class' (simple type to container); otherwise\n                 *   we may try to narrow a SimpleType (Object.class) into MapType (Map.class), losing actual\n                 *   type in process (getting SimpleType of Map.class which will not work as expected)\n                 */\n                if ((_baseType != null)\n                        && _baseType.getClass() == type.getClass()\n                        && _baseType.getRawClass() != type.getRawClass()) {\n                    /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                     *   but it appears to check that JavaType impl class is the same which is\n                     *   important for some reason?\n                     *   Disabling the check will break 2 Enum-related tests.\n                     */\n                    // 19-Jun-2016, tatu: As per [databind#1270] we may actually get full\n                    //   generic type with custom type resolvers. If so, should try to retain them.\n                    //  Whether this is sufficient to avoid problems remains to be seen, but for\n                    //  now it should improve things.\n                        type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass());\n                }\n                deser = ctxt.findContextualValueDeserializer(type, _property);\n            }\n            _deserializers.put(typeId, deser);\n        }\n        return deser;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\nindex 23380f082..ca7f6c7df 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java\n@@ -137,6 +137,7 @@ public abstract class TypeDeserializerBase\n     /**********************************************************\n      */\n \n+\n     protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n             String typeId) throws IOException\n     {\n@@ -171,7 +172,8 @@ public abstract class TypeDeserializerBase\n                  *   type in process (getting SimpleType of Map.class which will not work as expected)\n                  */\n                 if ((_baseType != null)\n-                        && _baseType.getClass() == type.getClass()) {\n+                        && _baseType.getClass() == type.getClass()\n+                        && _baseType.getRawClass() != type.getRawClass()) {\n                     /* 09-Aug-2015, tatu: Not sure if the second part of the check makes sense;\n                      *   but it appears to check that JavaType impl class is the same which is\n                      *   important for some reason?\n@@ -190,6 +192,7 @@ public abstract class TypeDeserializerBase\n         return deser;\n     }\n \n+\n     protected final JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt) throws IOException\n     {\n         /* 06-Feb-2013, tatu: As per [databind#148], consider default implementation value of"}
{"project": "JacksonDatabind", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "57", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), ", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\nindex 10fddc4d6..132cd4e6c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java\n@@ -1438,7 +1438,7 @@ public class ObjectReader\n         if (_dataFormatReaders != null) {\n             return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n         }\n-        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n+        return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src, offset, length), \n                 true));\n     }\n "}
{"project": "JacksonDatabind", "bug_id": "58", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n            BeanDescription beanDesc, BeanPropertyDefinition propDef,\n            JavaType propType0)\n        throws JsonMappingException\n    {\n        // need to ensure method is callable (for non-public)\n        AnnotatedMember mutator = propDef.getNonConstructorMutator();\n\n        if (ctxt.canOverrideAccessModifiers()) {\n            // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n            // never needed and attempts may cause problems on some platforms.\n            // !!! NOTE: should be handled better for 2.8 and later\n            if (!(mutator instanceof AnnotatedField && \"cause\".equals(mutator.getName()))) {\n                mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n            }\n        }\n        // note: this works since we know there's exactly one argument for methods\n        BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n                propType0, propDef.getWrapperName(),\n                beanDesc.getClassAnnotations(), mutator, propDef.getMetadata());\n        JavaType type = resolveType(ctxt, beanDesc, propType0, mutator);\n        // did type change?\n        if (type != propType0) {\n            property = property.withType(type);\n        }\n\n        // First: does the Method specify the deserializer to use? If so, let's use it.\n        JsonDeserializer<Object> propDeser = findDeserializerFromAnnotation(ctxt, mutator);\n        type = modifyTypeByAnnotation(ctxt, mutator, type);\n        TypeDeserializer typeDeser = type.getTypeHandler();\n        SettableBeanProperty prop;\n        if (mutator instanceof AnnotatedMethod) {\n            prop = new MethodProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedMethod) mutator);\n        } else {\n            prop = new FieldProperty(propDef, type, typeDeser,\n                    beanDesc.getClassAnnotations(), (AnnotatedField) mutator);\n        }\n        if (propDeser != null) {\n            prop = prop.withValueDeserializer(propDeser);\n        }\n        // need to retain name of managed forward references:\n        AnnotationIntrospector.ReferenceProperty ref = propDef.findReferenceType();\n        if (ref != null && ref.isManagedReference()) {\n            prop.setManagedReferenceName(ref.getName());\n        }\n        ObjectIdInfo objectIdInfo = propDef.findObjectIdInfo();\n        if(objectIdInfo != null){\n            prop.setObjectIdInfo(objectIdInfo);\n        }\n        return prop;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\nindex df861215c..a6b6ae362 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java\n@@ -700,6 +700,7 @@ public class BeanDeserializerFactory\n      * @return Property constructed, if any; or null to indicate that\n      *   there should be no property based on given definitions.\n      */\n+\n     protected SettableBeanProperty constructSettableProperty(DeserializationContext ctxt,\n             BeanDescription beanDesc, BeanPropertyDefinition propDef,\n             JavaType propType0)\n@@ -712,7 +713,9 @@ public class BeanDeserializerFactory\n             // [databind#877]: explicitly prevent forced access to `cause` of `Throwable`;\n             // never needed and attempts may cause problems on some platforms.\n             // !!! NOTE: should be handled better for 2.8 and later\n+            if (!(mutator instanceof AnnotatedField && \"cause\".equals(mutator.getName()))) {\n                 mutator.fixAccess(ctxt.isEnabled(MapperFeature.OVERRIDE_PUBLIC_ACCESS_MODIFIERS));\n+            }\n         }\n         // note: this works since we know there's exactly one argument for methods\n         BeanProperty.Std property = new BeanProperty.Std(propDef.getFullName(),\n@@ -751,6 +754,7 @@ public class BeanDeserializerFactory\n         return prop;\n     }\n \n+\n     /**\n      * Method that will construct a regular bean property setter using\n      * the given setter method."}
{"project": "JacksonDatabind", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "63", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "67", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n            JavaType type)\n        throws JsonMappingException\n    {\n        final DeserializationConfig config = ctxt.getConfig();\n        KeyDeserializer deser = null;\n        if (_factoryConfig.hasKeyDeserializers()) {\n            BeanDescription beanDesc = config.introspectClassAnnotations(type.getRawClass());\n            for (KeyDeserializers d  : _factoryConfig.keyDeserializers()) {\n                deser = d.findKeyDeserializer(type, config, beanDesc);\n                if (deser != null) {\n                    break;\n                }\n            }\n        }\n        if (deser == null) {\n            if (type.isEnumType()) {\n                deser = _createEnumKeyDeserializer(ctxt, type);\n            } else {\n                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n            }\n        }\n        if (deser != null) {\n            if (_factoryConfig.hasDeserializerModifiers()) {\n                for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n                    deser = mod.modifyKeyDeserializer(config, type, deser);\n                }\n            }\n        }\n        return deser;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 7d6a7bf5e..c7fdcb394 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -1382,6 +1382,7 @@ public abstract class BasicDeserializerFactory\n      */\n     \n     @Override\n+\n     public KeyDeserializer createKeyDeserializer(DeserializationContext ctxt,\n             JavaType type)\n         throws JsonMappingException\n@@ -1397,14 +1398,13 @@ public abstract class BasicDeserializerFactory\n                 }\n             }\n         }\n-        // the only non-standard thing is this:\n         if (deser == null) {\n             if (type.isEnumType()) {\n-                return _createEnumKeyDeserializer(ctxt, type);\n+                deser = _createEnumKeyDeserializer(ctxt, type);\n+            } else {\n+                deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n             }\n-            deser = StdKeyDeserializers.findStringBasedKeyDeserializer(config, type);\n         }\n-        // and then post-processing\n         if (deser != null) {\n             if (_factoryConfig.hasDeserializerModifiers()) {\n                 for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) {\n@@ -1415,6 +1415,7 @@ public abstract class BasicDeserializerFactory\n         return deser;\n     }\n \n+\n     private KeyDeserializer _createEnumKeyDeserializer(DeserializationContext ctxt,\n             JavaType type)\n         throws JsonMappingException"}
{"project": "JacksonDatabind", "bug_id": "70", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                found = key.equals(getPropertyName(prop));", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\nindex dc791897b..fabbeaccb 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java\n@@ -437,7 +437,7 @@ System.err.println(\"And new propr #\"+slot+\" '\"+key+\"'\");\n             if (!found) {\n                 // 09-Jan-2017, tatu: Important: must check name slot and NOT property name,\n                 //   as only former is lower-case in case-insensitive case\n-                found = key.equals(prop.getName());\n+                found = key.equals(getPropertyName(prop));\n                 if (found) {\n                     // need to leave a hole here\n                     _propsInOrder[_findFromOrdered(prop)] = null;"}
{"project": "JacksonDatabind", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "76", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n                if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n                    continue;\n                }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\nindex 1629a42be..219ab99d9 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java\n@@ -580,27 +580,11 @@ public class BuilderBasedDeserializer\n             // creator property?\n             SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n             if (creatorProp != null) {\n+\n                 if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) {\n-                    t = p.nextToken();\n-                    Object bean;\n-                    try {\n-                        bean = creator.build(ctxt, buffer);\n-                    } catch (Exception e) {\n-                        wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt);\n-                        continue;\n-                    }\n-                    while (t == JsonToken.FIELD_NAME) {\n-                        p.nextToken();\n-                        tokens.copyCurrentStructure(p);\n-                        t = p.nextToken();\n-                    }\n-                    tokens.writeEndObject();\n-                    if (bean.getClass() != _beanType.getRawClass()) {\n-                        ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\");\n-                        return null;\n-                    }\n-                    return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens);\n+                    continue;\n                 }\n+\n                 continue;\n             }\n             // Object Id property?"}
{"project": "JacksonDatabind", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "83", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n    public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n    {\n        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n        String text = p.getValueAsString();\n        if (text != null) { // has String representation\n            if (text.length() == 0 || (text = text.trim()).length() == 0) {\n                // 04-Feb-2013, tatu: Usually should become null; but not always\n                return _deserializeFromEmptyString();\n            }\n            Exception cause = null;\n            try {\n                // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                //    indicated error; but that seems wrong. Should be able to return\n                //    `null` as value.\n                return _deserialize(text, ctxt);\n            } catch (IllegalArgumentException iae) {\n                cause = iae;\n            } catch (MalformedURLException me) {\n                cause = me;\n            }\n            String msg = \"not a valid textual representation\";\n            if (cause != null) {\n                String m2 = cause.getMessage();\n                if (m2 != null) {\n                    msg = msg + \", problem: \"+m2;\n                }\n            }\n            // 05-May-2016, tatu: Unlike most usage, this seems legit, so...\n            JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);\n            if (cause != null) {\n                e.initCause(cause);\n            }\n            throw e;\n            // nothing to do here, yet? We'll fail anyway\n        }\n        JsonToken t = p.getCurrentToken();\n        // [databind#381]\n        if (t == JsonToken.START_ARRAY) {\n            return _deserializeFromArray(p, ctxt);\n        }\n        if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {\n            // Trivial cases; null to null, instance of type itself returned as is\n            Object ob = p.getEmbeddedObject();\n            if (ob == null) {\n                return null;\n            }\n            if (_valueClass.isAssignableFrom(ob.getClass())) {\n                return (T) ob;\n            }\n            return _deserializeEmbedded(ob, ctxt);\n        }\n        return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\nindex 4f4eb672a..96eb139b4 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/std/FromStringDeserializer.java\n@@ -102,6 +102,7 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n     \n     @SuppressWarnings(\"unchecked\")\n     @Override\n+\n     public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException\n     {\n         // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:\n@@ -116,9 +117,7 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`\n                 //    indicated error; but that seems wrong. Should be able to return\n                 //    `null` as value.\n-                if (_deserialize(text, ctxt) != null) {\n                 return _deserialize(text, ctxt);\n-                }\n             } catch (IllegalArgumentException iae) {\n                 cause = iae;\n             } catch (MalformedURLException me) {\n@@ -157,6 +156,7 @@ public abstract class FromStringDeserializer<T> extends StdScalarDeserializer<T>\n         }\n         return (T) ctxt.handleUnexpectedToken(_valueClass, p);\n     }\n+\n         \n     protected abstract T _deserialize(String value, DeserializationContext ctxt) throws IOException;\n "}
{"project": "JacksonDatabind", "bug_id": "85", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "88", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "89", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "91", "eval": "PASS", "attempt": 4, "mode": "SF", "patch": "\n    private boolean _hasCustomHandlers(JavaType t) {\n        if (t.isContainerType()) {\n            // First: value types may have both value and type handlers\n            JavaType ct = t.getContentType();\n            if (ct != null) {\n                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n                    return true;\n                }\n            // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n            if (t.hasHandlers()) { \n                return true;\n            }\n            }\n        }\n        return false;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\nindex aae7e87f5..25fd026f6 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/DeserializerCache.java\n@@ -533,18 +533,25 @@ public final class DeserializerCache\n      *\n      * @since 2.8.11\n      */\n+\n     private boolean _hasCustomHandlers(JavaType t) {\n         if (t.isContainerType()) {\n             // First: value types may have both value and type handlers\n             JavaType ct = t.getContentType();\n             if (ct != null) {\n-                return (ct.getValueHandler() != null) || (ct.getTypeHandler() != null);\n+                if ((ct.getValueHandler() != null) || (ct.getTypeHandler() != null)) {\n+                    return true;\n+                }\n             // Second: map(-like) types may have value handler for key (but not type; keys are untyped)\n+            if (t.hasHandlers()) { \n+                return true;\n+            }\n             }\n         }\n         return false;\n     }\n \n+\n     private Class<?> _verifyAsClass(Object src, String methodName, Class<?> noneClass)\n     {\n         if (src == null) {"}
{"project": "JacksonDatabind", "bug_id": "92", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "96", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "            paramName = (paramDef != null) ? new PropertyName(paramDef.getName()) : null;", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\nindex 7057c5427..ed00e8dbd 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java\n@@ -732,7 +732,7 @@ nonAnnotatedParamIndex, ctor);\n             // 25-May-2018, tatu: as per [databind#2051], looks like we have to get\n             //    not implicit name, but name with possible strategy-based-rename\n //            paramName = candidate.findImplicitParamName(0);\n-            paramName = candidate.findImplicitParamName(0);\n+            paramName = (paramDef != null) ? new PropertyName(paramDef.getName()) : null;\n             useProps = (paramName != null) && paramDef.couldSerialize();\n         }\n         if (useProps) {"}
{"project": "JacksonDatabind", "bug_id": "97", "eval": "PASS", "attempt": 10, "mode": "SL", "patch": "            ctxt.defaultSerializeValue(_value, gen);", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\nindex 91fe5120a..06c315cfb 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java\n@@ -111,7 +111,7 @@ public class POJONode\n         } else {\n             // 25-May-2018, tatu: [databind#1991] do not call via generator but through context;\n             //    this to preserve contextual information\n-            gen.writeObject(_value);\n+            ctxt.defaultSerializeValue(_value, gen);\n         }\n     }\n "}
{"project": "JacksonDatabind", "bug_id": "99", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        sb.append('>');", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\nindex 4add34ee0..e8c69628c 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java\n@@ -166,6 +166,7 @@ public class ReferenceType extends SimpleType\n         sb.append(_class.getName());\n         sb.append('<');\n         sb.append(_referencedType.toCanonical());\n+        sb.append('>');\n         return sb.toString();\n     }\n "}
{"project": "JacksonDatabind", "bug_id": "100", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public byte[] getBinaryValue(Base64Variant b64variant)\n        throws IOException, JsonParseException\n    {\n        // Multiple possibilities...\n        JsonNode n = currentNode();\n        if (n != null) {\n            // [databind#2096]: although `binaryValue()` works for real binary node\n            // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n\n            if (n.isBinary()) {\n                return n.binaryValue();\n            }\n\n            if (n.isPojo()) {\n                Object ob = ((POJONode) n).getPojo();\n                if (ob instanceof byte[]) {\n                    return (byte[]) ob;\n                }\n            }\n\n            if (n.isTextual()) {\n                String text = n.textValue();\n                // If the string is a valid base64 string, then decode it, else return null\n                try {\n                    return b64variant.decode(text);\n                } catch (IllegalArgumentException e) {\n                    return null;\n                }\n            }\n        }\n        // otherwise return null to mark we have no binary content\n        return null;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\nindex 9d2f74b35..046edd2ec 100644\n--- a/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n+++ b/src/main/java/com/fasterxml/jackson/databind/node/TreeTraversingParser.java\n@@ -352,6 +352,7 @@ public class TreeTraversingParser extends ParserMinimalBase\n      */\n \n     @Override\n+\n     public byte[] getBinaryValue(Base64Variant b64variant)\n         throws IOException, JsonParseException\n     {\n@@ -360,22 +361,34 @@ public class TreeTraversingParser extends ParserMinimalBase\n         if (n != null) {\n             // [databind#2096]: although `binaryValue()` works for real binary node\n             // and embedded \"POJO\" node, coercion from TextNode may require variant, so:\n-            byte[] data = n.binaryValue();\n-            if (data != null) {\n-                return data;\n+\n+            if (n.isBinary()) {\n+                return n.binaryValue();\n             }\n+\n             if (n.isPojo()) {\n                 Object ob = ((POJONode) n).getPojo();\n                 if (ob instanceof byte[]) {\n                     return (byte[]) ob;\n                 }\n             }\n+\n+            if (n.isTextual()) {\n+                String text = n.textValue();\n+                // If the string is a valid base64 string, then decode it, else return null\n+                try {\n+                    return b64variant.decode(text);\n+                } catch (IllegalArgumentException e) {\n+                    return null;\n+                }\n+            }\n         }\n         // otherwise return null to mark we have no binary content\n         return null;\n     }\n \n \n+\n     @Override\n     public int readBinaryValue(Base64Variant b64variant, OutputStream out)\n             throws IOException, JsonParseException"}
{"project": "JacksonDatabind", "bug_id": "101", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "107", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JacksonDatabind", "bug_id": "112", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "3", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\n    public String nextTextValue() throws IOException\n    {\n        _binaryValue = null;\n        if (_nextToken != null) {\n            JsonToken t = _nextToken;\n            _currToken = t;\n            _nextToken = null;\n\n            // expected case; yes, got a String\n            if (t == JsonToken.VALUE_STRING) {\n                return _currText;\n            }\n            _updateState(t);\n            return null;\n        }\n\n        int token = _xmlTokens.next();\n\n        // mostly copied from 'nextToken()'\n        while (token == XmlTokenStream.XML_START_ELEMENT) {\n            if (_mayBeLeaf) {\n                _nextToken = JsonToken.FIELD_NAME;\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return null;\n            }\n            if (_parsingContext.inArray()) {\n                token = _xmlTokens.next();\n                _mayBeLeaf = true;\n                continue;\n            }\n            String name = _xmlTokens.getLocalName();\n            _parsingContext.setCurrentName(name);\n            if (_namesToWrap != null && _namesToWrap.contains(name)) {\n                _xmlTokens.repeatStartElement();\n            }\n            _mayBeLeaf = true;\n            _currToken = JsonToken.FIELD_NAME;\n            return null;\n        }\n\n        // Ok; beyond start element, what do we get?\n        switch (token) {\n        case XmlTokenStream.XML_END_ELEMENT:\n            if (_mayBeLeaf) {\n                // NOTE: this is different from nextToken() -- produce \"\", NOT null\n                _mayBeLeaf = false;\n                _currToken = JsonToken.VALUE_STRING;\n                return (_currText = \"\");\n            }\n            _currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n            _parsingContext = _parsingContext.getParent();\n            _namesToWrap = _parsingContext.getNamesToWrap();\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_NAME:\n            // If there was a chance of leaf node, no more...\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                _nextToken = JsonToken.FIELD_NAME;\n                _currText = _xmlTokens.getText();\n                _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                _currToken = JsonToken.START_OBJECT;\n                return _currText;\n            } else {\n                _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                _currToken = JsonToken.FIELD_NAME;\n            }\n            break;\n        case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n            _currText = _xmlTokens.getText();\n            _currToken = JsonToken.VALUE_STRING;\n            return _currText;\n        case XmlTokenStream.XML_TEXT:\n            _currText = _xmlTokens.getText();\n            if (_mayBeLeaf) {\n                _mayBeLeaf = false;\n                // Also: must skip following END_ELEMENT\n                _xmlTokens.skipEndElement();\n\n                // NOTE: this is different from nextToken() -- NO work-around\n                // for otherwise empty List/array\n                _currToken = JsonToken.VALUE_STRING;\n                return _currText;\n            }\n            // If not a leaf, need to transform into property...\n            _parsingContext.setCurrentName(_cfgNameForTextElement);\n            _nextToken = JsonToken.VALUE_STRING;\n            _currToken = JsonToken.FIELD_NAME;\n            break;\n        case XmlTokenStream.XML_END:\n            _currToken = null;\n        }\n        return null;\n    }\n", "diff": "diff --git a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\nindex 7b163ed..855920c 100644\n--- a/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n+++ b/src/main/java/com/fasterxml/jackson/dataformat/xml/deser/FromXmlParser.java\n@@ -598,6 +598,7 @@ public class FromXmlParser\n      * String collections.\n      */\n     @Override\n+\n     public String nextTextValue() throws IOException\n     {\n         _binaryValue = null;\n@@ -660,6 +661,7 @@ public class FromXmlParser\n                 _currText = _xmlTokens.getText();\n                 _parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n                 _currToken = JsonToken.START_OBJECT;\n+                return _currText;\n             } else {\n                 _parsingContext.setCurrentName(_xmlTokens.getLocalName());\n                 _currToken = JsonToken.FIELD_NAME;\n@@ -668,7 +670,7 @@ public class FromXmlParser\n         case XmlTokenStream.XML_ATTRIBUTE_VALUE:\n             _currText = _xmlTokens.getText();\n             _currToken = JsonToken.VALUE_STRING;\n-            break;\n+            return _currText;\n         case XmlTokenStream.XML_TEXT:\n             _currText = _xmlTokens.getText();\n             if (_mayBeLeaf) {\n@@ -693,6 +695,7 @@ public class FromXmlParser\n     }\n \n \n+\n     private void _updateState(JsonToken t)\n     {\n         switch (t) {"}
{"project": "JacksonXml", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JacksonXml", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "6", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n        StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n        // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n\n        while (m.find()) {\n            int charval = -1;\n            String num = m.group(3);\n            if (num != null) {\n                try {\n                    int base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\n                    charval = Integer.valueOf(num, base);\n                } catch (NumberFormatException e) {\n                } // skip\n            } else {\n                String name = m.group(1);\n                if (full.containsKey(name))\n                    charval = full.get(name);\n            }\n\n            if (charval != -1 && charval <= 0xFFFF) { // out of range\n                String c = Character.toString((char) charval);\n                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n            } else {\n                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n            }\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 4daf720..efcf84c 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -47,6 +47,7 @@ public class Entities {\n             return string;\n \n         Matcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\n+\n         StringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n         // todo: replace m.appendReplacement with own impl, so StringBuilder and quoteReplacement not required\n \n@@ -65,13 +66,14 @@ public class Entities {\n                     charval = full.get(name);\n             }\n \n-            if (charval != -1 || charval > 0xFFFF) { // out of range\n+            if (charval != -1 && charval <= 0xFFFF) { // out of range\n                 String c = Character.toString((char) charval);\n-                m.appendReplacement(accum, c);\n+                m.appendReplacement(accum, Matcher.quoteReplacement(c));\n             } else {\n-                m.appendReplacement(accum, m.group(0));\n+                m.appendReplacement(accum, Matcher.quoteReplacement(m.group(0)));\n             }\n         }\n+\n         m.appendTail(accum);\n         return accum.toString();\n     }"}
{"project": "Jsoup", "bug_id": "10", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\nif (relUrl.startsWith(\"?\")) {\n                    String path = base.getPath();\n                    base = new URL(base.getProtocol(), base.getHost(), base.getPort(), path + relUrl);\n                    return base.toExternalForm();\n                }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Node.java b/src/main/java/org/jsoup/nodes/Node.java\nindex 5e6eb8f..768bb45 100644\n--- a/src/main/java/org/jsoup/nodes/Node.java\n+++ b/src/main/java/org/jsoup/nodes/Node.java\n@@ -170,6 +170,13 @@ public abstract class Node implements Cloneable {\n                     return abs.toExternalForm();\n                 }\n                 // workaround: java resolves '//path/file + ?foo' to '//path/?foo', not '//path/file?foo' as desired\n+\n+if (relUrl.startsWith(\"?\")) {\n+                    String path = base.getPath();\n+                    base = new URL(base.getProtocol(), base.getHost(), base.getPort(), path + relUrl);\n+                    return base.toExternalForm();\n+                }\n+\n                 URL abs = new URL(base, relUrl);\n                 return abs.toExternalForm();\n             } catch (MalformedURLException e) {"}
{"project": "Jsoup", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "20", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n            if (docData.startsWith(\"\\uFEFF\") || docData.startsWith(\"\\uFFFE\")) {\n                docData = docData.substring(1);\n            }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex e5b044d..0ca04eb 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -96,6 +96,11 @@ public class DataUtil {\n             // in utf-8. If after decoding, there is a BOM, strip it; otherwise will cause the parser to go straight\n             // into head mode\n \n+            if (docData.startsWith(\"\\uFEFF\") || docData.startsWith(\"\\uFFFE\")) {\n+                docData = docData.substring(1);\n+            }\n+\n+\n             doc = parser.parseInput(docData, baseUri);\n             doc.outputSettings().charset(charsetName);\n         }"}
{"project": "Jsoup", "bug_id": "24", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                t.dataBuffer.append(r.consume());", "diff": "diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex e530264..5867b13 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -555,7 +555,7 @@ enum TokeniserState {\n                 String name = r.consumeLetterSequence();\n                 t.tagPending.appendTagName(name.toLowerCase());\n                 t.dataBuffer.append(name);\n-                r.advance();\n+                t.dataBuffer.append(r.consume());\n                 return;\n             }\n "}
{"project": "Jsoup", "bug_id": "25", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};", "diff": "diff --git a/src/main/java/org/jsoup/parser/Tag.java b/src/main/java/org/jsoup/parser/Tag.java\nindex 40b7557..caebf4e 100644\n--- a/src/main/java/org/jsoup/parser/Tag.java\n+++ b/src/main/java/org/jsoup/parser/Tag.java\n@@ -215,7 +215,7 @@ public class Tag {\n     private static final String[] formatAsInlineTags = {\n             \"title\", \"a\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"pre\", \"address\", \"li\", \"th\", \"td\", \"script\", \"style\"\n     };\n-    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\"};\n+    private static final String[] preserveWhitespaceTags = {\"pre\", \"plaintext\", \"title\", \"textarea\"};\n \n     static {\n         // creates"}
{"project": "Jsoup", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "32", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "34", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "            if (offset < length && length - offset >= seq.length()) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/CharacterReader.java b/src/main/java/org/jsoup/parser/CharacterReader.java\nindex dc1b114..d375f16 100644\n--- a/src/main/java/org/jsoup/parser/CharacterReader.java\n+++ b/src/main/java/org/jsoup/parser/CharacterReader.java\n@@ -88,7 +88,7 @@ class CharacterReader {\n                 while(++offset < length && startChar != input[offset]);\n             int i = offset + 1;\n             int last = i + seq.length()-1;\n-            if (offset < length) {\n+            if (offset < length && length - offset >= seq.length()) {\n                 for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++);\n                 if (i == last) // found full sequence\n                     return offset - pos;"}
{"project": "Jsoup", "bug_id": "35", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "37", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "39", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        doc = parser.parseInput(docData, baseUri);", "diff": "diff --git a/src/main/java/org/jsoup/helper/DataUtil.java b/src/main/java/org/jsoup/helper/DataUtil.java\nindex d43bfe4..0b73f31 100644\n--- a/src/main/java/org/jsoup/helper/DataUtil.java\n+++ b/src/main/java/org/jsoup/helper/DataUtil.java\n@@ -116,6 +116,7 @@ public class DataUtil {\n             docData = Charset.forName(defaultCharset).decode(byteData).toString();\n             docData = docData.substring(1);\n             charsetName = defaultCharset;\n+        doc = parser.parseInput(docData, baseUri);\n         }\n         if (doc == null) {\n             doc = parser.parseInput(docData, baseUri);"}
{"project": "Jsoup", "bug_id": "40", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "        Validate.notNull(name);", "diff": "diff --git a/src/main/java/org/jsoup/nodes/DocumentType.java b/src/main/java/org/jsoup/nodes/DocumentType.java\nindex 4b4a5e9..c5ab1db 100644\n--- a/src/main/java/org/jsoup/nodes/DocumentType.java\n+++ b/src/main/java/org/jsoup/nodes/DocumentType.java\n@@ -19,7 +19,7 @@ public class DocumentType extends Node {\n     public DocumentType(String name, String publicId, String systemId, String baseUri) {\n         super(baseUri);\n \n-        Validate.notEmpty(name);\n+        Validate.notNull(name);\n         attr(\"name\", name);\n         attr(\"publicId\", publicId);\n         attr(\"systemId\", systemId);"}
{"project": "Jsoup", "bug_id": "41", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return this.hashCode() == o.hashCode();", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex cd2e86a..47d1aca 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1172,7 +1172,7 @@ public class Element extends Node {\n \n         Element element = (Element) o;\n \n-        return this == o;\n+        return this.hashCode() == o.hashCode();\n     }\n \n     @Override"}
{"project": "Jsoup", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            } else if ((\"td\".equals(name) || \"th\".equals(name)) && !last) {", "diff": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 4a58fdf..bdd4081 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -391,7 +391,7 @@ public class HtmlTreeBuilder extends TreeBuilder {\n             if (\"select\".equals(name)) {\n                 transition(HtmlTreeBuilderState.InSelect);\n                 break; // frag\n-            } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\n+            } else if ((\"td\".equals(name) || \"th\".equals(name)) && !last) {\n                 transition(HtmlTreeBuilderState.InCell);\n                 break;\n             } else if (\"tr\".equals(name)) {"}
{"project": "Jsoup", "bug_id": "46", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "                            accum.append(\"&nbsp;\");", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 6ccb84e..b28441e 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -115,7 +115,7 @@ public class Entities {\n                         if (escapeMode != EscapeMode.xhtml)\n                             accum.append(\"&nbsp;\");\n                         else\n-                            accum.append(c);\n+                            accum.append(\"&nbsp;\");\n                         break;\n                     case '<':\n                         if (!inAttribute)"}
{"project": "Jsoup", "bug_id": "47", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "                        if (escapeMode == EscapeMode.xhtml || !inAttribute)", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Entities.java b/src/main/java/org/jsoup/nodes/Entities.java\nindex 08cf311..00e5c23 100644\n--- a/src/main/java/org/jsoup/nodes/Entities.java\n+++ b/src/main/java/org/jsoup/nodes/Entities.java\n@@ -119,7 +119,7 @@ public class Entities {\n                         break;\n                     case '<':\n                         // escape when in character data or when in a xml attribue val; not needed in html attr val\n-                        if (!inAttribute)\n+                        if (escapeMode == EscapeMode.xhtml || !inAttribute)\n                             accum.append(\"&lt;\");\n                         else\n                             accum.append(c);"}
{"project": "Jsoup", "bug_id": "48", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n        void processResponseHeaders(Map<String, List<String>> resHeaders) {\n            for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                String name = entry.getKey();\n                if (name == null)\n                    continue; // http/1.1 line\n\n                List<String> values = entry.getValue();\n                if (name.equalsIgnoreCase(\"Set-Cookie\")) {\n                    for (String value : values) {\n                        if (value == null)\n                            continue;\n                        TokenQueue cd = new TokenQueue(value);\n                        String cookieName = cd.chompTo(\"=\").trim();\n                        String cookieVal = cd.consumeTo(\";\").trim();\n                        // ignores path, date, domain, validateTLSCertificates et al. req'd?\n                        // name not blank, value not null\n                        if (cookieName.length() > 0)\n                            cookie(cookieName, cookieVal);\n                    }\n                } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n                    if (!values.isEmpty()) {\n                        StringBuilder sb = new StringBuilder(values.get(0));\n                        for (int i = 1; i < values.size(); i++) {\n                            sb.append(\", \").append(values.get(i));\n                        }\n                        header(name, sb.toString());\n                    }\n                }\n            }\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex f8fd9dd..7bba8e5 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -750,6 +750,7 @@ public class HttpConnection implements Connection {\n             return headers;\n         }\n \n+\n         void processResponseHeaders(Map<String, List<String>> resHeaders) {\n             for (Map.Entry<String, List<String>> entry : resHeaders.entrySet()) {\n                 String name = entry.getKey();\n@@ -770,12 +771,18 @@ public class HttpConnection implements Connection {\n                             cookie(cookieName, cookieVal);\n                     }\n                 } else { // combine same header names with comma: http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n-                    if (!values.isEmpty())\n-                        header(name, values.get(0));\n+                    if (!values.isEmpty()) {\n+                        StringBuilder sb = new StringBuilder(values.get(0));\n+                        for (int i = 1; i < values.size(); i++) {\n+                            sb.append(\", \").append(values.get(i));\n+                        }\n+                        header(name, sb.toString());\n+                    }\n                 }\n             }\n         }\n \n+\n         private static String setOutputContentType(final Connection.Request req) {\n             // multipart mode, for files. add the header if we see something with an inputstream, and return a non-null boundary\n             boolean needsMulti = false;"}
{"project": "Jsoup", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "50", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "54", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                if (key.matches(\"^[a-zA-Z_:][-a-zA-Z0-9_:.]*$\")) ", "diff": "diff --git a/src/main/java/org/jsoup/helper/W3CDom.java b/src/main/java/org/jsoup/helper/W3CDom.java\nindex 20aeeda..5c2b2e0 100644\n--- a/src/main/java/org/jsoup/helper/W3CDom.java\n+++ b/src/main/java/org/jsoup/helper/W3CDom.java\n@@ -123,6 +123,7 @@ public class W3CDom {\n             for (Attribute attribute : source.attributes()) {\n                 // valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\n                 String key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\n+                if (key.matches(\"^[a-zA-Z_:][-a-zA-Z0-9_:.]*$\")) \n                     el.setAttribute(key, attribute.getValue());\n             }\n         }"}
{"project": "Jsoup", "bug_id": "55", "eval": "PASS", "attempt": 5, "mode": "SL", "patch": "                    r.unconsume();", "diff": "diff --git a/src/main/java/org/jsoup/parser/TokeniserState.java b/src/main/java/org/jsoup/parser/TokeniserState.java\nindex 3a2ac1f..2e998d5 100644\n--- a/src/main/java/org/jsoup/parser/TokeniserState.java\n+++ b/src/main/java/org/jsoup/parser/TokeniserState.java\n@@ -880,6 +880,7 @@ enum TokeniserState {\n                     break;\n                 default:\n                     t.error(this);\n+                    r.unconsume();\n                     t.transition(BeforeAttributeName);\n             }\n         }"}
{"project": "Jsoup", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                it.remove();", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attributes.java b/src/main/java/org/jsoup/nodes/Attributes.java\nindex 49ff25d..8fdb654 100644\n--- a/src/main/java/org/jsoup/nodes/Attributes.java\n+++ b/src/main/java/org/jsoup/nodes/Attributes.java\n@@ -122,7 +122,7 @@ public class Attributes implements Iterable<Attribute>, Cloneable {\n         for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n             String attrKey = it.next();\n             if (attrKey.equalsIgnoreCase(key))\n-                attributes.remove(attrKey);\n+                it.remove();\n         }\n     }\n "}
{"project": "Jsoup", "bug_id": "59", "eval": "PASS", "attempt": 5, "mode": "SF", "patch": "\n        final void newAttribute() {\n            if (attributes == null)\n                attributes = new Attributes();\n\n            if (pendingAttributeName != null) {\n                // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                pendingAttributeName = pendingAttributeName.trim();\n                if (pendingAttributeName.isEmpty()) {\n                    pendingAttributeName = null;\n                    hasEmptyAttributeValue = false;\n                    hasPendingAttributeValue = false;\n                    reset(pendingAttributeValue);\n                    pendingAttributeValueS = null;\n                    return;\n                }\n\n                Attribute attribute;\n                if (hasPendingAttributeValue)\n                    attribute = new Attribute(pendingAttributeName,\n                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n                else if (hasEmptyAttributeValue)\n                    attribute = new Attribute(pendingAttributeName, \"\");\n                else\n                    attribute = new BooleanAttribute(pendingAttributeName);\n                attributes.put(attribute);\n            }\n            pendingAttributeName = null;\n            hasEmptyAttributeValue = false;\n            hasPendingAttributeValue = false;\n            reset(pendingAttributeValue);\n            pendingAttributeValueS = null;\n        }\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/Token.java b/src/main/java/org/jsoup/parser/Token.java\nindex 7dcfa2b..5a4e26e 100644\n--- a/src/main/java/org/jsoup/parser/Token.java\n+++ b/src/main/java/org/jsoup/parser/Token.java\n@@ -97,6 +97,7 @@ abstract class Token {\n             return this;\n         }\n \n+\n         final void newAttribute() {\n             if (attributes == null)\n                 attributes = new Attributes();\n@@ -104,15 +105,24 @@ abstract class Token {\n             if (pendingAttributeName != null) {\n                 // the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\n                 pendingAttributeName = pendingAttributeName.trim();\n-                    Attribute attribute;\n-                    if (hasPendingAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName,\n-                            pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n-                    else if (hasEmptyAttributeValue)\n-                        attribute = new Attribute(pendingAttributeName, \"\");\n-                    else\n-                        attribute = new BooleanAttribute(pendingAttributeName);\n-                    attributes.put(attribute);\n+                if (pendingAttributeName.isEmpty()) {\n+                    pendingAttributeName = null;\n+                    hasEmptyAttributeValue = false;\n+                    hasPendingAttributeValue = false;\n+                    reset(pendingAttributeValue);\n+                    pendingAttributeValueS = null;\n+                    return;\n+                }\n+\n+                Attribute attribute;\n+                if (hasPendingAttributeValue)\n+                    attribute = new Attribute(pendingAttributeName,\n+                        pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS);\n+                else if (hasEmptyAttributeValue)\n+                    attribute = new Attribute(pendingAttributeName, \"\");\n+                else\n+                    attribute = new BooleanAttribute(pendingAttributeName);\n+                attributes.put(attribute);\n             }\n             pendingAttributeName = null;\n             hasEmptyAttributeValue = false;\n@@ -121,6 +131,7 @@ abstract class Token {\n             pendingAttributeValueS = null;\n         }\n \n+\n         final void finaliseTag() {\n             // finalises for emit\n             if (pendingAttributeName != null) {"}
{"project": "Jsoup", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "62", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "66", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "68", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        int bottom = stack.size() -1;\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\nindex 08444ef..2492180 100644\n--- a/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java\n@@ -465,10 +465,9 @@ public class HtmlTreeBuilder extends TreeBuilder {\n \n     private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n         // https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\n+\n         int bottom = stack.size() -1;\n-        if (bottom > MaxScopeSearchDepth) {\n-            bottom = MaxScopeSearchDepth;\n-        }\n+\n         final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n         // don't walk too far up the tree\n "}
{"project": "Jsoup", "bug_id": "70", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    static boolean preserveWhitespace(Node node) {\n        // looks only at this element and five levels up, to prevent recursion & needless stack searches\n        if (node != null && node instanceof Element) {\n            Element el = (Element) node;\n            if (el.tag().preserveWhitespace())\n                return true;\n            else {\n                Node parent = el.parent();\n                for (int i = 0; i < 5 && parent != null; i++) {\n                    if (((Element)parent).tag().preserveWhitespace())\n                        return true;\n                    parent = parent.parent();\n                }\n                return false;\n            }\n        }\n        return false;\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Element.java b/src/main/java/org/jsoup/nodes/Element.java\nindex faca4c8..4e2fbd7 100644\n--- a/src/main/java/org/jsoup/nodes/Element.java\n+++ b/src/main/java/org/jsoup/nodes/Element.java\n@@ -1084,18 +1084,27 @@ public class Element extends Node {\n             accum.append(\" \");\n     }\n \n+\n     static boolean preserveWhitespace(Node node) {\n         // looks only at this element and five levels up, to prevent recursion & needless stack searches\n         if (node != null && node instanceof Element) {\n             Element el = (Element) node;\n-                if (el.tag.preserveWhitespace())\n-                    return true;\n-                else\n-                    return el.parent() != null && el.parent().tag.preserveWhitespace();\n+            if (el.tag().preserveWhitespace())\n+                return true;\n+            else {\n+                Node parent = el.parent();\n+                for (int i = 0; i < 5 && parent != null; i++) {\n+                    if (((Element)parent).tag().preserveWhitespace())\n+                        return true;\n+                    parent = parent.parent();\n+                }\n+                return false;\n+            }\n         }\n         return false;\n     }\n \n+\n     /**\n      * Set the text of this element. Any existing contents (text or elements) will be cleared\n      * @param text unencoded text"}
{"project": "Jsoup", "bug_id": "72", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "75", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "76", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "77", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        String elName = endTag.name().toLowerCase();", "diff": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 65d3045..3c4e96c 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -114,7 +114,7 @@ public class XmlTreeBuilder extends TreeBuilder {\n      * @param endTag tag to close\n      */\n     private void popStackToClose(Token.EndTag endTag) {\n-        String elName = endTag.name();\n+        String elName = endTag.name().toLowerCase();\n         Element firstFound = null;\n \n         for (int pos = stack.size() -1; pos >= 0; pos--) {"}
{"project": "Jsoup", "bug_id": "80", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\nvoid insert(Token.Comment commentToken) {\n    Comment comment = new Comment(commentToken.getData());\n    Node insert = comment;\n    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n        // so we do a bit of a hack and try to parse the data as an element to pull the attributes out\n        String data = comment.getData();\n        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n            String xml = \"<\" + data.substring(1, data.length() -1) + \">\";\n            Document doc;\n            try {\n                doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n                Element el = doc.child(0);\n                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n                insert.attributes().addAll(el.attributes());\n            } catch (IndexOutOfBoundsException e) {\n                // If there's an IndexOutOfBoundsException, it's because the xml wasn't well-formed and Jsoup couldn't parse it.\n                // In this case, just insert the comment as a normal comment.\n            }\n        }\n    }\n    insertNode(insert);\n}\n", "diff": "diff --git a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\nindex 75374e4..5ec097b 100644\n--- a/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n+++ b/src/main/java/org/jsoup/parser/XmlTreeBuilder.java\n@@ -80,21 +80,30 @@ public class XmlTreeBuilder extends TreeBuilder {\n         return el;\n     }\n \n-    void insert(Token.Comment commentToken) {\n-        Comment comment = new Comment(commentToken.getData());\n-        Node insert = comment;\n-        if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n-            // so we do a bit of a hack and parse the data as an element to pull the attributes out\n-            String data = comment.getData();\n-            if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n-                Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri, Parser.xmlParser());\n-                    Element el = doc.child(0);\n-                    insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n-                    insert.attributes().addAll(el.attributes());\n+\n+void insert(Token.Comment commentToken) {\n+    Comment comment = new Comment(commentToken.getData());\n+    Node insert = comment;\n+    if (commentToken.bogus) { // xml declarations are emitted as bogus comments (which is right for html, but not xml)\n+        // so we do a bit of a hack and try to parse the data as an element to pull the attributes out\n+        String data = comment.getData();\n+        if (data.length() > 1 && (data.startsWith(\"!\") || data.startsWith(\"?\"))) {\n+            String xml = \"<\" + data.substring(1, data.length() -1) + \">\";\n+            Document doc;\n+            try {\n+                doc = Jsoup.parse(xml, \"\", Parser.xmlParser());\n+                Element el = doc.child(0);\n+                insert = new XmlDeclaration(settings.normalizeTag(el.tagName()), data.startsWith(\"!\"));\n+                insert.attributes().addAll(el.attributes());\n+            } catch (IndexOutOfBoundsException e) {\n+                // If there's an IndexOutOfBoundsException, it's because the xml wasn't well-formed and Jsoup couldn't parse it.\n+                // In this case, just insert the comment as a normal comment.\n             }\n         }\n-        insertNode(insert);\n     }\n+    insertNode(insert);\n+}\n+\n \n     void insert(Token.Character token) {\n         final String data = token.getData();"}
{"project": "Jsoup", "bug_id": "82", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Jsoup", "bug_id": "85", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public Attribute(String key, String val, Attributes parent) {\n        Validate.notNull(key);\n        this.key = key.trim();\n        Validate.notEmpty(this.key); // trimming could potentially make empty, so validate here\n        this.val = val;\n        this.parent = parent;\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 612fdeb..0f8022a 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -39,14 +39,16 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      * @param val attribute value\n      * @param parent the containing Attributes (this Attribute is not automatically added to said Attributes)\n      * @see #createFromEncoded*/\n+\n     public Attribute(String key, String val, Attributes parent) {\n         Validate.notNull(key);\n         this.key = key.trim();\n-        Validate.notEmpty(key); // trimming could potentially make empty, so validate here\n+        Validate.notEmpty(this.key); // trimming could potentially make empty, so validate here\n         this.val = val;\n         this.parent = parent;\n     }\n \n+\n     /**\n      Get the attribute key.\n      @return the attribute key"}
{"project": "Jsoup", "bug_id": "86", "eval": "PASS", "attempt": 4, "mode": "SL", "patch": "        if (doc.children().size() > 0) {", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Comment.java b/src/main/java/org/jsoup/nodes/Comment.java\nindex d0669fe..d983385 100644\n--- a/src/main/java/org/jsoup/nodes/Comment.java\n+++ b/src/main/java/org/jsoup/nodes/Comment.java\n@@ -75,7 +75,7 @@ public class Comment extends LeafNode {\n         String data = getData();\n         Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n         XmlDeclaration decl = null;\n-        if (doc.childNodeSize() > 0) {\n+        if (doc.children().size() > 0) {\n             Element el = doc.child(0);\n             decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\"));\n             decl.attributes().addAll(el.attributes());"}
{"project": "Jsoup", "bug_id": "88", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        return val == null ? \"\" : val;", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex e321b6a..fb305bb 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -77,7 +77,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      @return the attribute value\n      */\n     public String getValue() {\n-        return val;\n+        return val == null ? \"\" : val;\n     }\n \n     /**"}
{"project": "Jsoup", "bug_id": "89", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public String setValue(String val) {\n        String oldVal = this.val; // Changed this line\n        if (parent != null) {\n            int i = parent.indexOfKey(this.key);\n            if (i != Attributes.NotFound)\n                parent.vals[i] = val;\n        }\n        this.val = val;\n        return Attributes.checkNotNull(oldVal);\n    }\n", "diff": "diff --git a/src/main/java/org/jsoup/nodes/Attribute.java b/src/main/java/org/jsoup/nodes/Attribute.java\nindex 4ff695d..96ee4b2 100644\n--- a/src/main/java/org/jsoup/nodes/Attribute.java\n+++ b/src/main/java/org/jsoup/nodes/Attribute.java\n@@ -84,8 +84,9 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n      Set the attribute value.\n      @param val the new attribute value; must not be null\n      */\n+\n     public String setValue(String val) {\n-        String oldVal = parent.get(this.key);\n+        String oldVal = this.val; // Changed this line\n         if (parent != null) {\n             int i = parent.indexOfKey(this.key);\n             if (i != Attributes.NotFound)\n@@ -95,6 +96,7 @@ public class Attribute implements Map.Entry<String, String>, Cloneable  {\n         return Attributes.checkNotNull(oldVal);\n     }\n \n+\n     /**\n      Get the HTML representation of this attribute; e.g. {@code href=\"index.html\"}.\n      @return HTML"}
{"project": "Jsoup", "bug_id": "90", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n                if (end > input.length) {\n                    return false;\n                }\n", "diff": "diff --git a/src/main/java/org/jsoup/helper/HttpConnection.java b/src/main/java/org/jsoup/helper/HttpConnection.java\nindex a941e48..126294e 100644\n--- a/src/main/java/org/jsoup/helper/HttpConnection.java\n+++ b/src/main/java/org/jsoup/helper/HttpConnection.java\n@@ -422,6 +422,11 @@ public class HttpConnection implements Connection {\n                 }\n \n \n+                if (end > input.length) {\n+                    return false;\n+                }\n+\n+\n                 while (i < end) {\n                     i++;\n                     o = input[i];"}
{"project": "Jsoup", "bug_id": "93", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "8", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    private boolean compute(Object left, Object right) {\n        left = reduce(left);\n        right = reduce(right);\n\n        if (left instanceof InitialContext) {\n            ((InitialContext) left).reset();\n        }\n        if (right instanceof InitialContext) {\n            ((InitialContext) right).reset();\n        }\n        if (left instanceof Iterator && right instanceof Iterator) {\n            return findMatch((Iterator) left, (Iterator) right);\n        }\n        if (left instanceof Iterator) {\n            return containsMatch((Iterator) left, right);\n        }\n        if (right instanceof Iterator) {\n            return containsMatch((Iterator) right, left);\n        }\n        double ld = InfoSetUtil.doubleValue(left);\n        double rd = InfoSetUtil.doubleValue(right);\n\n        // Correcting the issue here\n        if (Double.isNaN(ld) || Double.isNaN(rd)) {\n            return evaluateCompare(0);\n        }\n\n        return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\nindex c6e0041..abcdb67 100644\n--- a/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n+++ b/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java\n@@ -53,6 +53,7 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n \n     protected abstract boolean evaluateCompare(int compare);\n \n+\n     private boolean compute(Object left, Object right) {\n         left = reduce(left);\n         right = reduce(right);\n@@ -74,9 +75,16 @@ public abstract class CoreOperationRelationalExpression extends CoreOperation {\n         }\n         double ld = InfoSetUtil.doubleValue(left);\n         double rd = InfoSetUtil.doubleValue(right);\n+\n+        // Correcting the issue here\n+        if (Double.isNaN(ld) || Double.isNaN(rd)) {\n+            return evaluateCompare(0);\n+        }\n+\n         return evaluateCompare(ld == rd ? 0 : ld < rd ? -1 : 1);\n     }\n \n+\n     private Object reduce(Object o) {\n         if (o instanceof SelfContext) {\n             o = ((EvalContext) o).getSingleNodePointer();"}
{"project": "JxPath", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "JxPath", "bug_id": "22", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\n    public static String getNamespaceURI(Node node) {\n        if (node instanceof Document) {\n            node = ((Document) node).getDocumentElement();\n        }\n\n        Element element = (Element) node;\n\n        String uri = element.getNamespaceURI();\n        if (uri == null) {\n            String prefix = element.getPrefix();\n            if (prefix == null) {\n                return null;\n            }\n            String qname = \"xmlns:\" + prefix;\n            Node aNode = node;\n            while (aNode != null) {\n                if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n                    Attr attr = ((Element) aNode).getAttributeNode(qname);\n                    if (attr != null) {\n                        return attr.getValue();\n                    }\n                }\n                aNode = aNode.getParentNode();\n            }\n            return null;\n        }\n        return uri;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\nindex f8e3b1a..1dffca9 100644\n--- a/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n+++ b/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java\n@@ -669,6 +669,7 @@ public class DOMNodePointer extends NodePointer {\n      * @param node Node to check\n      * @return String ns uri\n      */\n+\n     public static String getNamespaceURI(Node node) {\n         if (node instanceof Document) {\n             node = ((Document) node).getDocumentElement();\n@@ -678,9 +679,11 @@ public class DOMNodePointer extends NodePointer {\n \n         String uri = element.getNamespaceURI();\n         if (uri == null) {\n-            String prefix = getPrefix(node);\n-            String qname = prefix == null ? \"xmlns\" : \"xmlns:\" + prefix;\n-    \n+            String prefix = element.getPrefix();\n+            if (prefix == null) {\n+                return null;\n+            }\n+            String qname = \"xmlns:\" + prefix;\n             Node aNode = node;\n             while (aNode != null) {\n                 if (aNode.getNodeType() == Node.ELEMENT_NODE) {\n@@ -696,6 +699,7 @@ public class DOMNodePointer extends NodePointer {\n         return uri;\n     }\n \n+\n     public Object getValue() {\n         if (node.getNodeType() == Node.COMMENT_NODE) {\n             String text = ((Comment) node).getData();"}
{"project": "Lang", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "3", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "6", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "12", "eval": "PASS", "attempt": 15, "mode": "SF", "patch": "\n    public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                char[] chars, Random random) {\n        if (count == 0) {\n            return \"\";\n        } else if (count < 0) {\n            throw new IllegalArgumentException(\"Requested random string length \" + count + \" is less than 0.\");\n        }\n\n        if (start == 0 && end == 0) {\n                if (!letters && !numbers) {\n                    end = Integer.MAX_VALUE;\n                } else {\n                    end = 'z' + 1;\n                    start = ' ';                    \n                }\n        }\n\n        char[] buffer = new char[count];\n        int gap = end - start;\n\n        while (count-- != 0) {\n            char ch;\n            if (chars == null) {\n                ch = (char) (random.nextInt(gap) + start);\n            } else {\n                ch = chars[random.nextInt(chars.length)];\n            }\n            if ( (letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers) ) {\n                if(ch >= 56320 && ch <= 57343) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // low surrogate, insert high surrogate after putting it in\n                        buffer[count] = ch;\n                        count--;\n                        buffer[count] = (char) (55296 + random.nextInt(128));\n                    }\n                } else if(ch >= 55296 && ch <= 56191) {\n                    if(count == 0) {\n                        count++;\n                    } else {\n                        // high surrogate, insert low surrogate before putting it in\n                        buffer[count] = (char) (56320 + random.nextInt(128));\n                        count--;\n                        buffer[count] = ch;\n                    }\n                } else if(ch >= 56192 && ch <= 56319) {\n                    // private high surrogate, no effing clue, so skip it\n                    count++;\n                } else {\n                    buffer[count] = ch;\n                }\n            } else {\n                count++;\n            }\n        }\n        return new String(buffer);\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\nindex b200223d..0e609e1e 100644\n--- a/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/RandomStringUtils.java\n@@ -220,6 +220,7 @@ public class RandomStringUtils {\n      * @throws IllegalArgumentException if {@code count} &lt; 0 or the provided chars array is empty.\n      * @since 2.0\n      */\n+\n     public static String random(int count, int start, int end, boolean letters, boolean numbers,\n                                 char[] chars, Random random) {\n         if (count == 0) {\n@@ -233,7 +234,7 @@ public class RandomStringUtils {\n                     end = Integer.MAX_VALUE;\n                 } else {\n                     end = 'z' + 1;\n-                    start = ' ';                \n+                    start = ' ';                    \n                 }\n         }\n \n@@ -245,11 +246,9 @@ public class RandomStringUtils {\n             if (chars == null) {\n                 ch = (char) (random.nextInt(gap) + start);\n             } else {\n-                ch = chars[random.nextInt(gap) + start];\n+                ch = chars[random.nextInt(chars.length)];\n             }\n-            if (letters && Character.isLetter(ch)\n-                    || numbers && Character.isDigit(ch)\n-                    || !letters && !numbers) {\n+            if ( (letters && Character.isLetter(ch)) || (numbers && Character.isDigit(ch)) || (!letters && !numbers) ) {\n                 if(ch >= 56320 && ch <= 57343) {\n                     if(count == 0) {\n                         count++;\n@@ -281,6 +280,7 @@ public class RandomStringUtils {\n         return new String(buffer);\n     }\n \n+\n     /**\n      * <p>Creates a random string whose length is the number of characters\n      * specified.</p>"}
{"project": "Lang", "bug_id": "14", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public static boolean equals(CharSequence cs1, CharSequence cs2) {\n        if (cs1 == cs2) {\n            return true;\n        }\n        if (cs1 == null || cs2 == null) {\n            return false;\n        }\n        if (cs1.length() != cs2.length()) {\n            return false;\n        }\n        for (int i = 0; i < cs1.length(); i++) {\n            if (cs1.charAt(i) != cs2.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/StringUtils.java b/src/main/java/org/apache/commons/lang3/StringUtils.java\nindex 535a3f24..d6f77c9c 100644\n--- a/src/main/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/StringUtils.java\n@@ -778,6 +778,7 @@ public class StringUtils {\n      * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}\n      * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)\n      */\n+\n     public static boolean equals(CharSequence cs1, CharSequence cs2) {\n         if (cs1 == cs2) {\n             return true;\n@@ -785,9 +786,18 @@ public class StringUtils {\n         if (cs1 == null || cs2 == null) {\n             return false;\n         }\n-            return cs1.equals(cs2);\n+        if (cs1.length() != cs2.length()) {\n+            return false;\n+        }\n+        for (int i = 0; i < cs1.length(); i++) {\n+            if (cs1.charAt(i) != cs2.charAt(i)) {\n+                return false;\n+            }\n+        }\n+        return true;\n     }\n \n+\n     /**\n      * <p>Compares two CharSequences, returning {@code true} if they represent\n      * equal sequences of characters, ignoring case.</p>"}
{"project": "Lang", "bug_id": "16", "eval": "PASS", "attempt": 9, "mode": "SL", "patch": "        if (str.startsWith(\"0X\") || str.startsWith(\"-0X\") || str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\nindex 882358f2..1e27cd93 100644\n--- a/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/math/NumberUtils.java\n@@ -455,7 +455,7 @@ public class NumberUtils {\n             // a wrong value.\n             return null;\n         }\n-        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n+        if (str.startsWith(\"0X\") || str.startsWith(\"-0X\") || str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n             return createInteger(str);\n         }   \n         char lastChar = str.charAt(str.length() - 1);"}
{"project": "Lang", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "21", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/DateUtils.java b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\nindex 9a24c00f..52a44363 100644\n--- a/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/time/DateUtils.java\n@@ -262,7 +262,7 @@ public class DateUtils {\n         return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n                 cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n                 cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n-                cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n+                cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n                 cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n                 cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n                 cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) &&"}
{"project": "Lang", "bug_id": "22", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    private static int greatestCommonDivisor(int u, int v) {\n        // From Commons Math:\n        //if either operand is abs 1, return 1:\n        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n            return 1;\n        }\n        // keep u and v negative, as negative integers range down to\n        // -2^31, while positive numbers can only be as large as 2^31-1\n        // (i.e. we can't necessarily negate a negative number without\n        // overflow)\n        if (u > 0) { u = -u; } // make u negative\n        if (v > 0) { v = -v; } // make v negative\n        // B1. [Find power of 2]\n        int k = 0;\n        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n            u /= 2; v /= 2; k++; // cast out twos.\n        }\n        if (k == 31) {\n            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n        }\n        // B2. Initialize: u and v have been divided by 2^k and at least\n        //     one is odd.\n        int t = ((u & 1) == 1) ? v : -(u / 2);\n        // t negative: u was odd, v may be even (t replaces v)\n        // t positive: u was even, v is odd (t replaces u)\n        do {\n            /* assert u<0 && v<0; */\n            // B4/B3: cast out twos from t.\n            while ((t & 1) == 0) { // while t is even..\n                t /= 2; // cast out twos\n            }\n            // B5 [reset max(u,v)]\n            if (t > 0) {\n                u = -t;\n            } else {\n                v = t;\n            }\n            // B6/B3. at this point both u and v should be odd.\n            t = (v - u) / 2;\n            // |u| larger: t positive (replace u)\n            // |v| larger: t negative (replace v)\n        } while (t != 0);\n        return -u * (1 << k); // gcd is u*2^k\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/math/Fraction.java b/src/main/java/org/apache/commons/lang3/math/Fraction.java\nindex b36a156a..fa698125 100644\n--- a/src/main/java/org/apache/commons/lang3/math/Fraction.java\n+++ b/src/main/java/org/apache/commons/lang3/math/Fraction.java\n@@ -578,51 +578,53 @@ public final class Fraction extends Number implements Comparable<Fraction> {\n      * @param v  a non-zero number\n      * @return the greatest common divisor, never zero\n      */\n+\n     private static int greatestCommonDivisor(int u, int v) {\n         // From Commons Math:\n         //if either operand is abs 1, return 1:\n-        if (Math.abs(u) <= 1 || Math.abs(v) <= 1) {\n+        if (Math.abs(u) == 1 || Math.abs(v) == 1) {\n             return 1;\n         }\n         // keep u and v negative, as negative integers range down to\n         // -2^31, while positive numbers can only be as large as 2^31-1\n         // (i.e. we can't necessarily negate a negative number without\n         // overflow)\n-        if (u>0) { u=-u; } // make u negative\n-        if (v>0) { v=-v; } // make v negative\n+        if (u > 0) { u = -u; } // make u negative\n+        if (v > 0) { v = -v; } // make v negative\n         // B1. [Find power of 2]\n-        int k=0;\n-        while ((u&1)==0 && (v&1)==0 && k<31) { // while u and v are both even...\n-            u/=2; v/=2; k++; // cast out twos.\n+        int k = 0;\n+        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are both even...\n+            u /= 2; v /= 2; k++; // cast out twos.\n         }\n-        if (k==31) {\n+        if (k == 31) {\n             throw new ArithmeticException(\"overflow: gcd is 2^31\");\n         }\n         // B2. Initialize: u and v have been divided by 2^k and at least\n         //     one is odd.\n-        int t = ((u&1)==1) ? v : -(u/2)/*B3*/;\n+        int t = ((u & 1) == 1) ? v : -(u / 2);\n         // t negative: u was odd, v may be even (t replaces v)\n         // t positive: u was even, v is odd (t replaces u)\n         do {\n             /* assert u<0 && v<0; */\n             // B4/B3: cast out twos from t.\n-            while ((t&1)==0) { // while t is even..\n-                t/=2; // cast out twos\n+            while ((t & 1) == 0) { // while t is even..\n+                t /= 2; // cast out twos\n             }\n             // B5 [reset max(u,v)]\n-            if (t>0) {\n+            if (t > 0) {\n                 u = -t;\n             } else {\n                 v = t;\n             }\n             // B6/B3. at this point both u and v should be odd.\n-            t = (v - u)/2;\n+            t = (v - u) / 2;\n             // |u| larger: t positive (replace u)\n             // |v| larger: t negative (replace v)\n-        } while (t!=0);\n-        return -u*(1<<k); // gcd is u*2^k\n+        } while (t != 0);\n+        return -u * (1 << k); // gcd is u*2^k\n     }\n \n+\n     // Arithmetic\n     //-------------------------------------------------------------------\n "}
{"project": "Lang", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "33", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "            classes[i] = (array[i] == null) ? null : array[i].getClass();", "diff": "diff --git a/src/main/java/org/apache/commons/lang3/ClassUtils.java b/src/main/java/org/apache/commons/lang3/ClassUtils.java\nindex 615e4a9a..d0f4af10 100644\n--- a/src/main/java/org/apache/commons/lang3/ClassUtils.java\n+++ b/src/main/java/org/apache/commons/lang3/ClassUtils.java\n@@ -907,7 +907,7 @@ public class ClassUtils {\n         }\n         Class<?>[] classes = new Class[array.length];\n         for (int i = 0; i < array.length; i++) {\n-            classes[i] = array[i].getClass();\n+            classes[i] = (array[i] == null) ? null : array[i].getClass();\n         }\n         return classes;\n     }"}
{"project": "Lang", "bug_id": "37", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\n    public static <T> T[] addAll(T[] array1, T... array2) {\n        if (array1 == null) {\n            return clone(array2);\n        } else if (array2 == null) {\n            return clone(array1);\n        }\n        final Class<?> type1 = array1.getClass().getComponentType();\n        final Class<?> type2 = array2.getClass().getComponentType();\n        \n        // Check if the types are compatible\n        if (!type1.isAssignableFrom(type2)) {\n            throw new IllegalArgumentException(\"Incompatible types: \" + type1 + \" and \" + type2);\n        }\n        \n        T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n        System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n\n        return joinedArray;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/lang3/ArrayUtils.java b/src/java/org/apache/commons/lang3/ArrayUtils.java\nindex 889497e9..562b705e 100644\n--- a/src/java/org/apache/commons/lang3/ArrayUtils.java\n+++ b/src/java/org/apache/commons/lang3/ArrayUtils.java\n@@ -2950,6 +2950,7 @@ public class ArrayUtils {\n      * @since 2.1\n      */\n     @SuppressWarnings(\"unchecked\")\n+\n     public static <T> T[] addAll(T[] array1, T... array2) {\n         if (array1 == null) {\n             return clone(array2);\n@@ -2957,13 +2958,21 @@ public class ArrayUtils {\n             return clone(array1);\n         }\n         final Class<?> type1 = array1.getClass().getComponentType();\n+        final Class<?> type2 = array2.getClass().getComponentType();\n+        \n+        // Check if the types are compatible\n+        if (!type1.isAssignableFrom(type2)) {\n+            throw new IllegalArgumentException(\"Incompatible types: \" + type1 + \" and \" + type2);\n+        }\n+        \n         T[] joinedArray = (T[]) Array.newInstance(type1, array1.length + array2.length);\n         System.arraycopy(array1, 0, joinedArray, 0, array1.length);\n-            System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n-            // Check if problem is incompatible types\n+        System.arraycopy(array2, 0, joinedArray, array1.length, array2.length);\n+\n         return joinedArray;\n     }\n \n+\n     /**\n      * <p>Adds all the elements of the given arrays into a new array.</p>\n      * <p>The new array contains all of the element of <code>array1</code> followed"}
{"project": "Lang", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "40", "eval": "PASS", "attempt": 10, "mode": "SH", "patch": "\n        for (int i = 0; i <= str.length() - searchStr.length(); i++) {\n            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n                return true;\n            }\n        }\n        return false;\n", "diff": "diff --git a/src/java/org/apache/commons/lang/StringUtils.java b/src/java/org/apache/commons/lang/StringUtils.java\nindex 72b4a491..f3e995d7 100644\n--- a/src/java/org/apache/commons/lang/StringUtils.java\n+++ b/src/java/org/apache/commons/lang/StringUtils.java\n@@ -1045,7 +1045,14 @@ public class StringUtils {\n         if (str == null || searchStr == null) {\n             return false;\n         }\n-        return contains(str.toUpperCase(), searchStr.toUpperCase());\n+\n+        for (int i = 0; i <= str.length() - searchStr.length(); i++) {\n+            if (str.regionMatches(true, i, searchStr, 0, searchStr.length())) {\n+                return true;\n+            }\n+        }\n+        return false;\n+\n     }\n \n     // IndexOfAny chars"}
{"project": "Lang", "bug_id": "42", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public void escape(Writer writer, String str) throws IOException {\n        int len = str.length();\n        for (int i = 0; i < len; i++) {\n            char c = str.charAt(i);\n            \n            // Handling characters above 0xFFFF which are represented as surrogate pairs in Java\n            if (Character.isHighSurrogate(c)) {\n                char lowSurrogate = str.charAt(++i);\n                int codePoint = Character.toCodePoint(c, lowSurrogate);\n                writer.write(\"&#\");\n                writer.write(Integer.toString(codePoint, 10));\n                writer.write(';');\n            } else {\n                String entityName = this.entityName(c);\n                if (entityName == null) {\n                    if (c > 0x7F) {\n                        writer.write(\"&#\");\n                        writer.write(Integer.toString(c, 10));\n                        writer.write(';');\n                    } else {\n                        writer.write(c);\n                    }\n                } else {\n                    writer.write('&');\n                    writer.write(entityName);\n                    writer.write(';');\n                }\n            }\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/lang/Entities.java b/src/java/org/apache/commons/lang/Entities.java\nindex 900e1a89..f13e056b 100644\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -822,27 +822,39 @@ class Entities {\n      * @see #escape(String)\n      * @see Writer\n      */\n+\n     public void escape(Writer writer, String str) throws IOException {\n         int len = str.length();\n         for (int i = 0; i < len; i++) {\n             char c = str.charAt(i);\n-            String entityName = this.entityName(c);\n-            if (entityName == null) {\n-                if (c > 0x7F) {\n-                    writer.write(\"&#\");\n-                    writer.write(Integer.toString(c, 10));\n-                    writer.write(';');\n+            \n+            // Handling characters above 0xFFFF which are represented as surrogate pairs in Java\n+            if (Character.isHighSurrogate(c)) {\n+                char lowSurrogate = str.charAt(++i);\n+                int codePoint = Character.toCodePoint(c, lowSurrogate);\n+                writer.write(\"&#\");\n+                writer.write(Integer.toString(codePoint, 10));\n+                writer.write(';');\n+            } else {\n+                String entityName = this.entityName(c);\n+                if (entityName == null) {\n+                    if (c > 0x7F) {\n+                        writer.write(\"&#\");\n+                        writer.write(Integer.toString(c, 10));\n+                        writer.write(';');\n+                    } else {\n+                        writer.write(c);\n+                    }\n                 } else {\n-                    writer.write(c);\n+                    writer.write('&');\n+                    writer.write(entityName);\n+                    writer.write(';');\n                 }\n-            } else {\n-                writer.write('&');\n-                writer.write(entityName);\n-                writer.write(';');\n             }\n         }\n     }\n \n+\n     /**\n      * <p>\n      * Unescapes the entities in a <code>String</code>."}
{"project": "Lang", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "44", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "45", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n", "diff": "diff --git a/src/java/org/apache/commons/lang/WordUtils.java b/src/java/org/apache/commons/lang/WordUtils.java\nindex 42bd883e..db7bd6f4 100644\n--- a/src/java/org/apache/commons/lang/WordUtils.java\n+++ b/src/java/org/apache/commons/lang/WordUtils.java\n@@ -613,6 +613,11 @@ public class WordUtils {\n \n         // if the lower value is greater than the length of the string,\n         // set to the length of the string\n+\n+        if (lower > str.length()) {\n+            lower = str.length();\n+        }\n+\n         // if the upper value is -1 (i.e. no limit) or is greater\n         // than the length of the string, set to the length of the string\n         if (upper == -1 || upper > str.length()) {"}
{"project": "Lang", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "49", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "51", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                    return false;", "diff": "diff --git a/src/java/org/apache/commons/lang/BooleanUtils.java b/src/java/org/apache/commons/lang/BooleanUtils.java\nindex 3fda4ecc..6417625e 100644\n--- a/src/java/org/apache/commons/lang/BooleanUtils.java\n+++ b/src/java/org/apache/commons/lang/BooleanUtils.java\n@@ -679,6 +679,7 @@ public class BooleanUtils {\n                         (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                         (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                 }\n+                    return false;\n             }\n             case 4: {\n                 char ch = str.charAt(0);"}
{"project": "Lang", "bug_id": "52", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "53", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "55", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public void stop() {\n        if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n            throw new IllegalStateException(\"Stopwatch is not running. \");\n        }\n\n        if(this.runningState == STATE_RUNNING) {\n            stopTime = System.currentTimeMillis();\n        }\n        this.runningState = STATE_STOPPED;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/lang/time/StopWatch.java b/src/java/org/apache/commons/lang/time/StopWatch.java\nindex 8f394217..48907dac 100644\n--- a/src/java/org/apache/commons/lang/time/StopWatch.java\n+++ b/src/java/org/apache/commons/lang/time/StopWatch.java\n@@ -111,14 +111,19 @@ public class StopWatch {\n      *\n      * @throws IllegalStateException if the StopWatch is not running.\n      */\n+\n     public void stop() {\n         if(this.runningState != STATE_RUNNING && this.runningState != STATE_SUSPENDED) {\n             throw new IllegalStateException(\"Stopwatch is not running. \");\n         }\n+\n+        if(this.runningState == STATE_RUNNING) {\n             stopTime = System.currentTimeMillis();\n+        }\n         this.runningState = STATE_STOPPED;\n     }\n \n+\n     /**\n      * <p>Resets the stopwatch. Stops it if need be. </p>\n      * "}
{"project": "Lang", "bug_id": "57", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);", "diff": "diff --git a/src/java/org/apache/commons/lang/LocaleUtils.java b/src/java/org/apache/commons/lang/LocaleUtils.java\nindex ceb886e8..86b31d4b 100644\n--- a/src/java/org/apache/commons/lang/LocaleUtils.java\n+++ b/src/java/org/apache/commons/lang/LocaleUtils.java\n@@ -220,7 +220,7 @@ public class LocaleUtils {\n      * @return true if the locale is a known locale\n      */\n     public static boolean isAvailableLocale(Locale locale) {\n-        return cAvailableLocaleSet.contains(locale);\n+        return cAvailableLocaleSet != null && cAvailableLocaleSet.contains(locale);\n     }\n \n     //-----------------------------------------------------------------------"}
{"project": "Lang", "bug_id": "58", "eval": "PASS", "attempt": 7, "mode": "SH", "patch": "\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n", "diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a47..58f8c64d 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,8 +451,9 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n+\n                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {"}
{"project": "Lang", "bug_id": "59", "eval": "PASS", "attempt": 6, "mode": "SL", "patch": "                str.getChars(0, Math.min(strLen,width), buffer, size);", "diff": "diff --git a/src/java/org/apache/commons/lang/text/StrBuilder.java b/src/java/org/apache/commons/lang/text/StrBuilder.java\nindex 886d424e..b51d0d26 100644\n--- a/src/java/org/apache/commons/lang/text/StrBuilder.java\n+++ b/src/java/org/apache/commons/lang/text/StrBuilder.java\n@@ -881,7 +881,7 @@ public class StrBuilder implements Cloneable {\n             String str = (obj == null ? getNullText() : obj.toString());\n             int strLen = str.length();\n             if (strLen >= width) {\n-                str.getChars(0, strLen, buffer, size);\n+                str.getChars(0, Math.min(strLen,width), buffer, size);\n             } else {\n                 int padLen = width - strLen;\n                 str.getChars(0, strLen, buffer, size);"}
{"project": "Lang", "bug_id": "61", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Lang", "bug_id": "65", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "2", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "3", "eval": "PASS", "attempt": 6, "mode": "SF", "patch": "\npublic static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n    double sHighPrev = prodHigh[0];\n    double sLowSum = 0;\n\n    for (int i = 1; i < len; i++) {\n        final double prodHighNext = prodHigh[i];\n        final double sHighCur = sHighPrev + prodHighNext;\n        final double sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n        sHighPrev = sHighCur;\n    }\n\n    double result = sHighPrev + (prodLowSum + sLowSum);\n\n    if (Double.isNaN(result)) {\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..4b78a63de 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,65 +811,54 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n-        throws DimensionMismatchException {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n \n-            // Revert to scalar multiplication.\n+public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n+    final int len = a.length;\n+    if (len != b.length) {\n+        throw new DimensionMismatchException(len, b.length);\n+    }\n \n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n+    final double[] prodHigh = new double[len];\n+    double prodLowSum = 0;\n+\n+    for (int i = 0; i < len; i++) {\n+        final double ai = a[i];\n+        final double ca = SPLIT_FACTOR * ai;\n+        final double aHigh = ca - (ca - ai);\n+        final double aLow = ai - aHigh;\n+\n+        final double bi = b[i];\n+        final double cb = SPLIT_FACTOR * bi;\n+        final double bHigh = cb - (cb - bi);\n+        final double bLow = bi - bHigh;\n+        prodHigh[i] = ai * bi;\n+        final double prodLow = aLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n+        prodLowSum += prodLow;\n+    }\n \n-        for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n+    double sHighPrev = prodHigh[0];\n+    double sLowSum = 0;\n \n+    for (int i = 1; i < len; i++) {\n+        final double prodHighNext = prodHigh[i];\n+        final double sHighCur = sHighPrev + prodHighNext;\n+        final double sPrime = sHighCur - prodHighNext;\n+        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+        sHighPrev = sHighCur;\n+    }\n \n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n+    double result = sHighPrev + (prodLowSum + sLowSum);\n \n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n+    if (Double.isNaN(result)) {\n+        result = 0;\n+        for (int i = 0; i < len; ++i) {\n+            result += a[i] * b[i];\n         }\n+    }\n \n-        double result = sHighPrev + (prodLowSum + sLowSum);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n-        }\n+    return result;\n+}\n \n-        return result;\n-    }\n \n     /**\n      * Compute a linear combination accurately."}
{"project": "Math", "bug_id": "5", "eval": "PASS", "attempt": 20, "mode": "SL", "patch": "            return Complex.INF;", "diff": "diff --git a/src/main/java/org/apache/commons/math3/complex/Complex.java b/src/main/java/org/apache/commons/math3/complex/Complex.java\nindex 22b23f24e..c5eb0b8f5 100644\n--- a/src/main/java/org/apache/commons/math3/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math3/complex/Complex.java\n@@ -302,7 +302,7 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n         }\n \n         if (real == 0.0 && imaginary == 0.0) {\n-            return NaN;\n+            return Complex.INF;\n         }\n \n         if (isInfinite) {"}
{"project": "Math", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "9", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "10", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "11", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "12", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "17", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "21", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "26", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "28", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n            for (Integer row : minRatioPositions) {\n                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                    int column = i + tableau.getArtificialVariableOffset();\n                    final double entry = tableau.getEntry(row, column);\n                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                        return row;\n                    }\n                }\n            }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            Integer minRow = null;\n            int minIndex = tableau.getWidth();\n            for (Integer row : minRatioPositions) {\n                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n                    if (row.equals(tableau.getBasicRow(i))) {\n                        minRow = row;\n                        minIndex = i;\n                        break;\n                    }\n                }\n            }\n            return minRow;\n        }\n        return minRatioPositions.get(0);\n    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\nindex a84438d9b..66f3adda2 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexSolver.java\n@@ -87,6 +87,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n      * @param col the column to test the ratio of.  See {@link #getPivotColumn(SimplexTableau)}\n      * @return row with the minimum ratio\n      */\n+\n     private Integer getPivotRow(SimplexTableau tableau, final int col) {\n         // create a list of all the rows that tie for the lowest score in the minimum ratio test\n         List<Integer> minRatioPositions = new ArrayList<Integer>();\n@@ -116,43 +117,35 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n             // there's a degeneracy as indicated by a tie in the minimum ratio test\n \n             // 1. check if there's an artificial variable that can be forced out of the basis\n-                for (Integer row : minRatioPositions) {\n-                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n-                        int column = i + tableau.getArtificialVariableOffset();\n-                        final double entry = tableau.getEntry(row, column);\n-                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n-                            return row;\n-                        }\n+            for (Integer row : minRatioPositions) {\n+                for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n+                    int column = i + tableau.getArtificialVariableOffset();\n+                    final double entry = tableau.getEntry(row, column);\n+                    if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n+                        return row;\n                     }\n                 }\n+            }\n \n             // 2. apply Bland's rule to prevent cycling:\n             //    take the row for which the corresponding basic variable has the smallest index\n-            //\n-            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n-            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n-            //\n-            // Additional heuristic: if we did not get a solution after half of maxIterations\n-            //                       revert to the simple case of just returning the top-most row\n-            // This heuristic is based on empirical data gathered while investigating MATH-828.\n-                Integer minRow = null;\n-                int minIndex = tableau.getWidth();\n-                for (Integer row : minRatioPositions) {\n-                    int i = tableau.getNumObjectiveFunctions();\n-                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n-                        if (row == tableau.getBasicRow(i)) {\n-                            if (i < minIndex) {\n-                                minIndex = i;\n-                                minRow = row;\n-                            }\n-                        }\n+            Integer minRow = null;\n+            int minIndex = tableau.getWidth();\n+            for (Integer row : minRatioPositions) {\n+                for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n+                    if (row.equals(tableau.getBasicRow(i))) {\n+                        minRow = row;\n+                        minIndex = i;\n+                        break;\n                     }\n                 }\n-                return minRow;\n+            }\n+            return minRow;\n         }\n         return minRatioPositions.get(0);\n     }\n \n+\n     /**\n      * Runs one iteration of the Simplex method on the given model.\n      * @param tableau simple tableau for the problem"}
{"project": "Math", "bug_id": "30", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "        final double n1n2prod = n1 * (double) n2;", "diff": "diff --git a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\nindex ce694ce8f..42324e74a 100644\n--- a/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n+++ b/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java\n@@ -170,7 +170,7 @@ public class MannWhitneyUTest {\n                                              final int n2)\n         throws ConvergenceException, MaxCountExceededException {\n \n-        final int n1n2prod = n1 * n2;\n+        final double n1n2prod = n1 * (double) n2;\n \n         // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n         final double EU = n1n2prod / 2.0;"}
{"project": "Math", "bug_id": "31", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "32", "eval": "PASS", "attempt": 15, "mode": "SL", "patch": "            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {", "diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\nindex c6e7cf18c..6bc289ff0 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java\n@@ -133,7 +133,7 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {\n \n         if (v.length == 0) {\n             final BSPTree<Euclidean2D> tree = getTree(false);\n-            if ((Boolean) tree.getAttribute()) {\n+            if (tree.getAttribute() instanceof Boolean && (Boolean) tree.getAttribute()) {\n                 // the instance covers the whole space\n                 setSize(Double.POSITIVE_INFINITY);\n                 setBarycenter(Vector2D.NaN);"}
{"project": "Math", "bug_id": "33", "eval": "PASS", "attempt": 19, "mode": "SL", "patch": "            if (Precision.compareTo(entry, 0d, epsilon) > 0) {", "diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\nindex 9a6993a55..327b2ae65 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java\n@@ -335,7 +335,7 @@ class SimplexTableau implements Serializable {\n         // positive cost non-artificial variables\n         for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n             final double entry = tableau.getEntry(0, i);\n-            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n+            if (Precision.compareTo(entry, 0d, epsilon) > 0) {\n                 columnsToDrop.add(i);\n             }\n         }"}
{"project": "Math", "bug_id": "34", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return Collections.unmodifiableList(chromosomes).iterator();", "diff": "diff --git a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\nindex 1eb005316..bb9e18201 100644\n--- a/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n+++ b/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java\n@@ -206,6 +206,6 @@ public abstract class ListPopulation implements Population {\n      * @return chromosome iterator\n      */\n     public Iterator<Chromosome> iterator() {\n-        return chromosomes.iterator();\n+        return Collections.unmodifiableList(chromosomes).iterator();\n     }\n }"}
{"project": "Math", "bug_id": "38", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "39", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "40", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "41", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "                for (int i = begin; i < begin + length; i++) {", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\nindex e5518e31a..1de139f3e 100644\n--- a/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n+++ b/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java\n@@ -517,7 +517,7 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se\n                 }\n \n                 double sumWts = 0;\n-                for (int i = 0; i < weights.length; i++) {\n+                for (int i = begin; i < begin + length; i++) {\n                     sumWts += weights[i];\n                 }\n "}
{"project": "Math", "bug_id": "42", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "43", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "45", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "48", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "50", "eval": "PASS", "attempt": 3, "mode": "SH", "patch": "\n                    if (x == x1) {\n                        x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f1 = computeObjectiveValue(x1);\n                    }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e47d98204..8f6545b51 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -184,10 +184,12 @@ public abstract class BaseSecantSolver\n                     break;\n                 case REGULA_FALSI:\n                     // Nothing.\n+\n                     if (x == x1) {\n-                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n-                        f0 = computeObjectiveValue(x0);\n+                        x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x1), atol));\n+                        f1 = computeObjectiveValue(x1);\n                     }\n+\n                     break;\n                 default:\n                     // Should never happen."}
{"project": "Math", "bug_id": "51", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "52", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "53", "eval": "PASS", "attempt": 5, "mode": "SH", "patch": "\n        if (Double.isNaN(rhs.getReal()) || Double.isNaN(rhs.getImaginary()))\n            return createComplex(Double.NaN, Double.NaN);\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/complex/Complex.java b/src/main/java/org/apache/commons/math/complex/Complex.java\nindex e0a8e97e9..2ab77081c 100644\n--- a/src/main/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/main/java/org/apache/commons/math/complex/Complex.java\n@@ -150,6 +150,10 @@ public class Complex implements FieldElement<Complex>, Serializable  {\n     public Complex add(Complex rhs)\n         throws NullArgumentException {\n         MathUtils.checkNotNull(rhs);\n+\n+        if (Double.isNaN(rhs.getReal()) || Double.isNaN(rhs.getImaginary()))\n+            return createComplex(Double.NaN, Double.NaN);\n+\n         return createComplex(real + rhs.getReal(),\n             imaginary + rhs.getImaginary());\n     }"}
{"project": "Math", "bug_id": "54", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "55", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "56", "eval": "PASS", "attempt": 6, "mode": "SH", "patch": "\n        int idxRemaining = index - count;\n        int idx = idxRemaining >= 0 ? idxRemaining : 0;\n        indices[last] = idx;\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\nindex 56c9ffebc..4ef2c8736 100644\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n@@ -234,14 +234,12 @@ public class MultidimensionalCounter implements Iterable<Integer> {\n             indices[i] = idx;\n         }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n-        }\n-        --idx;\n+\n+        int idxRemaining = index - count;\n+        int idx = idxRemaining >= 0 ? idxRemaining : 0;\n         indices[last] = idx;\n \n+\n         return indices;\n     }\n "}
{"project": "Math", "bug_id": "57", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            double sum = 0;", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\nindex b73ac9d3e..e09bbc357 100644\n--- a/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n+++ b/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java\n@@ -172,7 +172,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {\n         while (resultSet.size() < k) {\n             // For each data point x, compute D(x), the distance between x and\n             // the nearest center that has already been chosen.\n-            int sum = 0;\n+            double sum = 0;\n             for (int i = 0; i < pointSet.size(); i++) {\n                 final T p = pointSet.get(i);\n                 final Cluster<T> nearest = getNearestCluster(resultSet, p);"}
{"project": "Math", "bug_id": "58", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "59", "eval": "PASS", "attempt": 12, "mode": "SL", "patch": "        return (a >= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);", "diff": "diff --git a/src/main/java/org/apache/commons/math/util/FastMath.java b/src/main/java/org/apache/commons/math/util/FastMath.java\nindex 8cba4d484..bd48c417a 100644\n--- a/src/main/java/org/apache/commons/math/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math/util/FastMath.java\n@@ -3479,7 +3479,7 @@ public class FastMath {\n      * @return b if a is lesser or equal to b, a otherwise\n      */\n     public static float max(final float a, final float b) {\n-        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n+        return (a >= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n     }\n \n     /** Compute the maximum of two values"}
{"project": "Math", "bug_id": "60", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "63", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "64", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "69", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "70", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "72", "eval": "PASS", "attempt": 3, "mode": "SF", "patch": "\npublic double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // return the initial guess if it is good enough\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    // return the first endpoint if it is good enough\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n\n    // reduce interval if min and initial bracket the root\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n\n    // return the second endpoint if it is good enough\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // reduce interval if initial and max bracket the root\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    return solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..de5a12ef0 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,54 +95,56 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+public double solve(final UnivariateRealFunction f,\n+                    final double min, final double max, final double initial)\n+    throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n+    clearResult();\n+    verifySequence(min, initial, max);\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+    // return the initial guess if it is good enough\n+    double yInitial = f.value(initial);\n+    if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        setResult(initial, 0);\n+        return result;\n+    }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+    // return the first endpoint if it is good enough\n+    double yMin = f.value(min);\n+    if (Math.abs(yMin) <= functionValueAccuracy) {\n+        setResult(min, 0);\n+        return result;\n+    }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+    // reduce interval if min and initial bracket the root\n+    if (yInitial * yMin < 0) {\n+        return solve(f, min, yMin, initial, yInitial, min, yMin);\n+    }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-        }\n+    // return the second endpoint if it is good enough\n+    double yMax = f.value(max);\n+    if (Math.abs(yMax) <= functionValueAccuracy) {\n+        setResult(max, 0);\n+        return result;\n+    }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+    // reduce interval if initial and max bracket the root\n+    if (yInitial * yMax < 0) {\n+        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+    }\n \n+    if (yMin * yMax > 0) {\n+        throw MathRuntimeException.createIllegalArgumentException(\n+              NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n     }\n \n+    // full Brent algorithm starting with provided initial guess\n+    return solve(f, min, yMin, max, yMax, initial, yInitial);\n+\n+}\n+\n+\n     /**\n      * Find a zero in the given interval.\n      * <p>"}
{"project": "Math", "bug_id": "73", "eval": "PASS", "attempt": 1, "mode": "SH", "patch": "\n        // throw IllegalArgumentException if the function has same sign at min, initial and max\n        if (yInitial * yMin > 0 && yInitial * yMax > 0) {\n            throw new IllegalArgumentException(\"non-bracketing\");\n        }\n", "diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..a229e5658 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -134,6 +134,12 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         }\n \n \n+        // throw IllegalArgumentException if the function has same sign at min, initial and max\n+        if (yInitial * yMin > 0 && yInitial * yMax > 0) {\n+            throw new IllegalArgumentException(\"non-bracketing\");\n+        }\n+\n+\n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n "}
{"project": "Math", "bug_id": "74", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "75", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        return getCumPct((Comparable<?>) v)/2;", "diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..76a88f51a 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -300,7 +300,7 @@ public class Frequency implements Serializable {\n      */\n     @Deprecated\n     public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+        return getCumPct((Comparable<?>) v)/2;\n     }\n \n     /**"}
{"project": "Math", "bug_id": "78", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "79", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "80", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "82", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {", "diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\nindex 8309d7b40..60a1b3ac5 100644\n--- a/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n+++ b/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java\n@@ -79,7 +79,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {\n         for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n             final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n             final double entry = tableau.getEntry(i, col);\n-            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n+            if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                 final double ratio = rhs / entry;\n                 if (ratio < minRatio) {\n                     minRatio = ratio;"}
{"project": "Math", "bug_id": "84", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "85", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        if (fa * fb > 0.0) {", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\nindex bf3e4bf53..974b8564e 100644\n--- a/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n+++ b/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java\n@@ -195,7 +195,7 @@ public class UnivariateRealSolverUtils {\n         } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                 ((a > lowerBound) || (b < upperBound)));\n    \n-        if (fa * fb >= 0.0 ) {\n+        if (fa * fb > 0.0) {\n             throw new ConvergenceException(\n                       \"number of iterations={0}, maximum iterations={1}, \" +\n                       \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +"}
{"project": "Math", "bug_id": "86", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                     final double relativeSymmetryThreshold,\n                                     final double absolutePositivityThreshold)\n        throws NonSquareMatrixException,\n               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n\n        if (!matrix.isSquare()) {\n            throw new NonSquareMatrixException(matrix.getRowDimension(),\n                                               matrix.getColumnDimension());\n        }\n\n        final int order = matrix.getRowDimension();\n        lTData   = matrix.getData();\n        cachedL  = null;\n        cachedLT = null;\n\n        // check the matrix before transformation\n        for (int i = 0; i < order; ++i) {\n\n            final double[] lI = lTData[i];\n\n            if (lTData[i][i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            // check off-diagonal elements (and reset them to 0)\n            for (int j = i + 1; j < order; ++j) {\n                final double[] lJ = lTData[j];\n                final double lIJ = lI[j];\n                final double lJI = lJ[i];\n                final double maxDelta =\n                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n                if (Math.abs(lIJ - lJI) > maxDelta) {\n                    throw new NotSymmetricMatrixException();\n                }\n                lJ[i] = 0;\n           }\n        }\n\n        // transform the matrix\n        for (int i = 0; i < order; ++i) {\n\n            final double[] ltI = lTData[i];\n\n            // check diagonal element\n            if(ltI[i] < absolutePositivityThreshold) {\n                throw new NotPositiveDefiniteMatrixException();\n            }\n            ltI[i] = Math.sqrt(ltI[i]);\n            final double inverse = 1.0 / ltI[i];\n\n            for (int q = order - 1; q > i; --q) {\n                ltI[q] *= inverse;\n                final double[] ltQ = lTData[q];\n                for (int p = q; p < order; ++p) {\n                    ltQ[p] -= ltI[q] * ltI[p];\n                }\n            }\n\n        }\n\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\nindex acd9222f6..f00f39e67 100644\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -90,6 +90,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n+\n     public CholeskyDecompositionImpl(final RealMatrix matrix,\n                                      final double relativeSymmetryThreshold,\n                                      final double absolutePositivityThreshold)\n@@ -134,7 +135,9 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n             final double[] ltI = lTData[i];\n \n             // check diagonal element\n-\n+            if(ltI[i] < absolutePositivityThreshold) {\n+                throw new NotPositiveDefiniteMatrixException();\n+            }\n             ltI[i] = Math.sqrt(ltI[i]);\n             final double inverse = 1.0 / ltI[i];\n \n@@ -150,6 +153,7 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n \n     }\n \n+\n     /** {@inheritDoc} */\n     public RealMatrix getL() {\n         if (cachedL == null) {"}
{"project": "Math", "bug_id": "87", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "88", "eval": "PASS", "attempt": 1, "mode": "SF", "patch": "\n    protected RealPointValuePair getSolution() {\n        double[] coefficients = new double[getOriginalNumDecisionVariables()];\n        Integer basicRow =\n            getBasicRow(getNumObjectiveFunctions() + getOriginalNumDecisionVariables());\n        double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n        for (int i = 0; i < coefficients.length; i++) {\n            basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n            coefficients[i] =\n                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n                (restrictToNonNegative ? 0 : mostNegative);\n            if (basicRow != null) {\n                for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                    if (tableau.getEntry(basicRow, j) == 1) {\n                         coefficients[j - getNumObjectiveFunctions()] = 0;\n                    }\n                }\n            }\n        }\n        return new RealPointValuePair(coefficients, f.getValue(coefficients));\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\nindex 3bcb17f2a..61b8b7677 100644\n--- a/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n+++ b/src/java/org/apache/commons/math/optimization/linear/SimplexTableau.java\n@@ -321,6 +321,7 @@ class SimplexTableau implements Serializable {\n      * </p>\n      * @return current solution\n      */\n+\n     protected RealPointValuePair getSolution() {\n         double[] coefficients = new double[getOriginalNumDecisionVariables()];\n         Integer basicRow =\n@@ -328,15 +329,13 @@ class SimplexTableau implements Serializable {\n         double mostNegative = basicRow == null ? 0 : getEntry(basicRow, getRhsOffset());\n         for (int i = 0; i < coefficients.length; i++) {\n             basicRow = getBasicRow(getNumObjectiveFunctions() + i);\n-                // if multiple variables can take a given value \n-                // then we choose the first and set the rest equal to 0\n-                coefficients[i] =\n-                    (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n-                    (restrictToNonNegative ? 0 : mostNegative);\n+            coefficients[i] =\n+                (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) -\n+                (restrictToNonNegative ? 0 : mostNegative);\n             if (basicRow != null) {\n                 for (int j = getNumObjectiveFunctions(); j < getNumObjectiveFunctions() + i; j++) {\n                     if (tableau.getEntry(basicRow, j) == 1) {\n-                         coefficients[i] = 0;\n+                         coefficients[j - getNumObjectiveFunctions()] = 0;\n                     }\n                 }\n             }\n@@ -344,6 +343,7 @@ class SimplexTableau implements Serializable {\n         return new RealPointValuePair(coefficients, f.getValue(coefficients));\n     }\n \n+\n     /**\n      * Subtracts a multiple of one row from another.\n      * <p>"}
{"project": "Math", "bug_id": "89", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public void addValue(Object v) {\n        if(v instanceof Comparable) {\n            addValue((Comparable<?>) v);\n        } else {\n            throw new IllegalArgumentException(\"Argument must be comparable\");\n        }\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/stat/Frequency.java b/src/java/org/apache/commons/math/stat/Frequency.java\nindex c8deca31a..08a5be6cb 100644\n--- a/src/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/java/org/apache/commons/math/stat/Frequency.java\n@@ -106,9 +106,15 @@ public class Frequency implements Serializable {\n      * @deprecated use {@link #addValue(Comparable)} instead\n      */\n     @Deprecated\n+\n     public void addValue(Object v) {\n-            addValue((Comparable<?>) v);            \n+        if(v instanceof Comparable) {\n+            addValue((Comparable<?>) v);\n+        } else {\n+            throw new IllegalArgumentException(\"Argument must be comparable\");\n+        }\n     }\n+\n     \n     /**\n      * Adds 1 to the frequency count for v."}
{"project": "Math", "bug_id": "91", "eval": "PASS", "attempt": 10, "mode": "SH", "patch": "\n        double nOd = this.numerator * object.denominator;\n        double dOn = this.denominator * object.numerator;\n", "diff": "diff --git a/src/java/org/apache/commons/math/fraction/Fraction.java b/src/java/org/apache/commons/math/fraction/Fraction.java\nindex 0706f8c41..614c5748e 100644\n--- a/src/java/org/apache/commons/math/fraction/Fraction.java\n+++ b/src/java/org/apache/commons/math/fraction/Fraction.java\n@@ -256,8 +256,10 @@ public class Fraction extends Number implements Comparable<Fraction> {\n      *         than <tt>object</tt>, 0 if they are equal.\n      */\n     public int compareTo(Fraction object) {\n-        double nOd = doubleValue();\n-        double dOn = object.doubleValue();\n+\n+        double nOd = this.numerator * object.denominator;\n+        double dOn = this.denominator * object.numerator;\n+\n         return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0);\n     }\n     "}
{"project": "Math", "bug_id": "94", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        if (u == 0 || v == 0) {", "diff": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex c5342aeb3..841714262 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,7 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+        if (u == 0 || v == 0) {\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to"}
{"project": "Math", "bug_id": "95", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    protected double getInitialDomain(double p) {\n        double d = getDenominatorDegreesOfFreedom();\n        // use mean\n        double ret = d / (d - 2.0);\n        \n        // If the result is not within the allowed range, default to 0\n        if (ret < 0 || ret > 1) {\n            ret = 0;\n        }\n        return ret;\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\nindex e19e97aef..5b8ff35fa 100644\n--- a/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n+++ b/src/java/org/apache/commons/math/distribution/FDistributionImpl.java\n@@ -140,13 +140,19 @@ public class FDistributionImpl\n      * @param p the desired probability for the critical value\n      * @return initial domain value\n      */\n+\n     protected double getInitialDomain(double p) {\n-        double ret;\n         double d = getDenominatorDegreesOfFreedom();\n-            // use mean\n-            ret = d / (d - 2.0);\n+        // use mean\n+        double ret = d / (d - 2.0);\n+        \n+        // If the result is not within the allowed range, default to 0\n+        if (ret < 0 || ret > 1) {\n+            ret = 0;\n+        }\n         return ret;\n     }\n+\n     \n     /**\n      * Modify the numerator degrees of freedom."}
{"project": "Math", "bug_id": "96", "eval": "PASS", "attempt": 3, "mode": "SL", "patch": "                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary()); ", "diff": "diff --git a/src/java/org/apache/commons/math/complex/Complex.java b/src/java/org/apache/commons/math/complex/Complex.java\nindex 3571567f8..f24c169f8 100644\n--- a/src/java/org/apache/commons/math/complex/Complex.java\n+++ b/src/java/org/apache/commons/math/complex/Complex.java\n@@ -255,7 +255,7 @@ public class Complex implements Serializable  {\n                 if (rhs.isNaN()) {\n                     ret = this.isNaN();\n                 } else {\n-                    ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n+                    ret = (real == rhs.getReal()) && (imaginary == rhs.getImaginary()); \n                 }\n             } catch (ClassCastException ex) {\n                 // ignore exception"}
{"project": "Math", "bug_id": "97", "eval": "PASS", "attempt": 8, "mode": "SF", "patch": "\npublic double solve(double min, double max) throws MaxIterationsExceededException, \n        FunctionEvaluationException {\n\n    clearResult();\n    verifyInterval(min, max);\n\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n\n    // Verify bracketing\n    double sign = yMin * yMax;\n    if (sign > 0) {\n        // check if either value is close to a zero\n        if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n            return min;\n        } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n            return max;\n        } else {\n            // neither value is close to zero and min and max do not bracket root.\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" +\n                    \"  Endpoints: [\" + min + \",\" + max + \"]\" +\n                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n    } else {\n        // solve using only the first endpoint as initial guess\n        return solve(min, yMin, max, yMax, min, yMin);\n    }\n}\n", "diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..a4e962b43 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,36 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n+\n+public double solve(double min, double max) throws MaxIterationsExceededException, \n         FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        \n-        double ret = Double.NaN;\n-        \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n-        \n-        // Verify bracketing\n-        double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+\n+    clearResult();\n+    verifyInterval(min, max);\n+\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+\n+    // Verify bracketing\n+    double sign = yMin * yMax;\n+    if (sign > 0) {\n+        // check if either value is close to a zero\n+        if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+            return min;\n+        } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+            return max;\n         } else {\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n-            // either min or max is a root\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\" +\n+                    \"  Endpoints: [\" + min + \",\" + max + \"]\" +\n+                    \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n         }\n-\n-        return ret;\n+    } else {\n+        // solve using only the first endpoint as initial guess\n+        return solve(min, yMin, max, yMax, min, yMin);\n     }\n+}\n+\n         \n     /**\n      * Find a zero starting search according to the three provided points."}
{"project": "Math", "bug_id": "101", "eval": "PASS", "attempt": 4, "mode": "SH", "patch": "\n        if (endIndex > source.length() ||\n", "diff": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex b404bc415..897e2484f 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -374,7 +374,9 @@ public class ComplexFormat extends Format implements Serializable {\n         int n = getImaginaryCharacter().length();\n         startIndex = pos.getIndex();\n         int endIndex = startIndex + n;\n-        if (\n+\n+        if (endIndex > source.length() ||\n+\n             source.substring(startIndex, endIndex).compareTo(\n             getImaginaryCharacter()) != 0) {\n             // set index back to initial, error index should be the start index"}
{"project": "Math", "bug_id": "102", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "103", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "104", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "105", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Math", "bug_id": "106", "eval": "PASS", "attempt": 2, "mode": "SF", "patch": "\n    public Fraction parse(String source, ParsePosition pos) {\n        // try to parse improper fraction\n        Fraction ret = super.parse(source, pos);\n        if (ret != null) {\n            return ret;\n        }\n\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse whole\n        Number whole = getWholeFormat().parse(source, pos);\n        if (whole == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse numerator\n        Number num = getNumeratorFormat().parse(source, pos);\n        if (num == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // minus signs should be leading, invalid expression\n        if(num.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse '/'\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        switch (c) {\n        case 0 :\n            // no '/'\n            // return num as a fraction\n            return new Fraction(num.intValue(), 1);\n        case '/' :\n            // found '/', continue parsing denominator\n            break;\n        default :\n            // invalid '/'\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse denominator\n        Number den = getDenominatorFormat().parse(source, pos);\n        if (den == null) {\n            // invalid integer number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // minus signs must be leading, invalid\n        if(den.intValue() < 0) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        int w = whole.intValue();\n        int n = num.intValue();\n        int d = den.intValue();\n        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n    }\n", "diff": "diff --git a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\nindex df2713da8..a116cbd90 100644\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n@@ -127,83 +127,93 @@ public class ProperFractionFormat extends FractionFormat {\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n      */\n-    public Fraction parse(String source, ParsePosition pos) {\n-        // try to parse improper fraction\n-        Fraction ret = super.parse(source, pos);\n-        if (ret != null) {\n-            return ret;\n-        }\n-        \n-        int initialIndex = pos.getIndex();\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse whole\n-        Number whole = getWholeFormat().parse(source, pos);\n-        if (whole == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-        \n-        // parse numerator\n-        Number num = getNumeratorFormat().parse(source, pos);\n-        if (num == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-            // minus signs should be leading, invalid expression\n-\n-        // parse '/'\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n-        switch (c) {\n-        case 0 :\n-            // no '/'\n-            // return num as a fraction\n-            return new Fraction(num.intValue(), 1);\n-        case '/' :\n-            // found '/', continue parsing denominator\n-            break;\n-        default :\n-            // invalid '/'\n-            // set index back to initial, error index should be the last\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse denominator\n-        Number den = getDenominatorFormat().parse(source, pos);\n-        if (den == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-            // minus signs must be leading, invalid\n-\n-        int w = whole.intValue();\n-        int n = num.intValue();\n-        int d = den.intValue();\n-        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n-    }\n+\n+    public Fraction parse(String source, ParsePosition pos) {\n+        // try to parse improper fraction\n+        Fraction ret = super.parse(source, pos);\n+        if (ret != null) {\n+            return ret;\n+        }\n+\n+        int initialIndex = pos.getIndex();\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse whole\n+        Number whole = getWholeFormat().parse(source, pos);\n+        if (whole == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse numerator\n+        Number num = getNumeratorFormat().parse(source, pos);\n+        if (num == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // minus signs should be leading, invalid expression\n+        if(num.intValue() < 0) {\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // parse '/'\n+        int startIndex = pos.getIndex();\n+        char c = parseNextCharacter(source, pos);\n+        switch (c) {\n+        case 0 :\n+            // no '/'\n+            // return num as a fraction\n+            return new Fraction(num.intValue(), 1);\n+        case '/' :\n+            // found '/', continue parsing denominator\n+            break;\n+        default :\n+            // invalid '/'\n+            // set index back to initial, error index should be the last\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            pos.setErrorIndex(startIndex);\n+            return null;\n+        }\n+\n+        // parse whitespace\n+        parseAndIgnoreWhitespace(source, pos);\n+\n+        // parse denominator\n+        Number den = getDenominatorFormat().parse(source, pos);\n+        if (den == null) {\n+            // invalid integer number\n+            // set index back to initial, error index should already be set\n+            // character examined.\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        // minus signs must be leading, invalid\n+        if(den.intValue() < 0) {\n+            pos.setIndex(initialIndex);\n+            return null;\n+        }\n+\n+        int w = whole.intValue();\n+        int n = num.intValue();\n+        int d = den.intValue();\n+        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n+    }\n+\n     \n     /**\n      * Modify the whole format."}
{"project": "Mockito", "bug_id": "1", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "12", "eval": "PASS", "attempt": 7, "mode": "SF", "patch": "\n    public Class<?> getGenericType(Field field) {\n        Type generic = field.getGenericType();\n        if (generic != null && generic instanceof ParameterizedType) {\n            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n            if (actual instanceof Class) {\n                return (Class<?>) actual;\n            } else if (actual instanceof ParameterizedType) {\n                return (Class<?>) ((ParameterizedType) actual).getRawType();\n            }\n        }\n\n        return Object.class;\n    }\n", "diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMaster.java b/src/org/mockito/internal/util/reflection/GenericMaster.java\nindex 64bf1540f..d133e80bb 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMaster.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMaster.java\n@@ -13,14 +13,19 @@ public class GenericMaster {\n      * @param field\n      * @return\n      */\n-    public Class getGenericType(Field field) {        \n-        Type generic = field.getGenericType();\n-        if (generic != null && generic instanceof ParameterizedType) {\n-            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n-                return (Class) actual;\n-                //in case of nested generics we don't go deep\n-        }\n-        \n-        return Object.class;\n-    }\n+\n+    public Class<?> getGenericType(Field field) {\n+        Type generic = field.getGenericType();\n+        if (generic != null && generic instanceof ParameterizedType) {\n+            Type actual = ((ParameterizedType) generic).getActualTypeArguments()[0];\n+            if (actual instanceof Class) {\n+                return (Class<?>) actual;\n+            } else if (actual instanceof ParameterizedType) {\n+                return (Class<?>) ((ParameterizedType) actual).getRawType();\n+            }\n+        }\n+\n+        return Object.class;\n+    }\n+\n }"}
{"project": "Mockito", "bug_id": "13", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "26", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        primitiveValues.put(double.class, 0.0);", "diff": "diff --git a/src/org/mockito/internal/util/Primitives.java b/src/org/mockito/internal/util/Primitives.java\nindex b44b8253d..0eefbb615 100644\n--- a/src/org/mockito/internal/util/Primitives.java\n+++ b/src/org/mockito/internal/util/Primitives.java\n@@ -63,6 +63,6 @@ public class Primitives {\n         primitiveValues.put(int.class, 0);\n         primitiveValues.put(long.class, 0L);\n         primitiveValues.put(float.class, 0F);\n-        primitiveValues.put(double.class, 0);\n+        primitiveValues.put(double.class, 0.0);\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "28", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "29", "eval": "PASS", "attempt": 1, "mode": "SL", "patch": "        description.appendText(String.valueOf(wanted));", "diff": "diff --git a/src/org/mockito/internal/matchers/Same.java b/src/org/mockito/internal/matchers/Same.java\nindex 6c172fee2..45e7ba4af 100644\n--- a/src/org/mockito/internal/matchers/Same.java\n+++ b/src/org/mockito/internal/matchers/Same.java\n@@ -26,7 +26,7 @@ public class Same extends ArgumentMatcher<Object> implements Serializable {\n     public void describeTo(Description description) {\n         description.appendText(\"same(\");\n         appendQuoting(description);\n-        description.appendText(wanted.toString());\n+        description.appendText(String.valueOf(wanted));\n         appendQuoting(description);\n         description.appendText(\")\");\n     }"}
{"project": "Mockito", "bug_id": "33", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Mockito", "bug_id": "34", "eval": "PASS", "attempt": 8, "mode": "SL", "patch": "            if (m instanceof CapturesArguments && k < i.getArguments().length){", "diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex c72b119dd..f68b3387d 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -103,10 +103,10 @@ public class InvocationMatcher implements PrintableInvocation, PrintingFriendlyI\n     public void captureArgumentsFrom(Invocation i) {\n         int k = 0;\n         for (Matcher m : matchers) {\n-            if (m instanceof CapturesArguments) {\n+            if (m instanceof CapturesArguments && k < i.getArguments().length){\n                 ((CapturesArguments) m).captureFrom(i.getArguments()[k]);\n             }\n             k++;\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}
{"project": "Mockito", "bug_id": "38", "eval": "PASS", "attempt": 2, "mode": "SL", "patch": "        return arg == null ? StringDescription.toString(m).equals(null) : StringDescription.toString(m).equals(arg.toString());", "diff": "diff --git a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\nindex 671fbc539..7d6294195 100644\n--- a/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n+++ b/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java\n@@ -44,7 +44,8 @@ public class ArgumentMatchingTool {\n         }\n     }\n \n+\n     private boolean toStringEquals(Matcher m, Object arg) {\n-        return StringDescription.toString(m).equals(arg.toString());\n+        return arg == null ? StringDescription.toString(m).equals(null) : StringDescription.toString(m).equals(arg.toString());\n     }\n }"}
{"project": "Time", "bug_id": "4", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "5", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "7", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "8", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "14", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "15", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "16", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "17", "eval": "PASS", "attempt": 17, "mode": "SF", "patch": "\n    public long adjustOffset(long instant, boolean earlierOrLater) {\n        // a bit messy, but will work in all non-pathological cases\n\n        // evaluate 3 hours before and after to work out if anything is happening\n        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        if (instantBefore == instantAfter) {\n            return instant;  // not an overlap (less than is a gap, equal is normal case)\n        }\n\n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        if (earlierOrLater) {\n            // We are finding the later offset, so we need to get the instant that follows the instantAfter\n            if (instant < instantAfter) {\n                instant = instantAfter;\n            }\n            while (convertUTCToLocal(instant) == local) {\n                instant += DateTimeConstants.MILLIS_PER_HOUR;\n            }\n        } else {\n            // We are finding the earlier offset, so we need to get the instant that precedes the instantBefore\n            if (instant > instantBefore) {\n                instant = instantBefore;\n            }\n            while (convertUTCToLocal(instant) == local) {\n                instant -= DateTimeConstants.MILLIS_PER_HOUR;\n            }\n        }\n\n        // calculate result\n        return convertLocalToUTC(local, false, instant);\n    }\n", "diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802a..c180885a 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1160,24 +1160,41 @@ public abstract class DateTimeZone implements Serializable {\n      * @param earlierOrLater  false for earlier, true for later\n      * @return the adjusted instant millis\n      */\n+\n     public long adjustOffset(long instant, boolean earlierOrLater) {\n         // a bit messy, but will work in all non-pathological cases\n-        \n+\n         // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         if (instantBefore == instantAfter) {\n             return instant;  // not an overlap (less than is a gap, equal is normal case)\n         }\n-        \n+\n         // work out range of instants that have duplicate local times\n         long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-        \n+        if (earlierOrLater) {\n+            // We are finding the later offset, so we need to get the instant that follows the instantAfter\n+            if (instant < instantAfter) {\n+                instant = instantAfter;\n+            }\n+            while (convertUTCToLocal(instant) == local) {\n+                instant += DateTimeConstants.MILLIS_PER_HOUR;\n+            }\n+        } else {\n+            // We are finding the earlier offset, so we need to get the instant that precedes the instantBefore\n+            if (instant > instantBefore) {\n+                instant = instantBefore;\n+            }\n+            while (convertUTCToLocal(instant) == local) {\n+                instant -= DateTimeConstants.MILLIS_PER_HOUR;\n+            }\n+        }\n+\n         // calculate result\n-          // currently in later offset\n-          // currently in earlier offset\n+        return convertLocalToUTC(local, false, instant);\n     }\n+\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n     //-----------------------------------------------------------------------"}
{"project": "Time", "bug_id": "18", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "19", "eval": "FAIL", "attempt": 20, "mode": "SL", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "20", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "22", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "23", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "24", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "25", "eval": "FAIL", "attempt": 20, "mode": "SH", "patch": "", "diff": ""}
{"project": "Time", "bug_id": "27", "eval": "FAIL", "attempt": 20, "mode": "SF", "patch": "", "diff": ""}
